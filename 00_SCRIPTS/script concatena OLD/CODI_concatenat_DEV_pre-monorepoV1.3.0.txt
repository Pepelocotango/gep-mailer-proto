=== PROJECTE CONCATENAT ===
Projecte: Gestor-Events_i_Personal
Branca: DEV_pre-monorepoV1.3.0
Data: 2025-11-11 13:30:53
==================================================

--- START: ../Gestor-Events_i_Personal/ARBRE_DIRECTORIS.txt -- branca DEV_pre-monorepoV1.3.0 ---
enllaç a Gestor-Events_i_Personal/
├── .github/
│   └── workflows/                # CI/CD: Conté els scripts per a la compilació automàtica a GitHub.
│       ├── build-linuxv20-04.yml # Script per compilar la versió per a Linux (AppImage).
│       ├── build-macos12.yml     # Script per compilar la versió per a macOS (DMG).
│       └── build-win10.yml       # Script per compilar la versió per a Windows (EXE).
├── build/                        # Carpeta de sortida per als fitxers de producció.
│   └── icons/                    # Icones per a la compilació.
│       └── icon.png              # Icona principal.
├── dist/                         # Carpeta de sortida de la compilació (build).
│   ├── linux-unpacked/           # Carpeta amb els fitxers desempaquetats per a Linux.
│   └── *.AppImage, *.yml, etc.   # Binaris i fitxers de configuració generats per electron-builder.
├── examples json/                # Exemples de fitxers JSON per a proves.
│   ├── example_all.json          # JSON amb dades completes.
│   ├── example_material.json     # JSON amb dades de material.
│   └── example_person.json       # JSON amb dades de contactes.
├── imatges/                      # Conté imatges i captures de pantalla per a la documentació.
│   └── en_construcció_GV.png     # Captura de pantalla de l'aplicació.
├── public/                       # Conté els actius públics que es copiaran a la carpeta de compilació.
│   └── *.png, *.ico, *.icns      # Diferents mides i formats de la icona de l'aplicació.
├── scripts/                      # Scripts d'utilitat per al procés de desenvolupament i compilació.
│   ├── templates/                # Plantilles utilitzades pels scripts.
│   │   └── index.css.template    # Plantilla per a l'arxiu index.css, amb marcadors per a les variables de tema.
│   └── build-theme.cjs           # Script per generar automàticament els fitxers de tema (CSS i TS) a partir de la configuració.
├── src/
│   ├── assets/                   # Actius (imatges, etc.) que són importats directament pel codi font.
│   │   └── splash/               # Imatges per a l'animació de la pantalla de benvinguda.
│   │       └── frame_*.png       # Seqüència d'imatges per a l'animació.
│   ├── components/               # Carpeta principal dels components de React que formen la UI.
│   │   ├── forms/                # Components reutilitzables de formularis.
│   │   │   └── MaterialForm.tsx  # Formulari reutilitzable per crear/editar ítems de material.
│   │   ├── modals/               # Sub-carpeta per a tots els diàlegs modals de l'aplicació.
│   │   │   ├── AboutModal.tsx                  # Finestra que mostra la informació "Sobre l'aplicació".
│   │   │   ├── AddMaterialFromTechSheetModal.tsx # Permet afegir un ítem a l'inventari des de la fitxa de bolo. [REFACTORITZAT: usa MaterialForm]
│   │   │   ├── AssignmentFormModal.tsx         # Formulari per crear/editar una assignació. [REFACTORITZAT: usa modalStore]
│   │   │   ├── ConfirmDeleteModal.tsx          # Modal genèric per a confirmacions d'eliminació.
│   │   │   ├── ConfirmDuplicateModal.tsx       # Avís de conflicte en crear una assignació duplicada.
│   │   │   ├── ConfirmRepairModal.tsx          # Diàleg per confirmar la càrrega de dades reparades.
│   │   │   ├── CreateCalendarModal.tsx         # Formulari per crear un nou calendari de l'app a Google.
│   │   │   ├── EventFrameDetailsModal.tsx      # Mostra un resum detallat d'un esdeveniment.
│   │   │   ├── EventFrameFormModal.tsx         # Formulari per crear/editar un esdeveniment marc. [REFACTORITZAT: usa modalStore]
│   │   │   ├── GoogleEventDetailsModal.tsx     # Mostra els detalls complets d'un esdeveniment extern de Google Calendar.
│   │   │   ├── GoogleSettingsModal.tsx         # Panell de configuració de la integració amb Google Calendar.
│   │   │   ├── HistoryModal.tsx                # Modal que mostra l'historial de canvis (desfer/refer). Mostra la descripció de l'acció que es desfarà/refer (no la de l'estat actual).
│   │   │   ├── MergeOrReplaceModal.tsx         # Opcions per fusionar o reemplaçar dades en importar.
│   │   │   ├── SelectSyncCalendarModal.tsx     # Permet triar el calendari de destí per a la sincronització.
│   │   │   └── UpdateFromAssignmentsModal.tsx  # Previsualitza i aplica canvis des d'assignacions a la fitxa.
│   │   ├── tech_sheets/          # Components específics per a la gestió de les Fitxes de Bolo.
│   │   │   ├── ConditionalFormControl.tsx      # Component UI per a seccions que es mostren condicionalment (SI/NO).
│   │   │   ├── NeedsList.tsx                   # Renderitza les llistes de necessitats de material (llum, so, etc.).
│   │   │   ├── SortableProvider.tsx            # Component reutilitzable per a la funcionalitat de drag-and-drop.
│   │   │   ├── TechSheetField.tsx              # Component de camp de formulari genèric i reutilitzable.
│   │   │   ├── TechSheetForm.tsx               # !! Component central que munta tota la fitxa de bolo !!
│   │   │   ├── TechSheetSection.tsx            # Component de secció col·lapsable per organitzar la fitxa.
│   │   │   └── TechnicalPersonnelSection.tsx   # Gestiona la secció de personal tècnic de la fitxa.
│   │   └── ui/                   # Components genèrics reutilitzables (botons, tooltips, etc.).
│   │       ├── AutosizeTextarea.tsx            # Textarea que s'ajusta automàticament a l'alçada del contingut.
│   │       ├── CollapsibleSection.tsx          # Component de secció genèrica que es pot expandir/col·lapsar.
│   │       ├── CustomMenuBar.tsx               # Barra de menú personalitzada en React que substitueix la nativa. Inclou opcions d'accés ràpid a carpetes de logs i backups.
│   │       ├── Modal.tsx                       # Component base per a tots els diàlegs modals.
│   │       ├── SplashScreen.tsx                # Component que mostra una animació en iniciar l'app.
│   │       ├── SyncProgressOverlay.tsx         # Overlay amb la barra de progrés per a la sincronització.
│   │       ├── Tooltip.tsx                     # Component per a missatges d'ajuda emergents (usa Portals).
│   │       └── WelcomeScreen.tsx               # Pantalla de benvinguda per a la gestió de documents.
│   │   ├── AssignmentCard.tsx      # Renderitza una assignació individual dins d'un esdeveniment. [REFACTORITZAT: usa eventDataStore]
│   │   ├── Controls.tsx            # Barra de controls superior (desar, carregar, tema, etc.). [REFACTORITZAT: usa stores]
│   │   ├── ErrorBoundary.tsx       # Component de React per capturar errors de renderitzat i evitar que l'app es trenqui.
│   │   ├── EventFrameCard.tsx      # Renderitza una targeta per a un esdeveniment marc a la llista. [REFACTORITZAT: usa eventDataStore]
│   │   ├── MainDisplay.tsx         # Vista principal. Gestiona la detecció de conflictes en modificar estats. [REFACTORITZAT: usa stores]
│   │   ├── MaterialDisplay.tsx     # Vista per a la gestió de l'inventari de material. [REFACTORITZAT: usa MaterialForm]
│   │   ├── Navigation.tsx          # Barra de navegació entre les vistes principals.
│   │   ├── PeopleDisplay.tsx       # Vista per a la gestió de la llibreta d'adreces. [REFACTORITZAT: usa eventDataStore]
│   │   ├── SummaryReports.tsx      # Component que genera els resums de dades. [REFACTORITZAT: usa eventDataStore]
│   │   └── TechSheetsDisplay.tsx   # Nova vista per a la gestió de les Fitxes de Bolo. [REFACTORITZAT: usa eventDataStore]
│   ├── stores/                 # Gestors d'estat global (Zustand).
│   │   ├── eventDataStore.ts   # !! EL CERVELL DEL FRONTEND !! Store que centralitza tot l'estat i la lògica de negoci. Inclou historial desfer/refer, lògica d'arxivatge d'esdeveniments, i partialize memoitzada per evitar bucles infinits.
│   │   ├── googleConfigStore.ts# Store per a la configuració i estat de la integració amb Google Calendar.
│   │   ├── loggingMiddleware.ts# Middleware de Zustand per registrar accions i canvis d'estat.
│   │   └── modalStore.ts       # Store centralitzat per a l'estat i la lògica dels modals.
│   ├── utils/
│   │   ├── colorUtils.ts         # Utilitat per convertir colors (ex: HSL a RGB) per a la generació de PDF.
│   │   ├── csvUtils.ts           # Utilitats per a la generació i escapat de fitxers CSV. Inclou funcions per formatar cel·les, afegir BOM per compatibilitat Excel, i exportar llistes filtrades.
│   │   ├── dataIntegrity.ts      # Lògica per validar i reparar dades carregades des d'un fitxer. Comprova la integritat referencial, elimina elements trencats i documenta les correccions aplicades.
│   │   ├── dataMigration.ts      # Scripts per convertir formats de dades antics al format actual. Permet migració transparent i retrocompatibilitat amb versions anteriors.
│   │   ├── dateFormat.ts         # Utilitats per a la conversió i format de dates.
│   │   ├── dateRangeFormatter.ts # Utilitat per crear rangs de dates compactes (ex: 14/05-16/05).
│   │   ├── fileNameUtils.ts      # Mòdul centralitzat per a la generació intel·ligent de noms de fitxer per a exportacions.
│   │   ├── logger.ts             # Client de logging del frontend que envia missatges al backend.
│   │   ├── pdfGenerator.ts       # Tota la lògica per crear els diferents documents PDF, ara utilitzant colors temàtics.
│   │   ├── statusUtils.ts        # Funcions per gestionar i mostrar els estats de les assignacions.
│   │   ├── techSheetMigration.ts   # Lògica específica per migrar l'estructura de les fitxes de bolo. Converteix dades antigues a l'estructura moderna de TechSheetData, assegura compatibilitat i integritat, i gestiona casos especials amb defaults i validació. Utilitzat en la càrrega de documents i migració automàtica.
│   │   ├── themeDefinition.ts    # [AUTO-GENERAT] Objecte TS amb colors per a la generació de PDFs. No editar manualment.
│   │   ├── notificationService.ts # Servei centralitzat per mostrar notificacions (toasts) i missatges globals a la UI. Integrat amb modalStore i la lògica de feedback d'usuari.
│   │   ├── selectors.ts           # Selectors optimitzats per Zustand. Permeten accedir a porcions de l'estat de forma memoitzada i evitar re-renderitzats innecessaris. Inclou la lògica de filtrat per a esdeveniments arxivats.
│   ├── App.tsx                   # Component arrel de React. Gestiona l'enrutament, modals i estat de la UI. [REFACTORITZAT: usa stores de Zustand]
│   ├── calendar-styles.d.ts      # Definició de tipus per a la importació de fitxers CSS a TypeScript.
│   ├── constants.tsx             # Emmagatzema constants i icones SVG reutilitzables.
│   ├── images.d.ts               # Permet la importació de fitxers d'imatge (.png) a TypeScript.
│   ├── index.css                 # [AUTO-GENERAT] Fitxer principal d'estils. No editar manualment.
│   ├── index.tsx                 # Punt d'entrada de React que renderitza l'App al DOM.
│   └── types.ts                  # Fitxer crític. Defineix totes les interfícies i tipus de dades de l'aplicació (EventFrame amb el flag isArchived, Assignment, MaterialItem, TechSheetData, AppData, GoogleConfig, ElectronAPI). La font de veritat per la robustesa i mantenibilitat del projecte.
├── .gitattributes                # Fitxer per definir atributs per a rutes de git.
├── .gitignore                    # Especifica quins fitxers i carpetes ignorar en el control de versions (Git).
├── DEVELOPING.md                 # Documentació tècnica detallada de l'arquitectura i funcionalitats per a desenvolupadors.
├── LICENSE                       # Fitxer de llicència del projecte.
├── README.md                     # Documentació principal del projecte: funcionalitats, instal·lació i ús.
├── index.html                    # El punt d'entrada HTML on es munta l'aplicació de React.
├── main.cjs                      # !! EL CERVELL DEL BACKEND !! Procés principal d'Electron. Gestiona finestres, fitxers i API externes.
│   # Lògica de backups/tancament: main.cjs implementa la gestió automàtica de còpies de seguretat per document, neteja de backups antics, flux de tancament intel·ligent amb confirmació d'usuari, i bloqueig d'instància única per evitar errors d'escriptura simultània.
├── metadata.json                 # Metadades del projecte.
├── package.json                  # Fitxer de configuració del projecte: dependències, scripts i metadades.
├── package-lock.json             # Fitxer generat automàticament que bloqueja les versions de les dependències.
├── postcss.config.cjs            # Fitxer de configuració per a PostCSS (usat per Tailwind).
├── preload.cjs                   # Pont de seguretat d'Electron que exposa funcions del backend al frontend de manera segura.
├── tailwind.config.cjs           # Fitxer de configuració per al framework de CSS Tailwind.
├── theme.config.cjs              # !! FONT ÚNICA DE LA VERITAT PER ALS COLORS !! Defineix tota la paleta de colors per als temes i la generació de PDF.
├── tsconfig.json                 # Fitxer de configuració del compilador de TypeScript.
└── vite.config.ts                # Fitxer de configuració de Vite, l'eina de compilació del frontend.
--- END: ../Gestor-Events_i_Personal/ARBRE_DIRECTORIS.txt -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/DEVELOPING.md -- branca DEV_pre-monorepoV1.3.0 ---
branca de desenvolupament * REFAC_OK-PER-REVISAR16-9-25 ## ->PROVES DE REFACTORITZACIÓ
## DEVELOPING.md V1.3.0


# Guia de Desenvolupament: Gestor d'Esdeveniments i Personal

Aquest document proporciona una anàlisi tècnica detallada de l'arquitectura, les funcionalitats clau i les convencions de codi del projecte. Està dissenyat per a desenvolupadors que vulguin entendre el funcionament intern de l'aplicació, contribuir-hi o fer-ne el manteniment.

# NOVETATS V1.3.0 (Octubre 2025)

**Resum de canvis tècnics recents:**
- Refactorització completa de la gestió d'estat amb Zustand i zundo: stores independents, historial desfer/refer, partialize memoitzada per evitar bucles infinits.
- Nova lògica de backups automàtics i tancament intel·ligent: backups per document, neteja automàtica, eliminació de backups de sessió.
- Menú d'aplicació personalitzat en React: substitució del menú natiu d'Electron, comunicació frontend-backend via IPC.
- Gestió d'IPC centralitzada: canals segurs, separació de responsabilitats, API interna documentada.
- Solució als bucles infinits de renderitzat: selectors Zustand independents, gestió asíncrona de flags d'actualització.
- Exemples de selectors correctes amb Zustand:
```tsx
// Selector independent (evita bucles)
const materialItems = useEventDataStore(state => state.materialItems);

// Acció estable (no reactiva)
const { updateMaterialItem } = useEventDataStore.getState();

// Historial desfer/refer
import { useStore } from 'zustand';
const canUndo = useStore(useEventDataStore.temporal, s => s.pastStates.length > 0);
```
- **Disseny fluid (Full-Width):** S'ha eliminat el contenidor principal centrat en favor d'un disseny d'amplada completa amb `padding` horitzontal (`px-4 sm:px-6 lg:px-8`). Això optimitza l'ús de l'espai de la pantalla, especialment en monitors grans. La classe `.container` personalitzada ha estat eliminada de `index.css`.

**Shortcuts de teclat segons plataforma:** La UI ara mostra els shortcuts adequats segons la plataforma (Windows/Linux vs macOS). La detecció de la plataforma s'ha centralitzat a `App.tsx` per a una major fiabilitat, passant la tecla modificadora ("Ctrl" o "⌘") com a `prop` als components fills com el menú personalitzat.

Consulta les seccions corresponents per a detalls i exemples complets.

## 1. Visió General i Pila Tecnològica

### Visió General del Projecte

El "Gestor d'Esdeveniments i Personal" és una aplicació d'escriptori multiplataforma construïda amb Electron i React. El seu objectiu és oferir una solució integral per a la gestió d'esdeveniments, cobrint tot el cicle de vida:

-   **Planificació:** Creació d'esdeveniments marc i assignació de personal.
-   **Gestió de Recursos:** Manteniment d'una base de dades centralitzada de personal/proveïdors i un inventari de material amb control d'estoc.
-   **Documentació Tècnica:** Generació de "Fitxes de Bolo" detallades per a cada esdeveniment.
-   **Connectivitat:** Sincronització unidireccional amb múltiples calendaris de Google gestionats per l'app i visualització de calendaris externs.
-   **Anàlisi i Exportació:** Creació de resums de dades i exportació a formats estàndard com PDF i CSV.

L'aplicació està dissenyada per funcionar de manera totalment autònoma (offline), sent la integració amb serveis externs una capa opcional.

### Pila Tecnològica (Tech Stack)

El projecte es basa en un conjunt de tecnologies modernes de l'ecosistema JavaScript/TypeScript.

-   **Framework d'Aplicació:**
    -   **Electron `38.1.1`**: Permet construir aplicacions d'escriptori multiplataforma utilitzant tecnologies web.
    -   **Electron Builder `^24.13.3`**: Eina per empaquetar i distribuir l'aplicació per a Windows, macOS i Linux.

-   **Frontend:**
    -   **React `^18.3.1`**: Llibreria per construir la interfície d'usuari.
    -   **Vite `^6.3.5`**: Eina de desenvolupament i empaquetat per al frontend, oferint una experiència de desenvolupament ràpida.
    -   **TypeScript `~5.5.3`**: Afegeix un sistema de tipus a JavaScript per a un codi més robust i mantenible.

-   **Estils i UI:**
    -   **Tailwind CSS `^3.4.17`**: Framework CSS "utility-first" per a un disseny ràpid i personalitzat.
    -   **FullCalendar `^6.1.17`**: Llibreria potent per a la creació de calendaris interactius.
    -   **Headless UI / Heroicons**: Utilitzats implícitament per a components d'UI i icones.

-   **Integracions i Utilitats Clau:**
    -   **Google APIs (`googleapis` `^150.0.1`)**: Llibreria client de Google per interactuar amb serveis com Google Calendar.
    -   **Generació de PDF (`jspdf` `^3.0.1`, `jspdf-autotable` `^5.0.2`)**: Per a la creació de documents PDF natius des del client.

---

## 2. Arquitectura del Projecte

L'aplicació segueix una **arquitectura de tres capes** dissenyada per separar clarament les responsabilitats, millorar la seguretat i facilitar el manteniment.

### El Model de 3 Capes

1.  **Capa 1: Backend (Procés Principal d'Electron - `main.cjs`)**
    -   **Descripció:** És el "cervell" natiu de l'aplicació. S'executa en un entorn Node.js complet i té accés a les API del sistema operatiu.
    -   **Responsabilitats:**
        -   Gestionar el cicle de vida de l'aplicació i les finestres (`BrowserWindow`).
        -   Crear menús natius.
        -   Interactuar directament amb el sistema de fitxers (lectura/escriptura de JSON, gestió de backups i logs).
        -   Gestionar processos complexos com l'autenticació OAuth 2.0 amb Google.
        -   Realitzar totes les comunicacions amb API externes (Google Calendar).
        -   Exposar una API interna segura a través de canals IPC (Comunicació Inter-Processos).

2.  **Capa 2: Pont Segur (`preload.cjs`)**
    -   **Descripció:** És un script especial d'Electron que s'executa en un context privilegiat, actuant com a pont entre el backend i el frontend.
    -   **Responsabilitats:**
        -   Utilitzar el mòdul `contextBridge` per exposar de manera selectiva i segura funcions del backend al món del frontend.
        -   Garantir que el frontend no tingui accés directe a les API de Node.js, una pràctica de seguretat fonamental en Electron.
        -   Definir l'API `window.electronAPI`, que és l'únic punt de contacte entre les dues capes.
        -   Habilitació de la Sandbox: L'aplicació s'executa amb la sandbox d'Electron activada (sandbox: true). Això aïlla completament el procés de renderitzat (frontend), prevenint que pugui executar codi natiu directament. Tota operació que requereixi accés al sistema ha de passar obligatòriament a través dels canals IPC definits aquí.

3.  **Capa 3: Frontend (Interfície d'Usuari en React - `src/`)**
    -   **Descripció:** És una Single Page Application (SPA) que s'executa dins d'una finestra de Chromium. És responsable de tot el que l'usuari veu i amb què interactua.
    -   **Responsabilitats:**
        -   Renderitzar la interfície d'usuari.
        -   Gestionar l'estat de la UI (dades d'esdeveniments, formularis, modals, etc.).
        -   Implementar tota la lògica de negoci del client (filtratge de dades, validacions de formularis, detecció de conflictes).
        -   Invocar les funcions exposades pel backend a través de `window.electronAPI` per a qualsevol operació que requereixi accés al sistema (desar un fitxer, sincronitzar amb Google, etc.).

### Diagrama de Flux de Dades: Exemple d'una Acció de "Guardar"

Per il·lustrar com col·laboren aquestes capes, analitzem el flux quan un usuari desa totes les dades:

1.  **[Frontend]** L'usuari fa clic al botó "Guardar Tot" al component `Controls.tsx`.
2.  **[Frontend]** S'activa una funció que crida a l'acció `exportData()` de l'store de Zustand (`useEventDataStore`).
3.  **[Frontend - Zustand]** L'store recopila totes les dades del seu estat actual (`eventFrames`, `peopleGroups`, etc.) i les retorna com un objecte `AppData`.
4.  **[Frontend]** La funció crida a `window.electronAPI.showSaveDialog()` amb les dades serialitzades en format JSON.
5.  **[Pont]** `preload.cjs` rep la crida i, de forma segura, envia una petició IPC (`ipcRenderer.invoke`) al backend a través del canal `'show-save-dialog'`.
6.  **[Backend]** El gestor `ipcMain.handle('show-save-dialog', ...)` a `main.cjs` rep la petició.
7.  **[Backend]** Utilitzant el mòdul `dialog` d'Electron, obre una finestra de diàleg nativa del sistema operatiu perquè l'usuari triï on desar el fitxer.
8.  **[Backend]** Un cop l'usuari confirma, utilitza el mòdul `fs` de Node.js per escriure les dades rebudes al disc.
9.  **[Backend -> Pont -> Frontend]** El resultat de l'operació (èxit o error) es retorna a través de la `Promise` de `ipcRenderer.invoke`.
10. **[Frontend]** El component que va iniciar l'acció rep el resultat i mostra una notificació (toast) a l'usuari.

Aquest flux demostra la clara separació de responsabilitats: el frontend gestiona la UI i l'estat, mentre que el backend s'encarrega de les operacions a nivell de sistema, garantint seguretat i un rendiment natiu.



---

## 3. Backend: El Procés Principal d'Electron (`main.cjs`)

El fitxer `main.cjs` és el punt d'entrada i el nucli de l'aplicació. S'executa en un entorn Node.js complet, la qual cosa li atorga accés directe a les API del sistema operatiu per a la gestió de finestres, menús, sistema de fitxers i comunicacions de xarxa. Actua com el "cervell" que orquestra totes les operacions natives.

### 3.1. Sistema d'Arxius i Persistència de Dades

L'aplicació gestiona totes les dades de l'usuari localment, garantint el seu funcionament offline. La ubicació central de les dades de configuració és el directori de dades de l'usuari, proporcionat per Electron (`app.getPath('userData')`).

#### Estructura de Fitxers i Rutes Clau

Les rutes principals es defineixen com a constants a l'inici del fitxer:

-   `CONFIG_DIR`: Apunta a `app.getPath('userData')`. És el directori arrel per a totes les dades de configuració de l'aplicació.
-   `SESSION_FILE`: (`.../session.json`) Emmagatzema l'estat de la sessió. Les seves responsabilitats s'han ampliat:
    -   Estat de la finestra (mida i posició).
    -   `recentFiles`: Un array amb les rutes dels últims 10 documents oberts per l'usuari.
-   `BACKUP_DIR`: (`.../backups/`) Subdirectori on es guarden les còpies de seguretat del fitxer de dades per defecte. **Nota:** La lògica de backup actual encara està lligada a l'antic `events_data.json` i es manté per compatibilitat.
-   `LOGS_DIR`: (`.../logs/`) Subdirectori per als fitxers de log de cada sessió.
-   `GOOGLE_TOKENS_PATH`: (`.../google-tokens.json`) Emmagatzema els tokens d'accés i de refresc d'OAuth 2.0 un cop l'usuari s'ha autenticat.
-   `GOOGLE_CONFIG_PATH`: (`.../google-config.json`) Desa la configuració de Google Calendar. La seva estructura ha evolucionat per suportar múltiples calendaris:
    ```json
    {
      "userEmail": "usuari@exemple.com",
      "activeAppCalendarId": "id_calendari_actiu_123",
      "managedAppCalendars": [
        {
          "id": "id_calendari_actiu_123",
          "name": "Gestor d'Esdeveniments (App) - Teatre Principal",
          "suffix": "Teatre Principal"
        }
      ],
      "selectedCalendarIds": ["id_calendari_extern_per_visualitzar_abc"]
    }
    ```
    - `activeAppCalendarId`: L'ID del calendari que s'utilitzarà per defecte per a la propera sincronització.
    - `managedAppCalendars`: Una llista de tots els calendaris que l'aplicació ha creat i sobre els quals té permís d'escriptura.
    - `selectedCalendarIds`: Una llista d'IDs de calendaris (tant gestionats com externs) que l'usuari vol visualitzar al calendari principal.

#### Logs de Sessió amb `electron-log`

Per facilitar la depuració i mantenir uns registres nets en producció, l'aplicació utilitza la llibreria estàndard `electron-log`.

-   **Nivells de Log:** S'ha implementat un sistema de nivells de log semàntics:
    -   `debug`: Informació detallada només rellevant per al desenvolupament (p. ex., "[IPC_IN] Rebut 'accio'"). Aquest nivell està desactivat per defecte en producció.
    -   `info`: Esdeveniments importants del flux normal (p. ex., "Fitxer desat correctament").
    -   `warn`: Situacions inesperades que no aturen l'aplicació (p. ex., "El fitxer service-account.json no es troba").
    -   `error`: Errors crítics que han provocat una fallada.
-   **Configuració per Entorn:**
    -   **Desenvolupament:** Es registren tots els nivells (`debug` i superiors) tant a la consola com al fitxer.
    -   **Producció:** Només es registren els nivells `info`, `warn` i `error` al fitxer, per mantenir-lo concís i rellevant.
-   **Integració Transparent:** `electron-log` sobreescriu automàticament els mètodes de `console` (`log`, `error`, etc.). Això permet que les crides de log des del frontend siguin capturades pel backend i escrites al fitxer de log sense necessitat de cap canal IPC personalitzat.
-   **Accés per a l'Usuari:** S'ha afegit una opció de menú ("Ajuda -> Obrir Carpeta de Logs") que obre directament el directori on es desen els fitxers de log, facilitant a l'usuari final l'enviament de registres per a la depuració.
-   **Rotació per Mida:** En lloc de crear un fitxer nou a cada sessió, ara s'utilitza un fitxer principal (`main.log`). Quan aquest fitxer arriba a 1MB, es reanomena amb un timestamp (p. ex., `main.163...log`) i se'n crea un de nou.
-   **Retenció Automàtica:** El sistema conserva un màxim de 10 fitxers de log (1 actiu i 9 arxivats), eliminant automàticament els més antics per optimitzar l'ús de disc.

#### Còpies de Seguretat Contextuals (Backups)

El sistema de còpies de seguretat s'ha fet més intel·ligent per evitar backups innecessaris.

-   **Activació Contextual:** Les còpies de seguretat només es creen quan es desa un **document de dades principal** (`.json`), i **no** quan s'exporten altres tipus de fitxers (PDF, CSV).
-   **Implementació Tècnica:**
    -   El gestor IPC `show-save-dialog` a `main.cjs` ara accepta un paràmetre booleà opcional: `isDocumentSave`.
    -   La lògica de `createBackup()` només s'executa si `isDocumentSave` és `true`.
    -   Totes les crides des del frontend (`App.tsx`, `pdfGenerator.ts`, etc.) han estat actualitzades per passar aquest flag correctament.
-   **Nomenclatura i Neteja:** La nomenclatura (amb el nom del document original) i la neteja automàtica (conservant els 5 backups més recents per document) es mantenen.

### 3.2. Cicle de Vida i Gestió de Finestres

El backend controla tots els aspectes del cicle de vida de l'aplicació, incloent un flux de tancament intel·ligent i segur.

#### Flux de Tancament Intel·ligent

El flux de sortida s'ha refactoritzat per eliminar els "backups de sessió" i alinear-se amb un model de gestió de documents, respectant sempre la decisió de l'usuari.

1.  **Interceptació del Tancament (`before-quit`):**
    -   Quan l'usuari intenta tancar l'aplicació, el listener `app.on('before-quit')` a `main.cjs` s'activa.
    -   Aquest listener desa l'estat de la finestra (mida/posició) i envia el senyal `'confirm-quit-signal'` al frontend, prevenint la sortida immediata per cedir el control.

2.  **Gestió Centralitzada al Frontend (`onConfirmQuit`):**
    -   Un listener a `App.tsx` rep el senyal i centralitza tota la lògica.
    -   **Sempre** es mostra un diàleg de confirmació a l'usuari per prevenir un tancament accidental.
        -   Si hi ha canvis no desats, el diàleg ofereix les opcions: "Desa", "Tanca sense desar" i "Cancel·la".
        -   Si no hi ha canvis, el diàleg simplement pregunta: "Estàs segur que vols sortir de l'aplicació?" amb les opcions "Sortir" i "Cancel·lar".
    -   En funció de la resposta, l'aplicació desa les dades si és necessari i finalment crida a l'IPC `quit-application` per tancar-se, o bé avorta el procés si l'usuari cancel·la.

3.  **Tancament Definitiu (`quit-application`):**
    -   El nou gestor IPC `quit-application` al backend té una única responsabilitat: marcar la variable `isQuitting` com a `true` i cridar a `app.quit()`.
    -   Això assegura que el segon esdeveniment `before-quit` no sigui interceptat, permetent que l'aplicació es tanqui de manera neta i definitiva.

El sistema de backups de sessió (`backup_sessio.json`) ha estat completament eliminat. Els backups ara només es creen de manera explícita quan l'usuari desa un document, com es descriu a la secció `Còpies de Seguretat (Backups)`.

#### Separació de Configuració Google

- **Configuració Local:**
  - Es desa a `google-config.json` (usuari). Inclou calendaris gestionats, calendaris externs, selecció d'ID, etc.
  - Camps com `externalCalendars`, `selectedIds` i preferències visuals són exclusius de l'usuari i no es modifiquen en obrir documents.
- **Configuració de Document:**
  - Quan s'obre un document, només s'actualitzen `activeAppCalendarId` i `managedAppCalendars` a la store, la resta de camps romanen intactes.
    - Això garanteix que la configuració local de l'usuari no es perdi ni se sobreescrigui accidentalment.

> **Nota important:** Els IDs dels calendaris gestionats (`managedAppCalendars`, `activeAppCalendarId`) estan lligats als fitxers de dades. Un usuari pot tenir diferents documents amb calendaris diferents. El logging OAuth (autenticació Google) és independent del document: l'usuari pot canviar de fitxer i de calendaris gestionats sense perdre la sessió ni la vinculació amb el seu compte Google.


#### Bloqueig d'Instància Única (Single Instance Lock)

Per prevenir errors crítics de tipus `write EIO` (Error d'Entrada/Sortida) i condicions de cursa (`race conditions`), l'aplicació implementa un bloqueig que assegura que només una instància pugui estar en execució al mateix temps.

Aquest error es produïa quan dues instàncies de l'aplicació intentaven escriure simultàniament al mateix fitxer de configuració (p. ex., `session.json`) durant el procés de tancament, causant una fallada del sistema de fitxers.

La solució s'implementa a l'inici de `main.cjs` utilitzant `app.requestSingleInstanceLock()`. La primera instància que s'obre obté el "candau" i s'executa amb normalitat. Si un usuari intenta obrir una segona instància, aquesta detectarà que el candau ja està agafat, posarà la finestra de la primera instància en primer pla (`mainWindow.focus()`) i es tancarà automàticament.

Això no només soluciona el bug d'escriptura, sinó que també millora l'experiència d'usuari evitant finestres duplicades.


#### Creació de la Finestra (`createWindow`)

Aquesta funció s'encarrega de:
1.  Assegurar que tots els directoris necessaris existeixin (`ensureDirectoriesExist`).
2.  Carregar les credencials de Google si estan disponibles (`loadGoogleCredentials`).
3.  Llegir `session.json` per restaurar la mida i posició anteriors de la finestra.
4.  Crear la `BrowserWindow` amb les opcions de seguretat adequades, incloent la càrrega del script `preload.cjs`.
5.  Carregar la URL del servidor de desenvolupament de Vite o el fitxer `index.html` de producció.
6.  Construir i establir el menú natiu de l'aplicació (`Menu.buildFromTemplate`).

#### Flux de Tancament Intel·ligent

El flux de tancament de l'aplicació ha estat redissenyat per utilitzar un únic diàleg intel·ligent i garantir backups incondicionals. Per a una descripció detallada del procés, consulteu la secció **3.2. Cicle de Vida i Gestió de Finestres > Flux de Tancament Intel·ligent (Diàleg Únic)**.

#### Gestió d'Excepcions

El procés principal inclou un gestor `process.on('uncaughtException')` com a última línia de defensa. Si es produeix un error no controlat, s'escriu al fitxer de log, es mostra un diàleg d'error a l'usuari i es tanca l'aplicació de manera forçada per evitar un estat inconsistent.

### 3.3. Menú d'Aplicació Personalitzat (Custom Menu Bar)

Per solucionar un bug de renderitzat del menú natiu d'Electron en configuracions de múltiples pantalles a Linux, s'ha reemplaçat el menú natiu per un component de menú personalitzat construït amb React.

#### Arquitectura de la Solució

1.  **Desactivació del Menú Natiu (`main.cjs`):**
    -   A la configuració de `BrowserWindow`, s'ha afegit la propietat `autoHideMenuBar: true`. Això amaga la barra de menú per defecte, però encara permet accedir-hi prement la tecla `Alt`.
    -   Les línies `Menu.buildFromTemplate(template)` i `Menu.setApplicationMenu(menu)` han estat comentades per desactivar completament la creació del menú natiu.

2.  **Component de React (`src/components/ui/CustomMenuBar.tsx`):**
    -   S'ha creat un nou component de React que replica visualment i funcionalment l'estructura del menú anterior.
    -   Aquest component gestiona el seu propi estat per controlar la visibilitat dels menús desplegables.

3.  **Comunicació Frontend -> Backend (`trigger-menu-action`):**
    -   Quan un usuari fa clic a un element del menú, el component de React crida a la funció `window.electronAPI.triggerMenuAction(action)`, passant una cadena que identifica l'acció (p. ex., `'save-all'`, `'reload'`).
    -   Aquesta funció està exposada de manera segura a través de `preload.cjs`.

4.  **Gestor d'Accions Centralitzat (`main.cjs`):**
    -   S'ha implementat un nou listener `ipcMain.on('trigger-menu-action', ...)` que actua com un enrutador per a totes les accions del menú.
    -   **Accions del Procés Principal:** Les accions que requereixen accés a les API d'Electron o Node.js (com obrir diàlegs de fitxers, gestionar el zoom de la finestra o tancar l'aplicació) són gestionades directament dins d'aquest listener.
    -   **Accions del Procés de Renderitzat:** Les accions que afecten l'estat de la UI (com canviar de tema, desar dades, obrir modals, o executar desfer/refer) es redirigeixen al procés de renderitzat a través del canal IPC existent `'menu-action'`, on són gestionades pel listener corresponent a `App.tsx`.

Aquest enfocament no només soluciona el bug original, sinó que també proporciona un control total sobre l'aparença i el comportament del menú, permetent una integració més profunda amb el disseny de l'aplicació. El menú "Edita" s'ha afegit seguint aquest mateix patró. Les dreceres de teclat per a accions comunes com "Eines de Desenvolupament" i "Pantalla Completa" s'han actualitzat per mostrar els estàndards de cada plataforma (`⌘+⌥+I` i `⌃+⌘+F` a macOS respectivament).

### 3.4. API Interna: Gestors d'IPC (Inter-Process Communication)

La comunicació entre el frontend i el backend es realitza exclusivament a través de canals IPC. `main.cjs` defineix diversos gestors (`ipcMain.handle` i `ipcMain.on`) que conformen l'API interna de l'aplicació.

-   **Gestió de Dades de Documents:**
    -   `open-file-dialog`: Obre un diàleg natiu per seleccionar un fitxer i retorna la ruta seleccionada.
    -   `read-file`: Llegeix el contingut d'un fitxer donada una ruta.
    -   `save-file`: Desa un contingut a una ruta de fitxer específica, sobreescrivint-lo.
    -   `show-save-dialog`: Obre un diàleg de desat natiu i, si l'usuari confirma, desa el contingut a la nova ruta.

-   **Gestió de Sessió:**
    -   `get-recent-files`: Retorna la llista de fitxers recents des de `session.json`.
    -   `add-recent-file`: Afegeix una ruta a la llista de fitxers recents.

-   **Handlers Obsolets:**
    -   `load-app-data`: Encara existeix per a la seqüència d'inici, però ara només retorna `null`.
    -   `save-app-data`, `getDefaultDataPath`: Han estat eliminats.

-   **Integració amb Google:**
    -   `google-auth-start`: Inicia el flux d'autenticació OAuth 2.0.
    -   `load-google-config`, `save-google-config`: Llegeixen i escriuen les preferències de l'usuari per a Google Calendar.
    -   `google-get-calendar-list`: Obté la llista de calendaris del compte de l'usuari.
    -   `get-google-events`: Recupera esdeveniments dels calendaris seleccionats per a visualització.
    -   `google-get-event-details`: Obté tots els detalls d'un esdeveniment específic de Google Calendar a partir del seu `calendarId` i `eventId`.
    -   `sync-with-google(payload)`: Orquestra la sincronització unidireccional cap a un calendari específic.
    -   `create-new-app-calendar(suffix)`: Crea un nou calendari gestionat per l'app.
    -   `delete-app-calendar(calendarId)`: Elimina un calendari gestionat específic.
    -   `google-disconnect`: Desconnecta el compte de Google i elimina tots els calendaris gestionats.

-   **Accions de l'Aplicació:**
    -   `get-app-metadata`: Retorna metadades de l'aplicació (nom, versió, descripció) llegides de `package.json` i `metadata.json`.
    -   `factory-reset`: Realitza una restauració de fàbrica eliminant els fitxers de configuració de l'aplicació.
    -   `quit-application`: Inicia el procés de tancament definitiu de l'aplicació.

-   **Interacció amb UI Nativa:**
    -   `show-save-dialog`: Permet al frontend obrir un diàleg de desat natiu.
    -   `show-unsaved-changes-dialog`: Mostra el diàleg personalitzat de canvis no desats en sortir.

    ---

### 3.5. Integració amb Serveis Externs: Google Calendar API

Aquesta secció ha estat refactoritzada per suportar múltiples calendaris. Per a una descripció detallada del nou flux, vegeu la secció **5.1. Flux de Sincronització amb Google Calendar (Multi-Calendari)**.

---

## 4. Frontend: Gestió d'Estat i Lògica de la UI (React)

El frontend és una Single Page Application (SPA) construïda amb React i TypeScript. La seva arquitectura ha estat refactoritzada per utilitzar **Zustand** com a eina principal per a la gestió de l'estat global.

### 4.1. Gestió d'Estat Centralitzada amb Zustand

L'estat global del frontend es gestiona a través de *stores* de Zustand, la qual cosa desacobla la lògica de l'estat dels components de React i millora el rendiment.

#### Stores de Zustand (`src/stores/`)

1.  **`eventDataStore.ts`**:
    -   **Descripció:** És la **font única de veritat** per a totes les dades principals de l'aplicació (esdeveniments, contactes, material).
    -   **Contingut:**
        -   **Estat:** Emmagatzema els arrays de `eventFrames`, `peopleGroups`, `materialItems`, l'estat de `hasUnsavedChanges`, etc.
        -   **Accions:** Conté totes les funcions per manipular aquestes dades (CRUD: `addEventFrame`, `updateAssignment`, etc.), la lògica de negoci (detecció de conflictes, disponibilitat de material), i la interacció amb el backend per a la persistència de dades (`loadData`, `exportData`).
    -   **Middleware:**
        -   **`immer`**: Permet escriure lògica de mutació d'estat de manera més senzilla i segura, com si es mutés l'estat directament.
        -   **`temporal` (de `zundo`)**: Envolta l'store per afegir automàticament la funcionalitat de desfer/refer (`undo`/`redo`) a totes les modificacions de l'estat.

2.  **`googleConfigStore.ts`**:
    -   **Descripció:** Gestiona tot l'estat i la lògica relacionats amb la configuració de Google Calendar.
    -   **Contingut:**
        -   **Estat:** Emmagatzema els `managedCalendars`, `externalCalendars`, `selectedIds`, `activeCalendarId`, i els estats de `loading` i `error`.
        -   **Accions:** Centralitza tota la interacció amb el backend per a la configuració de Google, incloent `fetchAndLoadConfig`, `saveConfig`, `createNewCalendar`, `deleteCalendar` i `disconnectGoogle`.

3.  **`modalStore.ts`**:
    -   **Descripció:** Gestiona quin modal està obert (`type`), les dades inicials amb què es va obrir (`data`) i si és visible (`isOpen`). També actua com un vehicle per a funcionalitats globals com les notificacions.
    -   **Contingut:**
        -   **`showToast`**: Manté una referència a la funció `showToast` creada a `App.tsx`. Això permet que altres stores (com `googleConfigStore`) puguin disparar notificacions a la UI de manera desacoblada.

#### Middleware de Depuració (`loggingMiddleware.ts`)

El projecte inclou un middleware de Zustand personalitzat a `src/stores/loggingMiddleware.ts` dissenyat per a la depuració.

- **Funcionalitat:** Quan s'aplica a un store, aquest middleware registra automàticament cada acció que es crida, l'estat *abans* del canvi, i l'estat *després* del canvi. Això és extremadament útil durant el desenvolupament per traçar com i per què canvia l'estat.
- **Ús:** Actualment, aquest middleware **no està actiu** a cap dels stores de producció per evitar sobrecarregar la consola. No obstant això, un desenvolupador pot activar-lo fàcilment per depurar un store específic.

Per exemple, per activar-lo a `eventDataStore.ts`, s'hauria d'importar i embolcallar la definició de l'store:

```typescript
import { loggingMiddleware } from './loggingMiddleware';
// ...

export const useEventDataStore = create<...>()(
  loggingMiddleware( // <-- Embolcallar amb el middleware
    temporal(
      immer(
        (set, get) => ({
          // ... contingut de l'store
        })
      )
    ),
    'eventDataStore' // <-- Nom per al logging
  )
);
```

#### Patró d'Ús de Zustand als Components

-   **Accés a l'Estat (Reactiu):** Els components se subscriuen de manera selectiva només a les porcions (`slices`) de l'estat que necessiten per renderitzar-se. Això evita re-renderitzats innecessaris.
    ```tsx
    // Aquest component només es tornarà a renderitzar quan `hasUnsavedChanges` canviï.
    const hasUnsavedChanges = useEventDataStore(state => state.hasUnsavedChanges);
    ```

-   **Accés a les Accions (No Reactiu):** Com que les funcions d'acció són estables, es poden obtenir directament de l'store amb `getState()` dins de gestors d'esdeveniments (`event handlers`) per evitar passar-les com a `props` o incloure-les a les dependències dels `useEffect`.
    ```tsx
    const handleAdd = () => {
      const { addEventFrame } = useEventDataStore.getState();
      addEventFrame({ /* ...dades... */ });
    };
    ```

-   **Accés a l'Store Temporal (Desfer/Refer):** Per interactuar amb l'estat de l'historial (p. ex., per activar/desactivar botons), s'ha d'utilitzar un hook `useStore` específic importat de Zustand.
    ```tsx
    import { useStore } from 'zustand';

    const canUndo = useStore(useEventDataStore.temporal, state => state.pastStates.length > 0);
    const { undo } = useEventDataStore.temporal.getState();
    ```

#### Historial d'Accions Visual (Desfer/Refer)

La funcionalitat d'historial desfer/refer utilitza Zustand + zundo amb una optimització clau:

- **Descripció d'acció:** Cada acció que modifica l'estat actualitza `lastActionDescription` amb un text clar (ex: "Creat esdeveniment: 'Nom'").
- **Notificacions:** Les funcions `undoWithToast` i `redoWithToast` mostren un toast amb la descripció de l'acció desfer/refer.
- **Neteja d'historial:** L'historial es neteja automàticament en carregar un nou document.
- **Visualitzador interactiu:** El modal `HistoryModal.tsx` mostra la llista d'accions passades/futures. Ara la descripció de cada acció a desfer/refer reflecteix l'acció que realment s'eliminarà (no la de l'estat actual), gràcies a una lògica que mostra la descripció del següent estat.
- **Optimització partialize:** La funció `partialize` del store està memoitzada per evitar bucles infinits de render, retornant el mateix objecte si l'estat no canvia.
### Correcció modal d'historial
El modal d'historial mostra ara la descripció de l'acció que es desfarà/refer, no la de l'estat actual. Això evita confusió i fa que el feedback sigui fidel a l'acció real.

### 4.2. Lògica de Gestió de Documents (`App.tsx`)
`App.tsx` orquestra tota la lògica del cicle de vida dels documents.

-   **Estat Clau:**
    -   `isDocumentOpen: boolean`: Controla si s'ha de mostrar la pantalla de benvinguda o la interfície principal de l'aplicació.
    -   `currentFilePath: string | null`: Emmagatzema la ruta del fitxer actualment obert. És `null` si es tracta d'un document nou que encara no s'ha desat.
    -   `recentFiles: string[]`: La llista de fitxers recents per mostrar a la UI.

-   **Funcions Gestores:**
    -   `handleNewDocument()`: Inicia un nou document buit.
    -   `handleOpenDocument(filePath?)`: Obre un document, ja sigui des d'un diàleg de fitxer o des de la llista de recents.
    -   `handleSaveDocument()`: Desa el document actual. Si no té ruta (`currentFilePath` és `null`), crida a `handleSaveAsDocument()`.
    -   `handleSaveAsDocument()`: Permet desar el document actual en una nova ubicació.
    -   `confirmContinueWithUnsavedChanges()`: Funció d'ajuda que comprova el "dirty flag" (`hasUnsavedChanges`) i mostra el diàleg de confirmació abans de realitzar una acció que podria causar pèrdua de dades (com crear un nou document o obrir-ne un altre).

### 4.3. Menú d'Aplicació i UI
-   **`WelcomeScreen.tsx`**: Nou component que actua com a pantalla d'inici, oferint accés ràpid a les accions de fitxer.
-   **`CustomMenuBar.tsx`**: El menú s'ha reestructurat per reflectir les accions estàndard de gestió de fitxers. Està connectat a l'estat d'`App.tsx` per activar/desactivar opcions de manera dinàmica (p. ex., "Guardar" només està actiu si hi ha canvis no desats).
-   **`Controls.tsx`**: Aquest component mostra ara la ruta del fitxer actiu (`currentFilePath`). La seva funcionalitat de càrrega/desat s'ha tornat redundant amb el nou menú, però es manté de moment.

### 4.4. Component Reutilitzable: `AutosizeTextarea`

Per donar resposta a la necessitat que les àrees de text s'ajustin al seu contingut, s'ha creat un nou component a `src/components/ui/AutosizeTextarea.tsx`.

-   **Funcionament:** El component embolcalla un `<textarea>` estàndard. Utilitza el hook `useLayoutEffect` per recalcular i ajustar l'alçada de l'element cada vegada que el seu valor canvia. `useLayoutEffect` es fa servir en lloc de `useEffect` per evitar un parpelleig visual, ja que el càlcul es realitza de manera síncrona després de les mutacions del DOM.
-   **Gestió de `ref` (Ref Forwarding):** Per solucionar l'advertència de React "Function components cannot be given refs", el component està embolicat amb `React.forwardRef`. Això li permet rebre una `ref` d'un component pare (com el component `Tooltip`, que la necessita per posicionar-se) i passar-la directament a l'element `<textarea>` intern. La lògica de `useLayoutEffect` també ha estat actualitzada per utilitzar aquesta `ref` reenviada.
-   **Integració:** Per aplicar aquest canvi de manera eficient, el component genèric `TechSheetField.tsx` ha estat modificat per renderitzar `AutosizeTextarea` quan se li passa la propietat `as="textarea"`. La resta de formularis de l'aplicació també han estat actualitzats per utilitzar aquest nou component.

### 4.4. Model de Dades i Tipus (`src/types.ts`)

Aquest fitxer és fonamental per a la robustesa del projecte. Defineix totes les estructures de dades clau mitjançant interfícies de TypeScript.

-   **`EventFrame`**: Representa un esdeveniment marc. Conté propietats com `id`, `name`, `startDate`, `endDate`, i, de manera crucial, un array niat `assignments: Assignment[]` i un objecte opcional `techSheet: TechSheetData`.
-   **`Assignment`**: Defineix una assignació de personal. Enllaça un `personGroupId` amb un `eventFrameId` i gestiona l'estat (`status`) i els estats diaris (`dailyStatuses`).
-   **`PersonGroup`**: Representa una entrada a l'agenda (una persona, una empresa, etc.).
-   **`MaterialItem`**: Defineix un article a l'inventari, amb propietats com `stock` i `category`.
-   **`TechSheetData`**: És una de les interfícies més complexes. Modela tota la informació d'una fitxa de bolo. S'han afegit els camps següents per a les notes generals de personal i necessitats tècniques:
    -   `technicalPersonnelNotes?: string`: Notes generals per a la secció de personal tècnic.
    -   `showTechnicalPersonnelNotesInPdf?: boolean`: Controla la visibilitat d'aquestes notes al PDF.
    -   `technicalNeedsNotes?: string`: Notes generals per a la secció de necessitats tècniques.
    -   `showTechnicalNeedsNotesInPdf?: boolean`: Controla la visibilitat d'aquestes notes al PDF.
-   **`AppData`**: Defineix l'estructura de l'objecte que es desa al fitxer de dades, amb llistes planes per a cada tipus de dada per facilitar la serialització.
-   **`GoogleConfig` i `ManagedAppCalendar`**: Tipifiquen la nova estructura de dades per a la configuració de Google.
-   **`ElectronAPI`**: Tipifica l'objecte `window.electronAPI`, proporcionant autocompletat i seguretat de tipus en les comunicacions amb el backend.

### 4.3. Estructura de Components i Vistes

El directori `src/components/` està organitzat seguint una lògica de funcionalitat.

-   **Vistes Principals (`src/components/`):**
    -   `MainDisplay.tsx`: La vista per defecte, que conté el calendari i la llista d'esdeveniments. També implementa la **lògica d'expansió automàtica** de la llista en aplicar filtres per millorar la usabilitat.
    -   `TechSheetsDisplay.tsx`: La vista per gestionar les fitxes de bolo.
    -   `PeopleDisplay.tsx`: La vista per a la gestió de la llibreta d'adreces.
-   **`MaterialDisplay.tsx`**: La vista per a la gestió de l'inventari de material. Ha estat **refactoritzada** per utilitzar el component `MaterialForm`.

-   **Components de Formularis Reutilitzables (`src/components/forms/`):**
    -   Aquest directori conté components de formulari dissenyats per ser reutilitzats en diferents parts de l'aplicació (p. ex., en vistes principals i en modals).
    -   `MaterialForm.tsx`: Un component controlat que encapsula la UI i la lògica de validació per crear i editar ítems de material. Rep `props` com `initialData`, `onSubmit` i `onCancel` per desacoblar-lo de la gestió de l'estat.

-   **Components de Lògica de Negoci:**
    -   `EventFrameCard.tsx`: Component complex que representa un esdeveniment a la llista. La seva capçalera està dissenyada per ser totalment clicable per expandir/col·lapsar el contingut. La lògica `onClick` de la capçalera comprova si el clic s'ha fet sobre un element interactiu (com un botó) per evitar l'expansió/col·lapse no desitjat, gestionant les interaccions de l'usuari de manera precisa. Conté la lògica per renderitzar la llista de `AssignmentCard`.
    -   `AssignmentCard.tsx`: Gestiona la presentació d'una única assignació. S'ha estandarditzat com `EventFrameCard` per permetre expandir/col·lapsar la vista diària fent clic a qualsevol lloc de la capçalera.
    -   `SummaryReports.tsx`: Calcula i renderitza les diferents vistes de resum de dades.

-   **Ecosistema de Fitxes de Bolo (`src/components/tech_sheets/`):**
    -   Aquest directori encapsula tota la complexitat de la fitxa de bolo. `TechSheetForm.tsx` actua com a component pare, orquestrant components fills especialitzats com `TechnicalPersonnelSection.tsx` i `NeedsList.tsx`. Aquesta modularitat permet aïllar la lògica i optimitzar el rendiment.

-   **Modals (`src/components/modals/`):**
    -   Cada modal té el seu propi component. La gestió de la seva visibilitat i de les dades amb què s'inicialitzen es controla a través del `modalStore`, tal com es descriu a la secció "Gestió de l'Estat dels Formularis".

-   **Components d'UI Genèrics (`src/components/ui/`):**
    -   Conté components reutilitzables i de presentació.
    -   `Modal.tsx`: Component base per a totes les finestres modals.
    -   `CollapsibleSection.tsx`: Un component clau per a l'organització de la UI. Ha estat dissenyat per funcionar de dues maneres:
        -   **Mode no controlat (per defecte):** Gestiona el seu propi estat d'expansió internament amb `useState`.
        -   **Mode controlat:** Si rep les propietats `isOpen` i `onToggle`, cedeix el control del seu estat a un component pare, permetent que l'estat d'expansió sigui gestionat per un store global com Zustand. Aquest patró s'utilitza per a la secció de la "Llista d'Esdeveniments".

### 4.4. Enrutament de l'Aplicació (`src/App.tsx`)

L'aplicació utilitza `react-router-dom` amb `HashRouter` per a la navegació entre les vistes principals. `HashRouter` és l'elecció estàndard per a aplicacions Electron, ja que funciona bé amb el protocol `file://` utilitzat en les builds de producció i evita problemes de configuració del servidor.

Les rutes principals definides són:
-   `/`: `MainDisplay`
-   `/tech-sheets`: `TechSheetsDisplay`
-   `/people`: `PeopleDisplay`
-   `/material`: `MaterialDisplay`

El component `Navigation.tsx` renderitza els enllaços (`NavLink`) que permeten a l'usuari moure's entre aquestes vistes.

---

## 5. Anàlisi Detallada de Funcionalitats Clau

Aquesta secció descriu el funcionament intern de les característiques més importants de l'aplicació, detallant la interacció entre el backend, el frontend i la lògica de negoci.

### 5.1. Flux de Sincronització amb Google Calendar (Multi-Calendari)

La integració amb Google Calendar s'ha refactoritzat per passar d'un model 1-a-1 (una app, un calendari) a un model **1-a-N** (una app, N calendaris). L'aplicació local continua sent sempre la font de veritat.

#### Arquitectura Híbrida d'Autenticació

El model híbrid es manté:
-   **Compte de Servei (`service-account.json`):** És l'autenticació principal de l'aplicació. Actua com una entitat pròpia i és la **propietària** dels calendaris de l'app. S'encarrega de totes les operacions d'escriptura (crear/eliminar calendaris, afegir/esborrar esdeveniments).
-   **OAuth 2.0 per a l'Usuari (`google-credentials.json`):** El flux de l'usuari s'utilitza per obtenir el seu email i per llegir els seus calendaris personals (només lectura).

#### Flux de Creació d'un Nou Calendari Gestionat

1.  **[UI]** L'usuari obre el modal de configuració de Google (`GoogleSettingsModal`) i fa clic a "+ Crear Nou".
2.  **[Frontend]** S'obre un nou modal dedicat (`CreateCalendarModal`) que demana un sufix per al nou calendari.
3.  **[Frontend]** En confirmar, el component crida a l'acció `createNewCalendar(suffix)` de l'store `useGoogleConfigStore`.
4.  **[Frontend - Zustand]** L'acció de l'store crida a `window.electronAPI.createNewAppCalendar(suffix)`.
5.  **[Backend]** El gestor `createNewAppCalendar` a `main.cjs` executa la mateixa lògica de creació i desat.
6.  **[Frontend - Zustand]** Un cop rep la resposta del backend, l'store actualitza el seu estat (`managedCalendars`, `activeCalendarId`) i refresca la llista completa de calendaris.
7.  **[Frontend]** Com que `GoogleSettingsModal` està subscrit a aquest store, es re-renderitza automàticament amb la nova llista de calendaris sense necessitat d'esdeveniments personalitzats. El modal de creació es tanca.

#### Flux de Sincronització Explícita

1.  **[UI]** L'usuari fa clic al botó principal "Sincronitzar" o al botó "Sincronitzar Ara" dins del modal de configuració.
2.  **[Frontend]** Es crida a l'acció `syncWithGoogle()` de l'store `useEventDataStore`.
3.  **[Frontend - Zustand]** L'acció `syncWithGoogle` conté la lògica d'orquestració:
    -   Crida a `window.electronAPI.loadGoogleConfig()` per obtenir la configuració actual.
    -   Si no hi ha calendaris gestionats, obre el modal de configuració (`googleSettings`) utilitzant `useModalStore`.
    -   Si n'hi ha, obre el modal de selecció (`selectSyncCalendar`), passant-li la llista de calendaris i l'ID actiu.
4.  **[Frontend]** Un cop l'usuari confirma el calendari al modal, s'invoca la funció `executeSync(targetCalendarId)` de l'store `useEventDataStore`.
5.  **[Frontend - Zustand]** L'acció `executeSync` crida a `window.electronAPI.syncWithGoogle({ localData, targetCalendarId })`.
5.  **[Backend]** El gestor `sync-with-google` a `main.cjs` executa la lògica:
    a. **Verificació i Autoreparació:** Comprova si `targetCalendarId` encara existeix a Google. Si rep un error `404 Not Found`, l'elimina de la llista `managedAppCalendars` a la configuració local i retorna un error `CALENDAR_NOT_FOUND` al frontend.
    b. **Confirmació de l'Usuari:** Mostra un diàleg advertint que l'operació sobreescriurà les dades.
    c. **Buidatge i Càrrega:** Si es confirma, buida completament el calendari de destinació i hi puja tots els esdeveniments locals, enriquint la descripció amb dades de la fitxa de bolo.
    d. **Actualització del Calendari Actiu:** Després d'una sincronització amb èxit, actualitza `activeAppCalendarId` al fitxer de configuració amb el `targetCalendarId` que s'acaba d'utilitzar.
6.  **[Frontend]** El frontend gestiona la resposta:
    -   En cas d'èxit, actualitza les dades i mostra una notificació.
    -   Si rep l'error `CALENDAR_NOT_FOUND`, mostra un missatge a l'usuari i torna a obrir el modal de selecció perquè pugui triar un altre calendari.

#### Flux de Neteja i Desconnexió

-   **Eliminació d'un Sol Calendari (`delete-app-calendar`):** Des del modal de configuració, l'usuari pot eliminar un calendari gestionat específic. Aquesta acció l'esborra de Google i de la llista `managedAppCalendars` a la configuració.
-   **Desconnexió Completa (`google-disconnect`):** Aquesta acció itera sobre **tots** els calendaris a `managedAppCalendars`, els elimina un per un de Google, revoca els tokens de l'usuari i esborra els fitxers de configuració locals.

### 5.2. Gestor de Fitxes de Bolo (`Tech Sheets`)

La gestió de fitxes de bolo és una de les funcionalitats més complexes, amb un model de dades jeràrquic i una interfície altament dinàmica.

#### Estructura de Dades (`types.ts`)

-   La informació es desa dins de cada `EventFrame` a la propietat `techSheet: TechSheetData`.
-   La clau de la gestió de personal és l'array `technicalProviders: TechSheetProvider[]`.
-   Cada `TechSheetProvider` enllaça un proveïdor de l'agenda (`personGroupId`) amb un array de rols (`roles: TechSheetRoleItem[]`). Aquesta estructura permet, per exemple, que l'empresa "So i Llum SL" (`PersonGroup`) proporcioni "2x Tècnic de So" i "1x Tècnic de Llums" (`TechSheetRoleItem[]`).

#### Lògica del Formulari (`TechSheetForm.tsx`)

-   **Inicialització:** Quan se selecciona un esdeveniment, el component `TechSheetForm` s'inicialitza amb les dades de `eventFrame.techSheet`. Si la propietat no existeix (dades antigues), la funció `createDefaultTechSheet` genera una estructura buida per evitar errors.

-   **Gestió de Desat Intel·ligent (UI Optimista + Debouncing):** Per solucionar la manca de fiabilitat del desat amb `onBlur` (propens a errors de *stale state*) i garantir la integritat de dades en temps real (especialment per al control d'estoc), s'ha implementat un sistema de desat híbrid i robust.
    -   **UI Optimista:** La interfície respon a l'instant als canvis de l'usuari. Quan es modifica una quantitat de material, per exemple, el càlcul de disponibilitat es refresca immediatament basant-se en l'estat intern del formulari, sense esperar el desat a l'estat central.
    -   **Desat Automàtic amb Temporitzador (Debouncing):** Quan l'usuari edita un camp, s'inicia un temporitzador. Si l'usuari fa una pausa, el sistema desa automàticament els canvis a l'estat central de l'aplicació. Això es gestiona amb un `useEffect` que observa canvis a `formData` i una referència (`useRef`) per al flag `isDirty` per evitar l'estat caduc.
    -   **Botó de Desat Manual:** S'ha afegit un botó "Desar Canvis" que s'activa només quan hi ha canvis pendents. Això dona a l'usuari control explícit per forçar un desat immediat si ho desitja.
    -   **Desat de Seguretat:** Com a mesura final de seguretat, una funció de neteja en un `useEffect` garanteix que qualsevol canvi pendent es desi automàticament si l'usuari canvia d'esdeveniment o navega fora de la pàgina, evitant qualsevol pèrdua de dades.

-   **Gestió de Llistes Dinàmiques:**
    -   Les funcions `handleListChange`, `onAddListItem`, i `onRemoveListItem` són **funcions d'ordre superior** que reben el nom de la llista (`'lightingNeeds'`, `'assemblySchedule'`, etc.) com a paràmetre. Aquesta abstracció permet reutilitzar la mateixa lògica per a totes les llistes de la fitxa.
    -   Cada ítem de llista ha de tenir un `id` únic (generat localment amb `generateLocalId`) per a un renderitzat eficient a React.

-   **Reordenació de Personal Tècnic (Drag-and-Drop):**
    -   **Tecnologia:** S'utilitza la llibreria `dnd-kit` per implementar la funcionalitat d'arrossegar i deixar anar.
    -   **Implementació:**
        -   El component `TechnicalPersonnelSection.tsx` embolcalla la llista de proveïdors amb `DndContext` i `SortableContext`.
        -   S'ha creat un component reutilitzable `SortableProvider.tsx` que utilitza el hook `useSortable` per fer que cada proveïdor sigui arrossegable.
        -   S'ha afegit una icona de "drag handle" a cada proveïdor per iniciar l'arrossegament.
        -   L'esdeveniment `onDragEnd` calcula el nou ordre i crida a l'acció `reorderTechnicalProviders` de l'store `eventDataStore.ts`.
    -   **Flux de Dades:** `onDragEnd` -> `reorderTechnicalProviders` (Zustand) -> Actualització de l'estat -> Re-renderitzat de la llista.

-  **Actualització Interactiva des d'Assignacions:** Per donar un control més gran a l'usuari, el botó **`⟳ Actualitza des d'assignacions`** ja no modifica directament la fitxa, sinó que obre un diàleg de confirmació.
    1.  **Càlcul de Canvis:** En fer clic, la lògica a `TechnicalPersonnelSection.tsx` compara el personal actual de la fitxa amb les assignacions confirmades i genera tres llistes: personal per afegir, personal per eliminar i personal per mantenir.
    2.  **Modal de Previsualització (`UpdateFromAssignmentsModal`):** Aquestes llistes s'envien a un nou modal que mostra cada canvi proposat (addicions en verd, eliminacions en vermell) amb una casella de selecció.
    3.  **Confirmació de l'Usuari:** L'usuari pot seleccionar quins canvis vol aplicar. Pot acceptar totes les suggestions, cap, o una combinació.
    4.  **Aplicació Selectiva:** Un cop confirmat, el modal retorna només els canvis seleccionats a `TechSheetForm.tsx`, que els aplica a l'estat, garantint que no es perdi cap entrada manual ni s'apliquin canvis no desitjats.
    5.  **Gestió d'Esdeveniments de Diversos Dies:** La lògica d'afegir nous rols des del modal inclou la funcionalitat de detallar els dies específics per a assignacions de tipus `Mixt`.



### 5.3. Centre de Control de Material (Càlcul de Pic de Demanda)

Aquesta secció ha estat completament redissenyada per oferir una anàlisi més potent i realista de les necessitats de material. En lloc de sumar tota la demanda, ara calcula el **pic de demanda concurrent** per a un període determinat, responent a la pregunta: "Quin és el nombre màxim d'unitats d'un ítem que necessitaré en un sol dia?".

#### Lògica de Càlcul (`selectMaterialControlData`)

La lògica principal resideix al selector `selectMaterialControlData` dins de `eventDataStore.ts`.

-   **Condició d'Activació:** El càlcul de pic de demanda només s'activa si l'usuari aplica un **filtre per esdeveniments o un rang de dates**. Si no hi ha cap d'aquests filtres actius, la vista mostra tots els ítems de l'inventari amb una demanda de 0, per a una gestió ràpida de l'estoc.

-   **Flux de Càlcul de Pic de Demanda:**
    1.  **Identificació d'Esdeveniments Rellevants:** El selector primer filtra la llista global d'esdeveniments per quedar-se només amb aquells que coincideixen amb els filtres actius.
    2.  **Càlcul per Ítem:** Per a cada `MaterialItem` de l'inventari:
        a.  Recopila totes les necessitats (`NeedItem`) d'aquest ítem dins dels esdeveniments rellevants.
        b.  Determina el rang de dates global (mínim i màxim) cobert per aquestes necessitats.
        c.  **Iteració Diària:** Recorre aquest rang dia per dia. Per a cada dia, suma la quantitat total de l'ítem requerida per tots els esdeveniments que estan actius en aquella data.
        d.  **Determinació del Pic:** Emmagatzema el valor diari més alt trobat durant la iteració. Aquest valor és el `totalDemand`.
    3.  **Càlcul del Balanç:** El balanç es calcula com `item.stock - totalDemand`. Un valor negatiu indica un dèficit en el dia de màxima demanda.

#### Lògica d'Ordenació Centralitzada i UI (`MaterialControlCenter.tsx`)

Per millorar la consistència i la claredat, la lògica d'ordenació de dades s'ha centralitzat i simplificat:

-   **Ordenació Jeràrquica Fixa:** Les dades del Centre de Control de Material ara s'ordenen sempre seguint una jerarquia estricta: 1r per **Categoria**, 2n per **Origen** (`location`), i 3r per **Nom**.
-   **Lògica Centralitzada:** Aquesta ordenació es realitza dins d'un `useMemo` al component `MaterialControlCenter.tsx`, just després de filtrar les dades. Això garanteix que tant la taula visual com totes les funcions d'exportació (PDF Resum, PDF Detallat, CSV) rebin exactament les mateixes dades ja ordenades.
-   **Eliminació d'Ordenació Interactiva:** Com a conseqüència, s'ha eliminat la possibilitat que l'usuari ordeni la taula fent clic a les capçaleres. S'ha netejat el codi de `MaterialControlTable.tsx` i `MaterialControlCenter.tsx`, eliminant els estats (`sortConfigs`), funcions (`requestSort`) i lògica de la UI que gestionaven l'ordenació dinàmica.
-   **Desglossament Enriquit:** Es manté el desglossament enriquit, que mostra el detall per esdeveniment amb les seves dates.



 #### Flux de Càlcul (`getMaterialAvailability`)

La funció implementa una lògica granular per garantir un càlcul d'estoc precís. Per evitar re-renderitzats innecessaris durant el càlcul, accedeix a l'estat directament amb `get()` dins de l'store.

 1.  **Entrades:** La funció rep l'ID del material (`materialId`), les dates de l'esdeveniment actual (`startDate`, `endDate`) i l'ID de l'esdeveniment actual (`currentEventFrameId`).
 2.  **Obtenció de l'Ítem:** Busca l'ítem de material a `materialItemsRef.current` per obtenir el seu estoc total (`materialItem.stock`). Si no el troba, retorna 0.
 3.  **Iteració per Dia i Càlcul de Disponibilitat Mínima:**
     -   La funció no comprova un simple solapament de rangs, sinó que itera sobre **cada dia individual** dins del rang de dates de l'esdeveniment que s'està consultant (`for (let d = new Date(start); d <= end; ...)`).
     -   Per a cada dia (`currentDate`), calcula l'estoc total compromès (`dailyCommittedStock`) per a aquest dia específic:
         -   Recorre tots els altres `eventFrames` (excloent l'actual per permetre l'edició).
         -   Comprova si l'altre esdeveniment està actiu en `currentDate`.
         -   Si és així, itera sobre les seves necessitats de material (`lightingNeeds`, `soundNeeds`, etc.) a la fitxa tècnica.
         -   Si una necessitat correspon al `materialId` consultat, suma la seva `quantity` a `dailyCommittedStock`.
     -   Calcula l'estoc disponible per a aquell dia (`availableOnDay = materialItem.stock - dailyCommittedStock`).
     -   Actualitza una variable `minAvailable` amb el valor més baix trobat fins ara. Aquest enfocament conservador assegura que el material estigui disponible durant **tot** el període.
 4.  **Resultat:** La funció retorna un objecte `{ total: materialItem.stock, available: minAvailable }`. El valor `available` representa la quantitat d'estoc que es pot garantir com a disponible durant tot el rang de dates de l'esdeveniment.


#### Integració a la UI (`NeedsList.tsx`)

-   El component `NeedsList` crida a `getMaterialAvailability` per a cada ítem de la llista.
-   Mostra el resultat com a text informatiu (`infoText`) al component `TechSheetField`.
-   Aplica una classe CSS d'error al camp de quantitat si `need.quantity > availability.available`.

#### Propagació de Canvis i Font de Veritat

Per garantir la consistència de les dades a tota l'aplicació, s'ha implementat un sistema de propagació de canvis des de l'inventari mestre:

-   **Edició Centralitzada:** Qualsevol propietat d'un ítem de material es pot editar ara des de la vista de "Material".
-   **Bloqueig de UI:** En desar un canvi, la UI es bloqueja temporalment per garantir que l'operació sigui atòmica.
-   **Propagació Automàtica:** L'acció `updateMaterialItem` a `eventDataStore` no només actualitza l'ítem a la llista `materialItems`, sinó que també itera sobre tots els `eventFrames` i les seves `techSheet`. Si troba una necessitat (`NeedItem`) que utilitza el material modificat (comparant `materialItemId`), actualitza automàticament les seves propietats derivades (com `description` i `origin`).
-   **Font de Veritat:** Per reforçar aquest concepte, a `NeedsList.tsx`, els camps "Descripció" i "Origen" d'una necessitat es tornen de només lectura (`readOnly`) si estan vinculats a un ítem de l'inventari, evitant edicions manuals que podrien crear inconsistències.

### 5.4. Detecció de Conflictes d'Assignació

Aquesta lògica, similar al control d'estoc, preveu que una persona sigui assignada a dos llocs alhora.

#### Flux de Validació amb Confirmació de l'Usuari

Per oferir més flexibilitat, el sistema ja no bloqueja les assignacions duplicades, sinó que demana confirmació a l'usuari.

1.  **Detecció de Conflictes (`useEventDataStore.ts`):**
    -   Les accions `addAssignment` i `updateAssignment` de l'store contenen la lògica per detectar si una persona ja té una altra assignació en el mateix període.
    -   Aquestes funcions accepten un paràmetre opcional `force: boolean`. La comprovació de conflictes només s'executa si `force` és `false`.

2.  **Senyalització del Conflicte (Workaround):**
    -   Si es detecta un conflicte, la funció retorna un `warningMessage` que conté un prefix especial: `DUPLICATE_CONFLICT:`.
    -   Aquest mètode de prefixar el missatge es va adoptar com a solució alternativa robusta davant d'errors del compilador de TypeScript que impedien la correcta resolució de tipus més complexos.

3.  **Gestió a la UI (`AssignmentFormModal.tsx` i `MainDisplay.tsx`):**
    -   Els components que inicien una modificació d'assignació (`AssignmentFormModal` per a la creació/edició i `MainDisplay` per als canvis d'estat ràpids) criden a les accions de l'store amb `force: false` inicialment.
    -   En rebre una resposta amb el prefix `DUPLICATE_CONFLICT:`, comproven el missatge i invoquen `openModal` per mostrar el diàleg `ConfirmDuplicateModal`, garantint un comportament consistent a tota l'aplicació.

4.  **Confirmació de l'Usuari (`ConfirmDuplicateModal.tsx`):**
    -   Aquest modal mostra el missatge de conflicte (sense el prefix) i pregunta a l'usuari si vol procedir.
    -   En confirmar, s'executa una funció de `callback` que torna a cridar `handleSubmit` al formulari, aquest cop amb el paràmetre `force: true`.

5.  **Execució Forçada:**
    -   La segona crida a `addAssignment` o `updateAssignment`, ara amb `force: true`, omet la comprovació de conflictes i desa l'assignació duplicada.


---

### 5.5. Sistema d'Importació/Exportació (JSON, PDF, CSV)

L'aplicació ofereix múltiples opcions per externalitzar i internalitzar dades, proporcionant flexibilitat i capacitat de backup manual.

#### Importació/Exportació General (JSON)

-   **Backend (`main.cjs`):** Utilitza `dialog.showSaveDialog` i `fs.writeFileSync` per a la funcionalitat de desat. Aquesta interacció nativa permet a l'usuari triar la ubicació de l'arxiu de manera familiar.
-   **Frontend (`Controls.tsx`):** Orquestra el procés.
    -   **Guardar:** Crida a `exportData()` de `useEventDataStore` per obtenir l'estat actual i l'envia al backend.
    -   **Carregar:** Utilitza un `<input type="file">` ocult que, en seleccionar un fitxer, el llegeix amb `FileReader` i envia el contingut a la funció `loadData()` de l'store.

#### Càrrega Flexible: Fusió vs. Reemplaçament

-   **Flux d'Execució:**
    1.  Quan l'usuari selecciona un fitxer de persones o material, `Controls.tsx` llegeix el JSON.
    2.  En lloc de processar les dades directament, crida a `openModal('mergeOrReplace', { ... })`, passant les dades noves (`newData`) al modal.
    3.  El modal `MergeOrReplaceModal.tsx` presenta a l'usuari les opcions.
    4.  Depenent del botó que es premi, s'executa una de les funcions del context: `mergePeopleGroups`, `replacePeopleGroups`, `addMaterialItemsFromFile` (per a fusió de material) o `replaceMaterialItems`.
-   **Lògica de Fusió (`useEventDataStore.ts`):** La fusió es realitza dins de les accions `mergePeopleGroups` i `addMaterialItemsFromFile` de l'store, comparant els noms per evitar duplicats.

#### Exportació a PDF i CSV

-   **Lògica Centralitzada:** Tota la lògica de generació de documents es troba a **`src/utils/pdfGenerator.ts`** per als PDF i a **`src/utils/csvUtils.ts`** per a les utilitats de CSV. Aquesta centralització fa que el manteniment dels formats d'exportació sigui més senzill.
-   **Exportació de Vistes Filtrades:**
    -   `MainDisplay.tsx` manté un estat (`currentlyDisplayedFrames`) que reflecteix la llista d'esdeveniments actualment visibles segons els filtres aplicats.
    -   Quan l'usuari clica "Exportar a CSV/PDF", aquesta llista filtrada és la que es passa a les funcions d'exportació, assegurant que l'arxiu generat sigui un reflex fidel del que l'usuari veu a la pantalla.
-   **Compatibilitat amb Excel (BOM):** Per garantir la correcta visualització d'accents i caràcters especials en programes com Microsoft Excel, els components que generen fitxers CSV (com `PeopleDisplay.tsx`) afegeixen un **Byte Order Mark (BOM)** (`\uFEFF`) a l'inici del contingut del fitxer.

##### Millores a les Exportacions del Centre de Control de Material
S'han implementat millores significatives a les funcions d'exportació del Centre de Control de Material per augmentar-ne la claredat i la fiabilitat.

-   **Exportació a PDF Resum (`exportMaterialControlSummaryPdf`):**
    -   **Estructura Jeràrquica:** Aquesta funció ja no realitza la seva pròpia agrupació. Rep les dades pre-ordenades (per categoria, origen i nom) des de `MaterialControlCenter.tsx`.
    -   **Agrupació Visual:** Itera sobre les dades i injecta dinàmicament files de capçalera per a cada **categoria** i sub-capçaleres per a cada **origen**, creant una estructura visual clara i fàcil de seguir.
    -   **Noves Columnes:** S'ha afegit la columna 'Origen' i s'ha reorganitzat la capçalera a `['Nom', 'Origen', 'Estoc', 'Balanç', 'Demanada']` per a una millor llegibilitat.
    -   **Inclusió de Notes:** Si un ítem de material té notes, aquestes s'inclouen en una fila addicional just a sota de l'ítem, amb un estil visual diferenciat per a una fàcil identificació.

-   **Exportació a CSV (`exportMaterialControlCsv`):**
    -   Aquesta funció ara rep les dades ja ordenades jeràrquicament. No s'ha necessitat cap canvi en la seva lògica, però el resultat és un CSV amb les files pre-ordenades de manera consistent amb el PDF de resum.

-   **Correcció a l'Exportació de PDF Detallat (`handleExportDetailedPdf`):**
    -   S'ha solucionat un error crític que provocava que s'exportés un PDF buit si no hi havia cap esdeveniment seleccionat explícitament al filtre.
    -   La nova lògica a `MaterialControlCenter.tsx` dedueix quins esdeveniments són rellevants directament de les dades filtrades (`filteredData`). Itera sobre el desglossament de cada fila, recull tots els `eventFrameId` únics en un `Set`, i filtra la llista completa d'esdeveniments amb aquest conjunt.
    -   Això garanteix que el PDF detallat sempre contingui la informació dels esdeveniments associats a les dades que l'usuari està veient a la taula.

La lògica d'exportació de les Fitxes de Bolo a PDF (`pdfGenerator.ts`) ha estat optimitzada per crear documents nets i rellevants:

-   **Omissió de Seccions Buides:** Les seccions completes (com 'Il·luminació', 'So', etc.) només apareixen al PDF si contenen alguna dada. Si una llista de necessitats està buida, la secció sencera no s'inclou.
-   **Gestió de Camps Condicionals:** Els camps que depenen d'un selector (com 'Vídeo' o 'Lloguers') només s'inclouen si estan marcats com a 'SI' i tenen informació addicional. Les opcions 'NO' o buides s'ometen.
-   **Consistència de Dades:** Per garantir la precisió, quan un camp condicional es desactiva al formulari (p. ex., canviant de 'SI' a 'NO'), les dades associades s'esborren de l'estat, assegurant que el PDF reflecteixi sempre la informació visible.

### 5.6. Generació de Noms de Fitxer Intel·ligents

Per millorar dràsticament la utilitat dels fitxers exportats (PDF/CSV), s'ha implementat un sistema de nomenclatura intel·ligent i contextual que fa que els noms dels fitxers siguin auto-descriptius.

#### Lògica Centralitzada (`src/utils/fileNameUtils.ts`)

-   **Mòdul Dedicat:** S'ha creat un nou mòdul a `src/utils/fileNameUtils.ts` que centralitza tota la lògica de generació de noms de fitxer.
-   **Funció Principal (`generateFileName`):** Aquesta funció construeix el nom del fitxer basant-se en una jerarquia de prioritat dels filtres actius:
    1.  **Prioritat Alta:** Filtres restrictius com **Esdeveniment específic**, **Persona** o **Data concreta** formen la part principal del nom (p. ex., `Llista_Esdeveniments_Persona_Pep`).
    2.  **Indicador Secundari:** Si s'apliquen filtres addicionals menys específics (com text lliure), s'afegeix un indicador genèric (`_+Filtres`) per a indicar que el contingut està més acotat.
    3.  **Comportament sense Filtres:** Si no hi ha cap filtre actiu, el nom del fitxer descriu el **rang de dates** del contingut exportat (p. ex., `De_01-09-25_a_30-11-25`), que s'extreu directament de les dades.
-   **Formats Especials:** El mòdul també inclou funcions per a formats específics, com `generateTechSheetFileName`, que segueix el patró `Fitxa_Bolo_[NomEsdeveniment]_[Data].pdf`.

#### Integració i Coherència de Dades

-   **Flux de Dades a `SummaryReports`:** El component `SummaryReports.tsx` ha estat refactoritzat per a rebre el conjunt de dades ja filtrat com a `props` des de `MainDisplay.tsx`. Això garanteix que els resums i les seves exportacions es basen exactament en les mateixes dades que l'usuari veu a la llista principal.
-   **Actualització dels Mòduls d'Exportació:** Les funcions a `pdfGenerator.ts` i `csvUtils.ts` han estat actualitzades per a acceptar l'estat dels filtres i cridar a `generateFileName`, assegurant que tots els fitxers exportats segueixin la nova convenció de nomenclatura.
---------


 #### Utilitat Centralitzada per a CSV (`csvUtils.ts`)

 Per garantir la consistència i evitar la duplicació de codi (principi DRY), la lògica de formatació de cel·les CSV ha estat refactoritzada:

 1.  **Mòdul Dedicat:** S'ha creat el fitxer **`src/utils/csvUtils.ts`**.
 2.  **Funció d'Escapament (`escapeCsvCell`):** Aquest mòdul exporta una funció reutilitzable, `escapeCsvCell`, que s'encarrega de gestionar correctament els caràcters especials (comes, cometes dobles, salts de línia) dins d'una cel·la. La funció embolcalla el contingut amb cometes dobles si és necessari i escapa les cometes internes segons l'estàndard CSV.
 3.  **Implementació:** Components com `PeopleDisplay.tsx` i `SummaryReports.tsx` importen i utilitzen `escapeCsvCell` per formatar cada cel·la abans de construir el fitxer CSV final.

--------------
### 5.6. Migració de Dades Antigues

Per garantir la retrocompatibilitat amb versions anteriors de l'estructura de dades, s'ha implementat un sistema de migració transparent.

-   **Fitxer Clau:** `src/utils/dataMigration.ts`.
-   **Funció `migrateData`:** Aquesta funció accepta objectes de dades amb l'estructura antiga (p. ex., amb `people` en lloc de `peopleGroups`, ID numèrics, etc.) i els transforma a l'estructura `AppData` moderna.
-   **Activació:** La lògica de migració i validació ara es troba centralitzada dins de l'acció **`loadData`** al fitxer **`src/stores/eventDataStore.ts`**.

---

### 5.7. Gestió de l'Estat de "Completat" dels Esdeveniments

L'aplicació permet marcar un esdeveniment marc com a "completat" a nivell de personal. Aquesta és una eina visual ràpida per a l'usuari, que té efectes tant a la llista d'esdeveniments com al calendari.

#### El Model de Dades

La "font de veritat" d'aquest estat és la propietat booleana `personnelComplete` dins de la interfície `EventFrame` a `src/types.ts`. Si és `true`, l'esdeveniment es considera complet; si és `false` o no està definit, es considera incomplet.

#### La Interfície d'Usuari (UI)

La interacció i la representació visual d'aquest estat es gestionen de manera consistent a tota l'aplicació:

1.  **A la Llista d'Esdeveniments (`EventFrameCard.tsx`):**
    -   Cada targeta d'esdeveniment té una icona de cercle de verificació (`CheckCircleIcon`) a la capçalera.
    -   El color d'aquesta icona és condicional: **verd** si l'esdeveniment està completat i **groc** si està incomplet.
    -   En fer-hi clic, s'invoca la funció `updateEventFrame` del gestor d'estat, que inverteix el valor del booleà `personnelComplete`.

2.  **Al Calendari (`MainDisplay.tsx`):**
    -   Quan es generen els esdeveniments per a FullCalendar, s'assigna una classe CSS específica a cada esdeveniment basant-se en l'estat de `personnelComplete`.
    -   S'assigna la classe `event-complete` o `event-incomplete`.

#### Els Estils

Les classes CSS esmentades no són classes de Tailwind per defecte. Estan definides dins del **plugin personalitzat** a `tailwind.config.cjs`. Aquest plugin injecta CSS pur que estableix el color de la vora dels esdeveniments al calendari: una **vora verda** per als completats i una **vora groga** per als incomplets.

Aquesta arquitectura connecta de manera eficient una simple dada booleana amb múltiples representacions visuals a tota la UI, proporcionant un feedback clar i immediat a l'usuari.

### 5.9. Sistema d'Arxivatge d'Esdeveniments

Per mantenir la interfície neta i centrada en els esdeveniments actuals, s'ha implementat un sistema d'arxivatge. Aquesta funcionalitat permet als usuaris ocultar esdeveniments antics (finalitzats fa més d'un mes) de les vistes principals, sense eliminar les dades.

#### Model de Dades

-   **`EventFrame`**: S'ha afegit una nova propietat opcional `isArchived?: boolean` a la interfície. Si és `true`, l'esdeveniment es considera arxivat.

#### Lògica a l'Store (`eventDataStore.ts`)

S'han afegit tres noves accions per gestionar el cicle de vida de l'arxivatge:
-   **`archiveOldEventFrames()`**: Aquesta acció no modifica l'estat. Escaneja tots els `eventFrames` i retorna una llista d'aquells que van finalitzar fa més d'un mes i que encara no estan arxivats.
-   **`confirmArchiveEventFrames(eventFrameIds: string[])`**: Aquesta acció rep un array d'IDs, busca els esdeveniments corresponents i estableix la seva propietat `isArchived` a `true`.
-   **`restoreEventFrame(eventFrameId: string)`**: Rep l'ID d'un esdeveniment, el busca i estableix `isArchived` a `false`.

#### Integració a la Interfície d'Usuari

1.  **Arxivatge massiu (`Controls.tsx`):**
    -   S'ha afegit un botó "Arxivar Antics".
    -   En fer-hi clic, es crida a `archiveOldEventFrames()`. Si retorna esdeveniments, s'obre un modal de confirmació (`confirmDelete`).
    -   Si l'usuari confirma, es crida a `confirmArchiveEventFrames()` amb els IDs dels esdeveniments a arxivar.

2.  **Visualització d'Arxivats (`MainDisplay.tsx`):**
    -   S'ha afegit un estat local `showArchived` i una casella de selecció ("Mostrar arxivats") per controlar-lo.
    -   El selector `selectFilteredEventFrames` s'ha modificat per acceptar un paràmetre `showArchived`. Per defecte (`false`), filtra i exclou els esdeveniments arxivats. Si és `true`, mostra *només* els arxivats.
    -   El títol de la secció canvia a "Esdeveniments Arxivats" quan la casella està marcada.

3.  **Restauració (`EventFrameCard.tsx`):**
    -   El component rep una nova propietat `isArchived: boolean`.
    -   Si és `true`, els botons d'acció habituals (editar, eliminar) s'oculten i es mostra un únic botó "Restaurar".
    -   Aquest botó, en ser clicat, invoca l'acció `restoreEventFrame()` amb l'ID de l'esdeveniment, restaurant-lo a la vista principal.

4.  **Fitxes de Bolo (`TechSheetsDisplay.tsx`):**
    -   S'ha afegit un estat `includeArchived` i una casella de selecció ("Incloure arxivats").
    -   La lògica que genera les opcions per al selector d'esdeveniments filtra els esdeveniments arxivats tret que aquesta casella estigui marcada, garantint que les fitxes d'esdeveniments antics segueixin sent accessibles si cal.

### 5.8. Format de Dates: Intern (YYYY-MM-DD) vs. Visual (DD/MM/YYYY)

L'aplicació utilitza deliberadament dos formats de data diferents per a dues finalitats diferents, una pràctica estàndard per garantir la integritat de les dades i una bona experiència d'usuari.

#### La Raó del Doble Format

1.  **Format Intern (`YYYY-MM-DD`):**
    -   **Estàndard i Robustesa:** Aquest format, basat en la norma ISO 8601, és inequívoc, independent de la configuració regional i ideal per a l'emmagatzematge de dades, la comunicació amb API (com la de Google Calendar) i l'ordenació algorítmica.
    -   **Compatibilitat:** És el format natiu que utilitzen els controls `<input type="date">` en HTML5.

2.  **Format Visual (`DD/MM/YYYY`):**
    -   **Experiència d'Usuari (UX):** És el format convencional i familiar per a l'usuari final a la nostra regió. Presentar les dates d'aquesta manera fa que l'aplicació sigui més intuïtiva i llegible.

#### La Implementació

La conversió entre aquests dos formats es gestiona de manera centralitzada per garantir la consistència.

-   **Utilitat Centralitzada:** El mòdul **`src/utils/dateFormat.ts`** conté les funcions `formatDateDMY` i `formatDateRangeDMY`, que són les úniques responsables de realitzar aquesta conversió de format per a la presentació.

-   **Ús a l'Aplicació:**
    -   **Entrada de Dades:** Els formularis amb camps de data utilitzen `<input type="date">`, que internament treballa amb el format `YYYY-MM-DD`. Aquest és el format que es desa a l'estat de React.
    -   **Visualització de Dades:** Tots els components que mostren una data a l'usuari (les targetes d'esdeveniments, els modals de detalls, els resums, etc.) importen i utilitzen les funcions de `dateFormat.ts` per mostrar-les en format `DD/MM/YYYY`. De la mateixa manera, el generador de documents (`pdfGenerator.ts`) utilitza aquestes funcions per garantir que els PDF exportats siguin fàcilment llegibles.

---

## 6. Sistema d'Estils (Tematització Semàntica Centralitzada)

El disseny de la interfície s'ha refactoritzat per utilitzar un **sistema de tematització semàntic i centralitzat** que combina la potència de Tailwind CSS amb la flexibilitat de les variables CSS natives. Aquesta arquitectura no només permet una gestió de temes (clar i fosc) robusta, sinó que també garanteix la coherència visual entre la interfície d'usuari i els documents exportats (PDF).

### Arquitectura del Disseny

El sistema es basa en una jerarquia de "fonts de veritat" per assegurar la màxima consistència i mantenibilitat.

1.  **Font Única de Veritat per a Colors (`src/utils/themeDefinition.ts`):**
    -   **Descripció:** Aquest fitxer és el **nucli de tot el sistema de colors**. Exporta un objecte `themeHslColors` que defineix tots els colors base de l'aplicació en format de tuples HSL `[Hue, Saturation, Lightness]`.
    -   **Responsabilitat:** Qualsevol canvi fonamental en la paleta de colors de l'aplicació (p. ex., canviar el to del color primari) s'ha de fer **únicament** en aquest fitxer.

2.  **Definició de Variables CSS (`src/index.css`):**
    -   **Descripció:** Aquest fitxer consumeix els valors de `themeDefinition.ts` (de manera manual, per ara) per definir una paleta de variables CSS semàntiques (p. ex., `--background`, `--foreground`, `--primary`, `--destructive`).
    -   **Tematització Clar/Fosc:** El tema per defecte (clar) es defineix a `:root`. El tema fosc simplement sobreescriu aquestes mateixes variables dins del selector `.dark`.
    -   **Colors Derivats:** Les variables més específiques (com `--daily-row-yes-bg` per al fons de les files) es deriven de les variables semàntiques principals mitjançant `hsla(var(--success) / 0.15)`, assegurant que s'adaptin automàticament al tema.

3.  **Integració amb Tailwind (`tailwind.config.cjs`):**
    -   **Descripció:** El fitxer de configuració de Tailwind s'ha modificat per consumir les variables CSS definides a `index.css`.
    -   **Implementació:** En lloc de definir colors directament, la paleta de Tailwind fa referència a les variables mitjançant la funció `hsl()`. Això permet que les classes d'utilitat de Tailwind (com `bg-background`, `text-primary`, `border-border`) apliquin automàticament el color correcte segons el tema actiu.

4.  **Coherència en PDFs (`src/utils/colorUtils.ts` i `pdfGenerator.ts`):**
    -   **Problema:** La llibreria `jspdf-autotable` requereix colors en format RGB, no HSL.
    -   **Solució:**
        -   S'ha creat una funció d'utilitat a **`src/utils/colorUtils.ts`** anomenada `hslToRgb` que converteix els colors del format HSL al format RGB.
        -   El generador de PDFs (`src/utils/pdfGenerator.ts`) ara importa els colors HSL directament des de la font única de veritat (`themeHslColors`) i els converteix a RGB al moment utilitzant `hslToRgb`.
    -   **Resultat:** Això garanteix que els colors dels PDFs exportats siguin sempre una representació fidel del tema de l'aplicació, eliminant completament els colors "hardcoded" i la possibilitat d'inconsistències.

### Avantatges d'Aquesta Arquitectura

-   **Centralització Absoluta:** Un únic fitxer (`themeDefinition.ts`) defineix la paleta de colors per a tota l'aplicació.
-   **Consistència Garantida:** La UI, el calendari, els tooltips i els PDFs comparteixen la mateixa font de colors.
-   **Mantenibilitat Superior:** Modificar un color a `themeDefinition.ts` i actualitzar-lo a `index.css` és suficient per canviar-lo a tota l'aplicació, inclosos els exports.
-   **Codi Net:** Redueix la necessitat de classes condicionals `dark:` als components, simplificant el codi JSX.

### 6.1. Sistema de Tooltips (Basat en Portals)

Per millorar la fiabilitat i resoldre problemes de visibilitat (`z-index` i `clipping`), el sistema de tooltips ha estat refactoritzat per utilitzar `ReactDOM.createPortal`. Aquesta tècnica "teletransporta" el tooltip al final del `document.body`, traient-lo del flux normal del DOM i evitant que quedi atrapat dins de contenidors pares amb contextos de solapament propis.

#### Ús del Component `Tooltip`

L'ús del component no ha canviat. Per afegir un tooltip, simplement cal embolcallar qualsevol element amb el component `Tooltip` i passar-li el text a mostrar a través de la propietat `text`.

**Exemple d'ús:**

```tsx
import Tooltip from './ui/Tooltip';

// ...

<Tooltip text="Aquest és el text que es mostrarà al tooltip">
  <button onClick={laMevaFuncio}>
    La Meva Acció
  </button>
</Tooltip>
```

#### Funcionament Intern

-   **Component `Tooltip` (`src/components/ui/Tooltip.tsx`):**
    -   Clona l'element fill (`children`) per afegir-hi `event listeners` (`onMouseEnter`, `onMouseLeave`).
    -   Utilitza `useState` per controlar la visibilitat del tooltip.
    -   Utilitza `setTimeout` i `clearTimeout` per gestionar un retard de 0.5 segons abans de mostrar el tooltip.
    -   Calcula la posició de l'element fill amb `getBoundingClientRect()` per posicionar el tooltip de manera absoluta a la pantalla.
    -   Renderitza un `<div>` amb el contingut del tooltip mitjançant `ReactDOM.createPortal`, que l'injecta al final del `<body>`.
-   **Estils (`src/index.css`):**
    -   La classe `.tooltip-portal` defineix l'estil del tooltip (fons, color, mida de font, etc.).
    -   Utilitza `position: absolute` i `transform` per posicionar-se correctament respecte a l'element que l'activa.
    -   Té un `z-index` molt alt per assegurar que sempre es mostri per sobre de tots els altres elements.

-   **Solució de Condició de Cursa (Race Condition) en Desmuntatge:** S'ha solucionat un bug crític que provocava la pèrdua de focus de la finestra. El problema ocorria quan un element amb un tooltip actiu desapareixia de la UI (per exemple, en ser eliminat d'una llista). El temporitzador del tooltip intentava executar-se després que el component s'hagués desmuntat, causant una condició de cursa que afectava el focus. La solució ha consistit a implementar una funció de neteja (`cleanup function`) dins d'un `useEffect` al component `Tooltip`. Aquesta funció s'assegura de cancel·lar qualsevol temporitzador pendent (`clearTimeout`) en el moment en què el component es desmunta, garantint que no quedin operacions asíncrones residuals i prevenint la pèrdua de focus.

---

## 7. Compilació i Desplegament (CI/CD)

El projecte està configurat per a la Integració i Desplegament Continus (CI/CD) mitjançant GitHub Actions.

### Workflows de GitHub Actions (`.github/workflows/`)

Existeixen tres arxius de workflow, un per a cada sistema operatiu principal:

-   `build-linuxv20-04.yml`
-   `build-macos12.yml`
-   `build-win10.yml`

Tots els workflows s'activen manualment (`workflow_dispatch`) i segueixen un patró similar:

1.  **Checkout:** Descarreguen el codi font del repositori.
2.  **Setup Node.js:** Configuren l'entorn amb la versió de Node.js especificada.
3.  **Install Dependencies:** Executen `npm install` per instal·lar totes les dependències.
4.  **Create `google-credentials.json`:** Aquest és un pas crucial. El contingut del fitxer de credencials s'emmagatzema com un **Secret de GitHub** (`GOOGLE_CREDENTIALS_JSON`). L'acció llegeix aquest secret i crea el fitxer `google-credentials.json` a l'entorn de compilació. Això permet que les credencials s'incloguin de manera segura a l'aplicació empaquetada sense que estiguin exposades al codi font.
5.  **Build Application:** Executen l'script `npm run build:electron` amb les banderes corresponents a cada sistema operatiu (`--linux`, `--win`, `--mac`).
6.  **Upload Artifact:** Empaqueten els binaris generats (`.AppImage`, `.dmg`, `.exe`) com a artefactes de la build, que es poden descarregar des de la pàgina de l'acció a GitHub.

### Configuració d'Electron Builder (`package.json`)

La clau `build` del `package.json` conté la configuració per a `electron-builder`:

-   `appId`: Identificador únic de l'aplicació.
-   `files`: Especifica quins fitxers i directoris s'han d'incloure a l'empaquetat final. És important que `dist/**/*` (el frontend compilat), `main.cjs`, `preload.cjs` i `google-credentials.json` estiguin aquí.
-   `extraResources`: Permet incloure fitxers addicionals (com exemples o la llicència) que seran accessibles des de l'aplicació instal·lada.
-   **Configuracions per Plataforma (`linux`, `win`, `mac`):** Defineixen les opcions específiques per a cada sistema operatiu, com els formats de sortida (`AppImage`, `nsis`, `dmg`) i les icones.

---

## 8. Guia per a Desenvolupadors

* nota * Per mantenir una alta qualitat i robustesa del codi, la configuració de TypeScript a `tsconfig.json` és estricta. Les següents regles estan activades (`true`):

-   `"strict": true`: Activa totes les comprovacions de tipus estrictes.
-   `"noUnusedLocals": true`: Marca un error si es declaren variables que no s'utilitzen.
-   `"noUnusedParameters": true`: Marca un error si es declaren paràmetres de funció que no s'utilitzen.

Això obliga a mantenir un codi net i evita variables residuals que puguin portar a errors.

### Instal·lació i Configuració

1.  **Clona el repositori:**
    ```bash
    git clone https://github.com/Pepelocotango/Gestor-Events_i_Personal.git
    cd Gestor-Events_i_Personal
    ```

2.  **Instal·la les dependències:**
    ```bash
    npm install
    ```

3.  **Configura les Credencials de Google (Opcional, per a desenvolupament):**
    -   Crea un fitxer anomenat `google-credentials.json` a l'arrel del projecte.
    -   Enganxa-hi el contingut JSON de les teves credencials d'OAuth 2.0 per a "Aplicació d'escriptori" obtingudes des de Google Cloud Console.

### Scripts `npm` Disponibles

-   `npm run dev`: Inicia el servidor de desenvolupament de Vite. (Normalment no s'utilitza sol).
-   `npm run electron`: Inicia l'aplicació Electron esperant que el servidor de Vite estigui actiu. (Normalment no s'utilitza sol).
-   `npm run electron-dev`: El comandament principal per al desenvolupament. Llança Vite i Electron simultàniament amb recàrrega en calent (`hot-reloading`).
-   `npm run build`: Compila el codi TypeScript i el frontend amb Vite a la carpeta `dist`.
-   `npm run build:electron`: Comanda genèrica per construir l'empaquetat d'Electron.
-   `npm run build:linux`, `npm run build:win`, `npm run build:mac`: Scripts específics per compilar l'aplicació per a cada sistema operatiu.
`npm start` : Aquesta única comanda s'encarregarà de tot:
Reconstruirà els teus colors a partir de theme.config.cjs.
Llançarà Vite sense memòria cau (--force).
Obrirà Electron.

- ultim script `npm run fresh-start` : Aquesta única comanda s'encarregarà de tot:
Reconstruirà els teus colors a partir de theme.config.cjs.
Llançarà Vite sense memòria cau (--force).
Obrirà Electron.

### Depuració (Debugging)

-   **Procés Principal (Backend):** Els logs es mostren a la terminal on has executat `npm run electron-dev` i es guarden als fitxers de log a la carpeta de dades de l'usuari.
-   **Procés de Renderitzat (Frontend):** Pots obrir les "Developer Tools" de Chromium des del menú `Veure -> Forçar Recàrrega` i `Veure -> Obrir Eines de Desenvolupament` (o amb el corresponent drecera de teclat). Això et dona accés a la consola, inspector d'elements, etc., com en un navegador web normal.

## Pràctiques de Qualitat i Seguretat del Codi
El projecte segueix una sèrie de bones pràctiques per garantir un codi segur, robust i mantenible:

-   **Immutabilitat de l'Estat: Tota la gestió de l'estat de React segueix el principi d'immutabilitat. En lloc de modificar directament objectes o arrays de l'estat, sempre es creen noves instàncies ([...array], {...objecte}), la qual cosa evita efectes secundaris i bugs de renderitzat.
-   **Separació de Responsabilitats: Les funcions d'utilitat (com la generació de CSV o la migració de dades) s'abstrauen en mòduls dedicats a src/utils/ per promoure la reutilització de codi i seguir el principi DRY (Don't Repeat Yourself).
-   **Consistència de la Interfície d'Usuari**: S'ha fet un esforç per estandarditzar el comportament dels components interactius. Per exemple, totes les seccions col·lapsables ara permeten expandir/col·lapsar fent clic a qualsevol lloc de la capçalera, no només a la icona.
-   **Programació Defensiva: El codi inclou comprovacions per a window.electronAPI abans de la seva execució, permetent que la base de codi del frontend sigui més resilient i pugui, teòricament, funcionar en un entorn de navegador sense trencar-se.
-   **Superfície d'Atac Mínima: L'API exposada a través de preload.cjs es manté al mínim necessari, eliminant qualsevol funció o listener IPC que no estigui en ús per reduir possibles vectors d'atac.
-   **Ús de Modals Interns per a Confirmacions**: Per evitar bugs de pèrdua de focus i mantenir una experiència d'usuari consistent, s'ha estandarditzat l'ús del sistema de modals interns de l'aplicació (`useModalStore`) en lloc de les funcions natives del navegador com `window.confirm()`. Qualsevol nova acció que requereixi confirmació de l'usuari ha d'implementar un modal a través d'aquest sistema.

### 5.9. Càrrega de Dades Resilient (Migració -> Validació -> Reparació)

Per garantir la màxima robustesa i evitar pèrdues de dades o bloquejos de l'aplicació a causa de fitxers de dades corruptes o amb formats antics, s'ha implementat un pipeline de càrrega de dades de diversos passos. Aquest sistema prioritza una experiència d'usuari ràpida per a dades vàlides (el "camí feliç") mentre proporciona una xarxa de seguretat per a dades que requereixen correccions.

#### El Pipeline de Processament de Dades

La lògica central resideix a l'acció `loadData` de l'store `useEventDataStore` i segueix aquesta seqüència:

1.  **Migració (Sempre):**
    -   **Objectiu:** Assegurar que les dades, independentment de la seva versió original, tinguin sempre l'estructura de dades més recent definida a `types.ts`.
    -   **Implementació:** La funció itera sobre cada `eventFrame` i passa el seu `techSheet` a la funció `migrateTechSheetData` (`src/utils/techSheetMigration.ts`). Aquesta funció comprova si la fitxa ja té el format nou; si no, la transforma, afegint els camps nous amb valors per defecte i reestructurant els antics.
    -   **Tolerància a Errors:** La migració està dins d'un bloc `try...catch`. Si falla per qualsevol motiu (p. ex., un format de dades completament inesperat), es registra l'error i es genera una fitxa tècnica per defecte, evitant que l'aplicació es bloquegi.

2.  **Validació (Sempre):**
    -   **Objectiu:** Comprovar la integritat referencial de les dades ja migrades.
    -   **Implementació:** Les dades migradas es passen a la funció `validateData` (`src/utils/dataIntegrity.ts`). Aquesta funció comprova, per exemple, que cada `assignment` apunti a un `eventFrameId` i a un `personGroupId` que realment existeixin a les llistes corresponents.
    -   **Resultat:** Retorna un objecte `{ isValid: boolean, errors: ValidationError[] }`.

3.  **Decisió i Rutes Condicionals:**
    -   **Cas A: Dades Vàlides (isValid: true)**
        -   **Acció:** S'executa la funció `_applyDataToState`, que carrega les dades directament a l'estat de React.
        -   **Feedback:** Es mostra un missatge d'èxit simple i ràpid a l'usuari. El procés acaba aquí.
    -   **Cas B: Dades Invàlides (isValid: false)**
        -   **Reparació:** Les dades i l'informe d'errors es passen a la funció `repairData` (`src/utils/dataIntegrity.ts`). Aquesta funció elimina els elements trencats (p. ex., les assignacions invàlides) i retorna les dades netes i un array de missatges explicant les correccions (`fixes`).
        -   **Confirmació de l'Usuari:** S'obre el modal `ConfirmRepairModal.tsx`, mostrant la llista de `fixes` a l'usuari.
        -   **Decisió Final:** L'usuari pot triar entre carregar la versió reparada o cancel·lar l'operació. Les dades només es carreguen si l'usuari dona el seu consentiment explícit.

Aquest sistema garanteix que l'aplicació sigui extremadament resilient a errors de dades, alhora que manté una experiència fluida per a la majoria d'usuaris les dades dels quals són correctes.

## 9. Restauració de Funcionalitats Post-Refactorització (Zustand)

Després de la migració a Zustand, algunes interaccions de la UI es van haver de reconnectar. Aquesta secció documenta les solucions.

### 9.1. Gestió d'Expansió de Targetes (Manual i Automàtica)

S'ha restaurat la capacitat de l'usuari per expandir i col·lapsar manualment les targetes d'esdeveniments.

-   **Gestió d'Esdeveniments de Clic (`EventFrameCard.tsx`):** La capçalera de la targeta gestiona els clics per evitar conflictes. Utilitza `e.stopPropagation()` en els botons interns per assegurar que només el clic a la capçalera activi l'expansió, cridant a la funció `onToggleExpand`.
-   **Estat a l'Store (`eventDataStore.ts`):**
    -   `manualExpandedFrameIds: Set<string>`: Emmagatzema els IDs de les targetes que l'usuari ha expandit manualment.
    -   `setManualExpandedFrameIds()`: L'acció per modificar aquest conjunt.
-   **Lògica al Component (`MainDisplay.tsx`):**
    -   La funció `handleToggleExpand` crida a l'acció de l'store.
    -   Un `useMemo` decideix quines targetes estan expandides: si hi ha filtres actius, s'expandeixen tots els resultats; si no, s'utilitza el conjunt manual.

### 9.2. Funcionalitat "Mostrar a la Llista" i Ressaltat (Correcció de Condició de Cursa)

S'ha restaurat l'acció "Mostrar a la Llista" i s'ha corregit una condició de cursa que impedia que funcionés de manera fiable.

-   **Acció Centralitzada (`eventDataStore.ts`):** L'acció `showAndHighlightEvent(eventId: string)` estableix l'estat per expandir la llista i ressaltar un element.
-   **Activació (`EventFrameDetailsModal.tsx`):** El botó corresponent crida a l'acció anterior.
-   **Efecte Visual Corregit (`MainDisplay.tsx`):**
    -   S'ha corregit una **condició de cursa** (race condition). El `useEffect` que gestiona el ressaltat ara depèn de `highlightedEventId` i també de `filteredAndSortedEventFrames`.
    -   **Explicació:** Això garanteix que l'efecte només s'executi després que React hagi renderitzat la llista d'esdeveniments (si estava col·lapsada). D'aquesta manera, quan `document.getElementById` busca la targeta, aquesta ja existeix al DOM.
    -   L'efecte fa `scrollIntoView()`, afegeix una classe CSS per a l'animació, i la neteja després de 3 segons.

### 9.3. Exportació de Vistes Filtrades (PDF/CSV)

S'ha restaurat la capacitat d'exportar a PDF o CSV només els esdeveniments que coincideixen amb els filtres actius a la vista principal.

-   **Lògica:** La funcionalitat d'exportació, ubicada a `Controls.tsx`, utilitza un selector (`selectFilteredEventFrames`) per accedir a la llista filtrada directament des de l'store `useEventDataStore`.
-   **Implementació:** Quan l'usuari clica a "Exportar a PDF/CSV", `Controls.tsx` obté l'estat complet de l'store, el passa al selector per obtenir la llista filtrada, i finalment envia aquesta llista a les utilitats `pdfGenerator` o `csvUtils`. Si no hi ha cap filtre actiu, s'exporta la llista completa per defecte.

### 9.4. Avís de Conflictes en Assignacions

S'ha reimplementat i estandarditzat el diàleg modal que adverteix l'usuari quan intenta crear o modificar una assignació que se solapa en el temps amb una altra assignació existent per a la mateixa persona.

-   **Arquitectura:** La detecció de conflictes es realitza a l'store (`useEventDataStore`). Si se'n troba un, es comunica a la UI a través d'un missatge de retorn amb un prefix especial.
-   **Gestió a la UI:**
    -   **`AssignmentFormModal.tsx`**: Gestiona els conflictes en crear o editar una assignació completa.
    -   **`MainDisplay.tsx`**: S'ha corregit un error pel qual l'avís no apareixia en modificar l'estat d'una assignació directament des de la vista principal. Ara, els seus gestors també comproven el missatge de conflicte.
    -   **Consistència:** Ambdós components utilitzen el mateix modal de confirmació (`ConfirmDuplicateModal`) per oferir una experiència d'usuari unificada.

### 9.5. Barra de Progrés Detallada per a la Sincronització

S'ha reintroduït la barra de progrés en temps real durant la sincronització amb Google Calendar.

-   **Comunicació Backend -> Frontend:** El procés principal (`main.cjs`) envia actualitzacions de progrés a través del canal IPC `'sync-progress'`.
-   **Gestió d'Estat amb Zustand:** Un `useEffect` a `App.tsx` escolta aquests esdeveniments i actualitza un estat `syncProgress` dins de `useEventDataStore`, que és consumit pel component `SyncProgressOverlay.tsx`.

## 🎨 Sistema de Temes i Gestió de Colors

Per garantir la consistència visual i facilitar el manteniment, l'aplicació utilitza un sistema de temes centralitzat. Tota la paleta de colors es gestiona des d'una única font de veritat, i els fitxers de l'aplicació es generen automàticament a partir d'aquesta.

### 1. La Font Única de la Veritat: `theme.config.cjs`

- **Fitxer Clau:** `theme.config.cjs` a l'arrel del projecte.
- **Propòsit:** Aquest fitxer és l'únic lloc on s'han de definir o modificar els colors de l'aplicació. Conté:
    - `light`: Un objecte amb els colors per al tema clar en format string HSL (`"H S% L%"`).
    - `dark`: Un objecte amb els colors per al tema fosc.
    - `pdfExtras`: Colors addicionals que no són part del sistema de temes CSS però que es necessiten per a la generació de PDFs.
    - `pdfMapping`: Un mapeig que indica quin color de tema (`light` o `dark`) s'ha d'utilitzar per a cada variable de color en el context dels PDFs.

**Mai no s'han de modificar els colors directament a `src/index.css` o `src/utils/themeDefinition.ts`.**

### 2. Generació Automàtica de Fitxers de Tema

- **Script:** `scripts/build-theme.cjs`
- **Comanda:** `npm run build:theme`

Aquest script llegeix `theme.config.cjs` i genera dos fitxers crucials:

- **`src/index.css`**: Injecta les variables de color CSS per als selectors `:root` (tema clar) i `.dark` (tema fosc). Aquestes variables són les que utilitza Tailwind CSS a tota l'aplicació.
- **`src/utils/themeDefinition.ts`**: Genera un objecte TypeScript (`themeHslColors`) que conté els colors en format d'array HSL (`[H, S, L]`). Aquest objecte s'utilitza en llocs on les variables CSS no són accessibles, com durant la generació de documents PDF.

### 3. Com Actualitzar un Color (Flux de Treball)

1.  Obre el fitxer `theme.config.cjs`.
2.  Modifica el valor HSL del color que vulguis canviar al tema `light`, `dark` o a tots dos.
3.  Desa el fitxer.
4.  Executa la següent comanda a la terminal:
    ```bash
    npm run build:theme
    ```
5.  Això és tot. L'script actualitzarà automàticament tots els fitxers necessaris. El comando `npm run build` també executa aquest script, de manera que els canvis sempre estaran sincronitzats en fer una nova compilació.

---

### 9.6. Detecció de Plataforma Centralitzada per a Dreceres de Teclat

Per garantir que les dreceres de teclat es mostrin de manera consistent i correcta a tota l'aplicació (p. ex., "⌘" a macOS i "Ctrl" a Windows/Linux), la lògica de detecció del sistema operatiu s'ha centralitzat.

-   **Font de la Veritat (`App.tsx`):** El component arrel `App.tsx` és ara l'únic responsable de determinar la tecla modificadora específica de la plataforma.
    -   Realitza una única crida **síncrona** a `window.electronAPI.getPlatformSync()` en el moment de la renderització inicial.
    -   El resultat s'assigna a una **constant** local: `const platformModifierKey = window.electronAPI?.getPlatformSync() === 'darwin' ? '⌘' : 'Ctrl';`.
    -   Aquest enfocament elimina la necessitat de `useState` i `useEffect`, evitant qualsevol parpelleig visual o estat intermedi incorrecte.

-   **Propagació mitjançant Props:**
    -   La constant `platformModifierKey` es passa com a `prop` (`modifierKey`) als components fills que ho necessiten, com ara `CustomMenuBar.tsx`.

-   **Component Fill (`CustomMenuBar.tsx`):**
    -   El component del menú ja no conté cap lògica pròpia per detectar la plataforma.
    -   Simplement rep la `prop` `modifierKey` i la utilitza directament per renderitzar la drecera de teclat correcta.

Aquest patró millora la mantenibilitat, elimina codi duplicat i assegura que tota la UI reaccioni de manera consistent a la plataforma en què s'executa l'aplicació.

## Arquitectura General (Resum)

- **Frontend:** React amb Vite.
- **Escriptori:** Electron.
- **Gestió d'Estat:** Zustand.
- **Estils:** Tailwind CSS.
- **Llenguatge:** TypeScript.

--- END: ../Gestor-Events_i_Personal/DEVELOPING.md -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/README.md -- branca DEV_pre-monorepoV1.3.0 ---
![Captura de pantalla del gestor d'events i personal](imatges/en_construcció_GV.png)

### NOVA BRANCA DESENVOLUPAMENT --> DEV


### `README.md`**

# Gestor d'Esdeveniments i Personal V1.3.0

Aplicació d'escriptori multiplataforma (Electron, React, Vite) per a la gestió integral d'esdeveniments, personal, fitxes de bolo i material amb control d'estoc.

El projecte està actualment en fase de desenvolupament actiu.

## Funcionalitats Principals

Aquesta aplicació està dissenyada per ser una solució integral per a professionals del sector dels esdeveniments, com ara directors de producció, caps tècnics o empreses de lloguer de material. El seu objectiu és centralitzar i simplificar tota la logística que envolta un esdeveniment, cobrint tot el cicle de vida, des de la planificació inicial fins a l'execució tècnica.

L'aplicació ofereix les següents eines:

*   **Gestió d'Esdeveniments i Assignacions:**
    *   Crea "esdeveniments marc" amb dates i notes generals.
    *   Assigna personal per dies concrets i controla'n l'estat (Confirmat, Pendent, No disponible, Mixt).
    *   El sistema detecta automàticament conflictes si una persona és assignada a múltiples llocs el mateix dia.

*   **Planificació i Visualització:**
    *   **Calendari Avançat:** Visualitza tots els esdeveniments en múltiples formats (2, 4 o 6 mesos, mes, setmana i agenda). 
    *   **Llista Dinàmica:** Filtra i ordena els esdeveniments per nom, lloc, persona, estat o data per a una visió detallada.

*   **Documentació Tècnica (Fitxes de Bolo):**
    *   Genera fitxes tècniques completes per a cada esdeveniment.
    *   Gestiona el personal per proveïdors i rols, i les necessitats de material (il·luminació, so, vídeo, etc.).
    *   **Reordena els proveïdors de personal amb drag-and-drop** per a una organització visual i lògica.
    *   Pobla automàticament la llista de personal a partir de les assignacions confirmades.

*   **Inventari de Material:**
    *   Manté una base de dades centralitzada de material amb control d'estoc.
    *   El sistema comprova la disponibilitat de l'estoc en temps real en assignar material a una fitxa de bolo.

*   **Connectivitat i Gestió de Dades:**
    *   **Integració amb Google Calendar:** Sincronitza els esdeveniments de l'aplicació a un calendari dedicat de Google i visualitza altres calendaris teus en mode de només lectura.
        
        > **AVÍS IMPORTANT:** La integració amb Google Calendar requereix una autorització manual per part del desenvolupador.
        Perquè la sincronització funcioni, Google requereix que el desenvolupador afegeixi manualment el teu correu electrònic a la llista de "testers" autoritzats del projecte. Si vols utilitzar aquesta funcionalitat, si us plau, contacta amb l'autor, per a que el teu compte de Google , sigui afegit a la llista d'usuaris permesos.

    *   **Importació/Exportació:** Desa i carrega totes les dades de l'aplicació en format JSON. La càrrega de dades de personal i material permet fusionar o reemplaçar la informació existent.
    *   **Exportació a PDF/CSV:** Exporta resums, llistes de personal, inventaris i fitxes de bolo a formats professionals com PDF i CSV.

> Per a una anàlisi tècnica detallada de l'arquitectura i les funcionalitats, consulta la nostra [**guia de desenvolupament (DEVELOPING.md)**](DEVELOPING.md).



## 💾 Descàrrega i Instal·lació

Pots descarregar l'última versió de l'aplicació directament des de la nostra secció de [**Releases a GitHub**](https://github.com/Pepelocotango/Gestor-Events_i_Personal/releases).

Cada versió inclou binaris compilats per a Windows, macOS i Linux. Assegura't de descarregar el fitxer correcte per al teu sistema operatiu.

### Requisits Mínims del Sistema

L'aplicació es construeix amb Electron 38, la qual cosa defineix els següents requisits mínims:

*   **Windows:** Windows 10 (només 64-bit) o superior.
*   **macOS:** macOS 10.15 (Catalina) o superior.
*   **Linux:** Es recomana una distribució moderna com Ubuntu 20.04, Debian 11, Fedora 34 o equivalents més recents (requereix glibc 2.31 o superior).

    > **Nota important per a Linux:** L'aplicació es distribueix com a AppImage, que requereix la llibreria `libfuse2`. En sistemes com **Ubuntu 22.04 o posteriors**, aquesta llibreria no ve instal·lada per defecte. Si l'aplicació no s'obre, necessitaràs instal·lar-la manualment amb la comanda:
    > ```sh
    > sudo apt-get install libfuse2
    > ```

---

### Instruccions per Plataforma

#### 🪟 **Windows**

Oferim dues versions per a Windows:

> **Nota IMPORTANT per a Windows:** Com que l'aplicació no està signada digitalment, és probable que Windows Defender SmartScreen la bloquegi. Per executar-la, hauràs de fer clic a **"Més informació"** a la pantalla blava d'avís i, a continuació, al botó **"Executar de totes maneres"**.
1.  **Instal·lador (`..._Setup.exe`):**
    *   **Recomanat per a la majoria d'usuaris.**
    *   Descarrega i executa el fitxer `.exe` que conté la paraula `Setup`.
    *   Això instal·larà l'aplicació al teu sistema, creant una drecera a l'escriptori i una entrada al menú d'inici per a un accés fàcil.

2.  **Versió Portable (`..._.exe`):**
    *   **Ideal per executar sense instal·lar, per exemple des d'un pen-drive.**
    *   Descarrega el fitxer `.exe`.
    *   Pots executar l'aplicació directament amb un doble clic sense que s'instal·li res al teu sistema.

####  **macOS**

Per a macOS, la distribució es fa a través d'un fitxer `.dmg`:

> **Nota IMPORTANT per a macOS:** Com que l'aplicació no està signada ni notariada per Apple, el sistema de seguretat (Gatekeeper) la bloquejarà per defecte. Aquest és un comportament esperat. Per obrir-la per primera vegada, segueix aquests passos amb atenció:
>
> 1.  **Intent d'Obertura Inicial:** Després de copiar l'aplicació a la teva carpeta d'Aplicacions, fes **clic-dret** (o **Ctrl+clic**) sobre la seva icona i selecciona **"Obrir"**.
> 2.  **Primer Avís:** És molt probable que macOS mostri un avís dient que no pot verificar el desenvolupador i només et doni l'opció de "Cancel·lar" o "Moure a la Paperera". Simplement, fes clic a **"Cancel·lar"**.
> 3.  **Segon Intent (Confirmació):** Torna a fer **clic-dret** (o **Ctrl+clic**) sobre la icona de l'aplicació i selecciona **"Obrir"** un altre cop.
> 4.  **Obertura Final:** Ara, l'avís que apareixerà serà diferent i inclourà un botó per **"Obrir"** l'aplicació. Fes clic en aquest botó per executar-la.
>
> Aquest procés només és necessari la primera vegada. Després d'això, podràs obrir l'aplicació amb un doble clic normal.

*   Descarrega el fitxer `...-macOS-10.15+.dmg`.
*   Fes-hi doble clic per obrir-lo. S'obrirà una finestra del Finder.
*   Per instal·lar l'aplicació, simplement **arrossega la icona de l'aplicació a la drecera de la carpeta d'Aplicacions** que apareix a la mateixa finestra.
*   Ja pots executar l'aplicació des de la teva carpeta d'Aplicacions o mitjançant Launchpad.

#### 🐧 **Linux**

Per a Linux, utilitzem el format `AppImage`, que no requereix instal·lació:

*   Descarrega el fitxer `...-Linux-Ubuntu18.04+.AppImage`.
*   **Dona-li permisos d'execució.** La manera més fàcil és fent clic dret sobre el fitxer > Propietats > Permisos > i marcar la casella "Permet executar el fitxer com un programa".
    *   Alternativament, des de la terminal: `chmod +x GestorEsdeveniments-*.AppImage`
*   Fes doble clic sobre el fitxer per executar l'aplicació.
---


### 📂 Fitxers d'Exemple

Per ajudar-te a començar, hem inclòs una carpeta anomenada `examples json` amb fitxers de dades que pots utilitzar.

*   **`example_all.json`**: És un arxiu de projecte complet amb esdeveniments, personal i material. Per utilitzar-lo:
    1.  Ves al menú **`Arxiu > Obrir...`**.
    2.  Selecciona el fitxer `example_all.json`.
    3.  L'aplicació carregarà el projecte. Pots desar els canvis amb `Guardar` o `Guardar com...`.

*   **`example_person.json`**: Conté una llista de contactes. Aquesta funció està pensada per **importar** contactes a un projecte existent.
    1.  Obre o crea un projecte.
    2.  Ves al menú **`Arxiu > Importar / Exportar > Importar Persones...`**.
    3.  Selecciona `example_person.json`.
    4.  L'aplicació et preguntarà si vols **fusionar** la nova llista amb l'existent (afegint només les persones que no existeixin) o **reemplaçar** completament la llista actual.

*   **`example_material.json`**: Un inventari de material d'exemple. Funciona de la mateixa manera que la importació de persones.
    1.  Obre o crea un projecte.
    2.  Ves al menú **`Arxiu > Importar / Exportar > Importar Material...`**.
    3.  Tria entre **fusionar** l'inventari o **reemplaçar-lo**.

## ✒️ Autoria

-   **Autor Principal:** Pëp 
-   **Co-autoria i Suport Tècnic:** Isaac ;) / Google Gemini - Google Studio IA - Jules / Github Copilot / Perplexity / ChatGPT / Claude /

## 📄 Llicència

Aquest projecte està sota la llicència **GNU General Public License v3.0**.

Això significa que ets lliure d'utilitzar, estudiar, modificar i compartir aquest software. No obstant això, qualsevol treball derivat que distribueixis ha de ser publicat sota aquesta mateixa llicència, garantint que el codi romangui sempre lliure i obert per a tota la comunitat.

Pots llegir el text complet de la llicència al fitxer [LICENSE](LICENSE) del projecte.

---
## 🚀 Novetats i Funcionalitats Clau

* **Centre de Control de Material (Redissenyat):**
  * **Càlcul de Pic de Demanda Concurrent:** La nova lògica calcula la demanda màxima d'un ítem en un sol dia dins d'un període, oferint una previsió d'estoc molt més realista.
  * **Interfície Reorganitzada:** Les columnes s'han reordenat per prioritzar la informació d'estoc i balanç. L'ordenació per defecte ara ressalta els ítems amb més problemes de disponibilitat.
  * **Desglossament Enriquit:** El desglossament per esdeveniment ara inclou les dates, proporcionant un context immediat.

* **Millores en Exportacions (PDF i CSV):**
  * **Noms de Fitxer Intel·ligents:** Els fitxers exportats (PDF/CSV) ara tenen noms descriptius que reflecteixen automàticament els filtres aplicats (p. ex., `Llista_Esdeveniments_Persona_Pep_+Filtres.pdf`), millorant dràsticament l'organització i la claredat dels documents generats.
  * **Ordenació Jeràrquica:** Els informes PDF de resum i CSV ara presenten les dades ordenades jeràrquicament per categoria, origen i nom, facilitant la seva anàlisi.
  * **PDF de Resum Millorat:** S'ha afegit la columna "Origen" i s'han reorganitzat les columnes per a una major claredat.
  * **Correcció d'Exportació Detallada:** Solucionat un error que generava un PDF detallat buit si no se seleccionava cap esdeveniment al filtre. Ara, l'informe sempre reflecteix les dades visibles a la taula.

* **Gestió d'Estat amb Zustand:**
  * Estat global optimitzat amb selectors independents per evitar bucles infinits de renderitzat.
  * Historial desfer/refer interactiu amb modal, botons i descripcions clares d'acció.

* **Backups i Logs Optimizats:**
  * **Backups Contextuals:** El sistema ara només crea còpies de seguretat automàtiques en desar el fitxer de dades principal de l'aplicació, evitant generar backups innecessaris durant les exportacions a PDF o CSV.
  * **Rotació de Logs Intel·ligent:** S'ha optimitzat el sistema de logs per limitar automàticament el nombre i la mida dels fitxers, reduint l'ús d'espai en disc sense perdre l'historial d'errors recent.

* **Separació de Configuració Google:**
  * Configuració local (`google-config.json`) independent de la configuració de cada document.
  * Sincronització multi-calendari i gestió d'IDs separada per usuari i projecte.

* **Instància Única:**
  * Bloqueig d'instància per evitar errors d'escriptura i finestres duplicades.

* **Menú Personalitzat en React:**
  * Substitució del menú natiu d'Electron per un component React, amb accions IPC centralitzades.

* **Sistema d'Arxivatge:** Nova funcionalitat per arxivar esdeveniments antics, mantenint la llista principal neta i organitzada.

*   **Finestra "Sobre l'aplicació":** Accessible des del menú "Ajuda", mostra informació rellevant sobre la versió, descripció i enllaços del projecte.

* **Altres millores:**
  * **Sistema de Temes Automatitzat:** S'ha implementat un sistema de gestió de colors centralitzat. Tota la paleta de colors es defineix en un únic fitxer de configuració (`theme.config.cjs`) i un script automatitzat (`npm run build:theme`) genera tots els estils necessaris, garantint una consistència total entre el tema de l'aplicació (clar/fosc) i els elements externs com els PDF. Per a més detalls tècnics, consulta la [guia de desenvolupament](DEVELOPING.md).
  * **Disseny Fluid (Full-Width):** L'aplicació ara utilitza un disseny d'amplada completa que aprofita tot l'espai de la pantalla, reemplaçant l'anterior contenidor centrat per optimitzar la visualització en monitors grans.
  * Refactorització de stores, modals, tech_sheets i utils.
  * Gestió d'errors robusta amb logs de sessió i ErrorBoundary.

---
## Desenvolupament

## 🔒 Tancament Intel·ligent i Backups

L'aplicació prioritza la integritat de les teves dades amb un sistema de desat i backups segur.

-   **Diàleg de Sortida Únic:** En intentar tancar l'aplicació amb canvis no desats, es mostra un únic diàleg que t'ofereix un control clar: `Desa`, `Tanca sense desar` o `Cancel·la`.
-   **Backups Automàtics Contextuals:** Es crea automàticament un backup del teu document cada vegada que el deses amb èxit (`Guardar` o `Guardar com...`). Aquest sistema és intel·ligent: només s'activa en desar el fitxer de dades principal, no en exportar PDFs o CSVs. El sistema gestiona una rotació, conservant les còpies més recents per a cada document.

## ⚡ Configuració de Google: Separació Local vs Document

La configuració de Google Calendar es gestiona de forma separada:
- La configuració local (`google-config.json`) manté calendaris gestionats, calendaris externs i preferències de l'usuari.
- Quan obres un document, només s'actualitzen els calendaris gestionats i l'ID actiu; la resta de preferències romanen intactes.
- Això garanteix que la configuració personal no es perdi ni se sobreescrigui accidentalment.

Si vols contribuir al projecte, consulta la nostra [guia de desenvolupament](DEVELOPING.md) per obtenir informació sobre com configurar l'entorn i entendre els canvis recents.

--- END: ../Gestor-Events_i_Personal/README.md -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/index.html -- branca DEV_pre-monorepoV1.3.0 ---
<!DOCTYPE html>
<html lang="ca">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gestor de Esdeveniments i Personal V1.3.0</title>
    <link rel="stylesheet" href="/src/index.css"> 
  </head>

  <body class="bg-background text-foreground">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    
    <!-- El punt d'entrada de la teva aplicació React -->
    <script type="module" src="/src/index.tsx"></script> 
  </body>
</html>
--- END: ../Gestor-Events_i_Personal/index.html -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/main.cjs -- branca DEV_pre-monorepoV1.3.0 ---
const { app, BrowserWindow, ipcMain, dialog, Menu, shell } = require('electron');
const path = require('path');
const fs = require('fs');
const os = require('os');
const { google } = require('googleapis');
const url = require('url');
const http = require('http');
const log = require('electron-log');

// --- CONFIGURACIÓ DE LOGS AMB ELECTRON-LOG ---
// Configura la rotació de logs per mida per evitar fitxers excessivament grans
// i un nombre excessiu de fitxers de log.
log.transports.file.fileName = 'main.log'; // Nom de fitxer estàtic
log.transports.file.maxSize = 1048576; // 1 MB

// Lògica personalitzada per arxivar i netejar logs antics
log.transports.file.archiveLogFn = (oldLogFile) => {
  const logDir = path.dirname(oldLogFile.path);
  // Utilitzem un timestamp per assegurar noms únics i poder ordenar-los
  const archiveName = `main.${Date.now()}.log`;
  const archivePath = path.join(logDir, archiveName);

  try {
    // 1. Renombra el fitxer de log actual a un nom d'arxiu
    fs.renameSync(oldLogFile.path, archivePath);

    // 2. Neteja els arxius de log més antics si se supera el límit
    const MAX_ARCHIVES = 9; // Mantenim 9 arxius + el 'main.log' actiu, sumant un total de 10.
    const files = fs.readdirSync(logDir);

    const logArchives = files
      // Filtrem per fitxers que coincideixin amb el nostre patró d'arxiu
      .filter(f => f.startsWith('main.') && f.endsWith('.log'))
      // Els ordenem del més antic al més nou basant-nos en el timestamp
      .sort((a, b) => {
        const timeA = parseInt(a.split('.')[1] || '0');
        const timeB = parseInt(b.split('.')[1] || '0');
        return timeA - timeB;
      });

    // Si el nombre d'arxius supera el límit, eliminem els més antics
    if (logArchives.length > MAX_ARCHIVES) {
      const filesToDelete = logArchives.slice(0, logArchives.length - MAX_ARCHIVES);
      filesToDelete.forEach(f => {
        try {
          fs.unlinkSync(path.join(logDir, f));
          console.debug(`Arxiu de log antic eliminat: ${f}`);
        } catch (unlinkErr) {
          console.error(`Error eliminant l'arxiu de log antic ${f}:`, unlinkErr);
        }
      });
    }
  } catch (err) {
    console.error('S\'ha produït un error durant la rotació de logs:', err);
  }
};

// Nivell de log: 'debug' en desenvolupament, 'info' en producció.
log.level = process.env.NODE_ENV === 'development' ? 'debug' : 'info';
// Sobreescriu els mètodes de la consola per redirigir-los a electron-log.
console.log = log.info.bind(log);
console.error = log.error.bind(log);
console.warn = log.warn.bind(log);
console.debug = log.debug.bind(log); // Afegim debug per a més granularitat
// Inicialitza el logger per al procés principal. Això començarà a capturar logs.
log.initialize();

const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json'), 'utf8'));
const metadataJson = JSON.parse(fs.readFileSync(path.join(__dirname, 'metadata.json'), 'utf8'));

const appMetadata = {
  name: packageJson.productName,
  version: packageJson.version,
  description: metadataJson.description,
};

app.disableHardwareAcceleration();

console.log('**************************************************');
console.log('*** INICIANT PROCÉS PRINCIPAL DE L\'APLICACIÓ ***');
console.log('**************************************************');
// Log del fitxer on es desa la informació
console.log('Tots els logs d\'aquesta sessió s\'emmagatzemen a:', log.transports.file.getFile().path);

const APP_ID = 'com.gestorevents.app';
app.setAppUserModelId(APP_ID);

const CONFIG_DIR = app.getPath('userData');
const DATA_DIR = CONFIG_DIR;
const SESSION_FILE = path.join(CONFIG_DIR, 'session.json');
const BACKUP_DIR = path.join(DATA_DIR, 'backups');
const GOOGLE_TOKENS_PATH = path.join(CONFIG_DIR, 'google-tokens.json');
const GOOGLE_CONFIG_PATH = path.join(CONFIG_DIR, 'google-config.json');

const APP_CALENDAR_BASE_NAME = "Gestor d'Esdeveniments (App)";

// ---  SINGLE INSTANCE LOCK ---
// Aquest codi assegura que només una instància de l'aplicació s'executi alhora.
const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  // Si no aconseguim el candau, significa que una altra instància ja s'està executant.
  // En aquest cas, tanquem aquesta nova instància immediatament.
  app.quit();
} else {
  // Si aconseguim el candau, som la primera instància.
  app.on('second-instance', (event, commandLine, workingDirectory) => {
    // Aquest esdeveniment es dispara quan un usuari intenta obrir una segona instància.
    // El que fem és posar la finestra de la nostra instància (la primera) en primer pla.
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });
}

let mainWindow;
let isQuitting = false;
let isAuthenticating = false;
let googleAuthClient;
let googleCredentials;
let googleServiceAccountClient;

// REFACCIÓ: La gestió de fitxers ara es fa amb handlers d'IPC específics cridats des del renderer.
// Aquesta funció ja no és necessària.

ipcMain.handle('open-file-dialog', async () => {
  console.debug("[IPC_IN] Rebut 'open-file-dialog'.");
  if (!mainWindow) return { success: false, message: 'No hi ha cap finestra activa.' };

  try {
    const result = await dialog.showOpenDialog(mainWindow, {
      properties: ['openFile'],
      filters: [{ name: 'JSON', extensions: ['json'] }],
      title: 'Obrir document',
    });

    if (result.canceled || !result.filePaths.length) {
      return { success: false, canceled: true };
    }

    const filePath = result.filePaths[0];
    console.debug(`Fitxer seleccionat per obrir: ${filePath}`);
    return { success: true, filePath };
  } catch (error) {
    console.error('Error en el diàleg per obrir fitxer:', error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle('read-file', async (event, filePath) => {
  console.debug(`[IPC_IN] Rebut 'read-file' per a: ${filePath}`);
  if (!filePath) return { success: false, message: 'filePath no pot ser buit.' };
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    return { success: true, content };
  } catch (error) {
    console.error(`Error llegint el fitxer ${filePath}:`, error);
    return { success: false, message: `No s'ha pogut llegir el fitxer: ${error.message}` };
  }
});

ipcMain.handle('save-file', async (event, { filePath, data }) => {
  console.debug(`[IPC_IN] Rebut 'save-file' per a: ${filePath}`);
  if (!filePath) return { success: false, message: 'filePath no pot ser buit.' };
  try {
    fs.writeFileSync(filePath, data, 'utf8');
    console.info(`Fitxer desat correctament a: ${filePath}`);

    // La crida a 'save-file' sempre prové del desat del document principal,
    // per tant, sempre creem una còpia de seguretat.
    console.info('Desant un document principal via save-file. Es crearà una còpia de seguretat.');
    await createBackup(filePath);
    await cleanupOldBackups(filePath);

    return { success: true };
  } catch (error) {
    console.error(`Error desant el fitxer a ${filePath}:`, error);
    return { success: false, message: `No s'ha pogut desar el fitxer: ${error.message}` };
  }
});

const generateId = () => Date.now().toString(36) + Math.random().toString(36).substring(2);

// Funció auxiliar per obtenir la ruta relativa a la carpeta de l'usuari
function getRelativePath(absolutePath) {
  if (!absolutePath) return '';
  const homeDir = os.homedir();
  if (absolutePath.startsWith(homeDir)) {
    return absolutePath.replace(homeDir, '~');
  }
  return absolutePath;
}

const addDaysISO = (dateStr, days) => {
  const date = new Date(dateStr);
  date.setDate(date.getDate() + days);
  return date.toISOString().split('T')[0];
};

function ensureDirectoriesExist() {
  [CONFIG_DIR, DATA_DIR, BACKUP_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
}

function loadGoogleCredentials() {
  try {
    const credentialsPath = path.join(__dirname, 'google-credentials.json');
    if (!fs.existsSync(credentialsPath)) return false;

    const content = fs.readFileSync(credentialsPath);
    googleCredentials = JSON.parse(content).installed;
    googleAuthClient = new google.auth.OAuth2(googleCredentials.client_id, googleCredentials.client_secret);
    
    if (fs.existsSync(GOOGLE_TOKENS_PATH)) {
      const tokens = JSON.parse(fs.readFileSync(GOOGLE_TOKENS_PATH));
      googleAuthClient.setCredentials(tokens);
    }
  } catch (err) {
    console.error('Error carregant credencials de Google:', err);
    return false;
  }
  return true;
}

async function loadServiceAccountCredentials() {
  try {
    const serviceAccountPath = path.join(__dirname, 'service-account.json');
    if (!fs.existsSync(serviceAccountPath)) {
      console.warn('El fitxer service-account.json no es troba. Les funcionalitats avançades de Google Calendar estaran desactivades.');
      return false;
    }

    const keys = JSON.parse(fs.readFileSync(serviceAccountPath, 'utf8'));

    googleServiceAccountClient = await new google.auth.GoogleAuth({
  credentials: {
    client_email: keys.client_email,
    private_key: keys.private_key,
  },
  scopes: ['https://www.googleapis.com/auth/calendar'],
  }).getClient();

    console.info("Client del Compte de Servei de Google inicialitzat i autoritzat correctament.");
    return true;

  } catch (err) {
    console.error('Error carregant les credencials del Compte de Servei de Google:', err);
    dialog.showErrorBox(
        'Error d\'Autenticació del Compte de Servei',
        `No s'ha pogut autenticar amb el compte de servei de Google. Comprova la validesa del teu fitxer "service-account.json" i la configuració a Google Cloud Console.\n\nError: ${err.message}`
    );
    googleServiceAccountClient = null;
    return false;
  }
}

function checkWritePermissions(dir) {
  try {
    const testFile = path.join(dir, '.write-test');
    fs.writeFileSync(testFile, '');
    fs.unlinkSync(testFile);
    return true;
  } catch (error) {
    return false;
  }
}

function getAlternativeDirectory(baseDir) {
  return path.join(app.getPath('userData'), baseDir);
}




function loadSessionData() {
  if (!SESSION_FILE) return {};
  try {
    if (fs.existsSync(SESSION_FILE)) {
      return JSON.parse(fs.readFileSync(SESSION_FILE, 'utf8'));
    }
  } catch (error) {
    console.error('Error carregant les dades de la sessió:', error);
  }
  return {};
}

async function saveDataWithErrorHandling(filePath, data) {
  if (!filePath) {
    throw new Error("filePath no està definit.");
  }
  try {
    const dirPath = path.dirname(filePath);
    if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath, { recursive: true });
    if (!checkWritePermissions(dirPath)) throw new Error(`No hi ha permisos d'escriptura a ${dirPath}`);
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    console.info(`Dades desades correctament a ${filePath}`);
    return true;
  } catch (error) {
    console.error(`Error guardant a ${filePath}:`, error);
    dialog.showMessageBoxSync({ type: 'error', title: 'Error guardant dades', message: `No s'han pogut guardar les dades a ${filePath}\\nError: ${error.message}` });
    throw error;
  }
}

async function saveSessionData(newData) {
  const currentData = loadSessionData();
  const mergedData = { ...currentData, ...newData };
  return saveDataWithErrorHandling(SESSION_FILE, mergedData);
}

async function createBackup(sourceFilePath) {
  if (!sourceFilePath || !BACKUP_DIR) return false;
  try {
    if (fs.existsSync(sourceFilePath)) {
      if (!fs.existsSync(BACKUP_DIR)) fs.mkdirSync(BACKUP_DIR, { recursive: true });
      if (!checkWritePermissions(BACKUP_DIR)) throw new Error(`No hi ha permisos d'escriptura a ${BACKUP_DIR}`);

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const sourceFileName = path.basename(sourceFilePath, '.json'); // Get filename without extension
      const backupFile = path.join(BACKUP_DIR, `backup-${sourceFileName}-${timestamp}.json`);

      fs.copyFileSync(sourceFilePath, backupFile);
      console.info(`Còpia de seguretat creada a: ${backupFile}`);
      return true;
    }
  } catch (error) {
    console.error('Error creant còpia de seguretat:', error);
  }
  return false;
}
async function cleanupOldBackups(sourceFilePath) {
  const MAX_BACKUPS_TO_KEEP = 5;
  if (!fs.existsSync(BACKUP_DIR) || !sourceFilePath) {
    return;
  }
  
  const sourceFileName = path.basename(sourceFilePath, '.json');
  const backupPrefix = `backup-${sourceFileName}-`;

  try {
    console.debug(`Netejant backups antics per a ${sourceFileName}...`);
    const backupFiles = fs.readdirSync(BACKUP_DIR)
      .filter(file => file.startsWith(backupPrefix) && file.endsWith('.json'))
      .map(file => {
        const filePath = path.join(BACKUP_DIR, file);
        try {
          const stats = fs.statSync(filePath);
          return { name: file, time: stats.mtime.getTime() };
        } catch (statError) {
          console.error(`No s'ha pogut obtenir informació del fitxer ${file}:`, statError);
          return null;
        }
      })
      .filter(Boolean)
      .sort((a, b) => b.time - a.time);

    if (backupFiles.length > MAX_BACKUPS_TO_KEEP) {
      console.debug(`Trobats ${backupFiles.length} backups. Conservant els ${MAX_BACKUPS_TO_KEEP} més recents.`);
      const backupsToDelete = backupFiles.slice(MAX_BACKUPS_TO_KEEP);
      
      backupsToDelete.forEach(backup => {
        try {
          fs.unlinkSync(path.join(BACKUP_DIR, backup.name));
          console.debug(`Backup eliminat: ${backup.name}`);
        } catch (unlinkError) {
          console.error(`Error eliminant el backup ${backup.name}:`, unlinkError);
        }
      });
    } else {
      console.debug(`Trobats ${backupFiles.length} backups. No cal neteja.`);
    }
  } catch (error) {
    console.error('Error durant la neteja de backups:', error);
  }
}

function loadGoogleConfigFromFile() {
    if (!fs.existsSync(GOOGLE_CONFIG_PATH)) return null;
    try {
        return JSON.parse(fs.readFileSync(GOOGLE_CONFIG_PATH, 'utf8'));
    } catch(err) {
        console.error('Error llegint el fitxer de configuració de Google:', err);
        return null;
    }
}

async function findOrCreateAppCalendar(calendarService, userEmail, calendarSuffix) {
  try {
    const suffix = calendarSuffix ? ` - ${calendarSuffix}` : '';
    const finalCalendarName = `${APP_CALENDAR_BASE_NAME}${suffix}`;
    let calendarId;
    let wasNewlyCreated = false; // Per saber si cal notificar

    // Pas 1: Comprovar si ja existeix un calendari amb aquest nom
    console.debug("SA: Buscant calendaris existents per evitar duplicats...");
    const calendarList = await calendarService.calendarList.list();
    const existingCalendar = calendarList.data.items.find(cal => cal.summary === finalCalendarName);

    if (existingCalendar) {
      console.debug(`SA: Trobat calendari existent amb nom "${finalCalendarName}". ID: ${existingCalendar.id}.`);
      calendarId = existingCalendar.id;
    } else {
      console.info(`SA: No s'ha trobat cap calendari existent. Creant un de nou amb el nom: "${finalCalendarName}"`);
      const newCalendar = await calendarService.calendars.insert({
        requestBody: {
          summary: finalCalendarName,
          description: "Calendari gestionat per l'aplicació Gestor d'Esdeveniments.",
          timeZone: 'Europe/Madrid'
        }
      });
      calendarId = newCalendar.data.id;
      wasNewlyCreated = true; // Marquem que s'ha creat ara
      console.info(`SA: Calendari creat amb ID: ${calendarId}`);
    }

    // Pas 2: Compartir el calendari (nou o existent) amb l'usuari
    if (!userEmail) {
      throw new Error("L'email de l'usuari és necessari per compartir el calendari.");
    }

    console.debug(`SA: Assegurant que el calendari ${calendarId} està compartit amb ${userEmail}...`);
    await calendarService.acl.insert({
      calendarId: calendarId,
      sendNotifications: wasNewlyCreated, // Només notifiquem si el calendari és nou
      requestBody: {
        role: 'reader',
        scope: { type: 'user', value: userEmail },
      },
    });

    console.info('SA: Permisos del calendari verificats/actualitzats amb èxit.');
    return calendarId;

  } catch (error) {
    console.error("SA: Error en findOrCreateAppCalendar:", error.message, error.response?.data);
    throw error;
  }
}

async function createWindow() {
  console.debug('[Startup] Iniciant createWindow...');
  ensureDirectoriesExist();
  console.debug('[Startup] Directoris assegurats.');
  loadGoogleCredentials(); 
  console.debug('[Startup] Credencials de Google carregades (si existeixen).');
  await loadServiceAccountCredentials();
  console.debug('[Startup] Credencials del compte de servei carregades (si existeixen).');
  const sessionData = loadSessionData();
  console.debug('[Startup] Dades de la sessió anterior carregades.');

  mainWindow = new BrowserWindow({
    width: sessionData.width || 1200,
    height: sessionData.height || 800,
    x: sessionData.x,
    y: sessionData.y,
    show: false,
    autoHideMenuBar: true,
    webPreferences: {
      preload: path.join(__dirname, 'preload.cjs'),
      contextIsolation: true,
      enableRemoteModule: false,
      nodeIntegration: false,
      sandbox: true,
    },
  });

  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
  });

  const isDev = process.env.NODE_ENV === 'development' || !app.isPackaged;
console.debug('[Startup] Mode de desenvolupament:', isDev);
console.debug('[Startup] NODE_ENV:', process.env.NODE_ENV);
console.debug('[Startup] app.isPackaged:', app.isPackaged);

if (isDev) {
  const devUrl = process.env.VITE_DEV_SERVER_URL || 'http://localhost:5173';
  console.debug('[Startup] Carregant des del servidor de desenvolupament:', devUrl);
  mainWindow.loadURL(devUrl).catch(err => {
    console.error('Error loading dev URL:', devUrl, err);
    dialog.showErrorBox('Error de Desenvolupament', `No s'ha pogut carregar ${devUrl}: ${err.message}`);
  });
} else {
  const indexPath = path.resolve(__dirname, 'dist', 'index.html');
  console.info('[Startup] Carregant des del fitxer de producció:', indexPath);
  mainWindow.loadFile(indexPath).catch(err => {
    console.error('Error loading production index file:', indexPath, err);
    dialog.showErrorBox('Error de Càrrega', `No s'ha pogut carregar l'aplicació: ${error.message}`);
  });
}


  const template = [
    {
      label: 'Arxiu',
      submenu: [
        { label: 'Carregar Tot', click: () => mainWindow.webContents.send('menu-action', 'load-all') },
        { label: 'Guardar Tot', click: () => mainWindow.webContents.send('menu-action', 'save-all') },
        { label: 'Carregar Material', click: () => mainWindow.webContents.send('menu-action', 'load-material') },
        { label: 'Començar de Zero', click: () => mainWindow.webContents.send('menu-action', 'hard-reset') },
        { type: 'separator' },
        { label: 'Carregar Persones', click: () => mainWindow.webContents.send('menu-action', 'load-people') },
        { label: 'Guardar Persones', click: () => mainWindow.webContents.send('menu-action', 'save-people') },
        { label: 'Guardar Material', click: () => mainWindow.webContents.send('menu-action', 'save-material') },
        { type: 'separator' },
        {
          label: 'Configuració Google Calendar',
          submenu: [
            { label: 'Sincronitzar', click: () => mainWindow.webContents.send('menu-action', 'sync-google') },
            { label: 'Configurar', click: () => mainWindow.webContents.send('menu-action', 'config-google') },
            { label: 'Connectar amb Google', click: () => mainWindow.webContents.send('menu-action', 'connect-google') },
          ]
        },
        { type: 'separator' },
        { label: 'Tema Clar/Fosc', click: () => mainWindow.webContents.send('menu-action', 'toggle-theme') },
        { type: 'separator' },
        { label: 'Sortir', accelerator: 'CmdOrCtrl+Q', click: () => { app.quit(); } }
      ]
    },
    {
      label: 'Veure',
      submenu: [
        { role: 'reload' }, { role: 'forceReload' }, { role: 'toggleDevTools' },
        { type: 'separator' }, { role: 'resetZoom' }, { role: 'zoomIn' }, { role: 'zoomOut' },
        { type: 'separator' }, { role: 'togglefullscreen' }
      ]
    }
  ];

  // const menu = Menu.buildFromTemplate(template);
  // Menu.setApplicationMenu(menu);
  console.debug('[Startup] Menú de l\'aplicació configurat (actualment desactivat en favor de la UI).');

  // >>> CANVI PRINCIPAL EN LA LÒGICA DE TANCAMENT <<<
  mainWindow.on('close', (event) => {
    console.debug(`[Exit Flow] Event 'close' rebut a la finestra. isQuitting: ${isQuitting}`);
    if (!isQuitting) {
      event.preventDefault(); // Prevenim que la finestra es tanqui directament
      app.quit(); // Iniciem el flux de sortida de l'aplicació
    }
  });
}

app.on('web-contents-created', (event, contents) => {
  contents.setWindowOpenHandler(({ url }) => {
    // Open external links in the default browser
    if (url.startsWith('http:') || url.startsWith('https:')) {
      shell.openExternal(url);
    }
    return { action: 'deny' };
  });
  // Prevent navigation to external links within the app
  contents.on('will-navigate', (event, url) => {
    if (url.startsWith('http:') || url.startsWith('https:')) {
      event.preventDefault();
      shell.openExternal(url);
    }
  });
});

app.on('before-quit', async (event) => {
  console.debug(`[Exit Flow] Event 'before-quit' rebut. isQuitting: ${isQuitting}`);
  if (isQuitting) return; // Evita bucles de tancament

  event.preventDefault(); // Prevenim la sortida immediata per donar control al frontend

  // Desar l'estat de la finestra (mida, posició) per a la propera sessió
  if (mainWindow && !mainWindow.isDestroyed()) {
    const windowBounds = mainWindow.getBounds();
    await saveSessionData({
      width: windowBounds.width,
      height: windowBounds.height,
      x: windowBounds.x,
      y: windowBounds.y
    });

    console.info('[Exit Flow] Estat de la finestra desat. Enviant senyal de confirmació al frontend...');
    // Envia el senyal al frontend perquè gestioni la lògica de desat/backup
    mainWindow.webContents.send('confirm-quit-signal');

  } else {
    // Si no hi ha finestra, no cal esperar el frontend.
    console.info('[Exit Flow] No hi ha finestra principal, sortint directament.');
    isQuitting = true;
    app.quit();
  }
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});


console.debug('[Startup] Configurant gestors de IPC...');

ipcMain.handle('quit-application', () => {
  console.info("[Exit Flow] Rebut 'quit-application'. Sortint de l'aplicació.");
  isQuitting = true;
  app.quit();
});

ipcMain.handle('load-app-data', async () => {
  // REFACCIÓ: Aquesta funció ara només serveix per indicar a l'App que pot començar.
  // La càrrega de dades es gestiona a través de les accions de l'usuari (Obrir, Recents).
  console.debug("[IPC_IN] Rebut 'load-app-data'. L'aplicació començarà amb un estat buit.");
  return null;
});

ipcMain.handle('get-recent-files', async () => {
  console.debug("[IPC_IN] Rebut 'get-recent-files'.");
  const sessionData = loadSessionData();
  return sessionData.recentFiles || [];
});

ipcMain.handle('add-recent-file', async (event, filePath) => {
  console.debug(`[IPC_IN] Rebut 'add-recent-file' per a: ${filePath}`);
  if (!filePath) return { success: false, message: 'filePath no pot ser buit.' };

  try {
    const sessionData = loadSessionData();
    let recentFiles = sessionData.recentFiles || [];

    // Eliminar duplicats i moure el fitxer al principi
    recentFiles = recentFiles.filter(f => f !== filePath);
    recentFiles.unshift(filePath);

    // Limitar la llista a 10 fitxers
    const MAX_RECENT_FILES = 10;
    if (recentFiles.length > MAX_RECENT_FILES) {
      recentFiles = recentFiles.slice(0, MAX_RECENT_FILES);
    }

    await saveSessionData({ recentFiles });
    console.debug("Fitxers recents actualitzats:", recentFiles);
    return { success: true, recentFiles };
  } catch (error) {
    console.error('Error afegint a fitxers recents:', error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle('sync-with-google', async (event, { localData, targetCalendarId }) => {
  console.info(`[IPC_IN] Iniciant 'sync-with-google' cap a ${targetCalendarId}.`);
  if (!googleServiceAccountClient) {
    console.error("SYNC ERROR: El client del compte de servei de Google no està inicialitzat.");
    return { success: false, message: 'El client del compte de servei de Google no està inicialitzat. Assegura\'t que el fitxer "service-account.json" existeix i és correcte.' };
  }
  let config = loadGoogleConfigFromFile();
  if (!config?.userEmail) {
    console.error("SYNC ERROR: No s'ha trobat l'email de l'usuari a la configuració.");
    return { success: false, message: 'No s\'ha trobat l\'email de l\'usuari. Si us plau, connecta\'t a Google primer.' };
  }
  if (!targetCalendarId) {
    console.error("SYNC ERROR: No s'ha proporcionat un targetCalendarId.");
    return { success: false, message: "No s'ha especificat cap calendari de destinació per a la sincronització." };
  }
  
  const calendar = google.calendar({ version: 'v3', auth: googleServiceAccountClient });
  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

  const targetCalendar = config.managedAppCalendars?.find(c => c.id === targetCalendarId);
  if (!targetCalendar) {
    return { success: false, message: "El calendari de destinació no es troba a la llista de calendaris gestionats." };
  }
  const finalCalendarName = targetCalendar.name;

  // Pas 5: Gestió de calendaris eliminats
  try {
    console.debug(`SA: Verificant existència del calendari a Google: ${targetCalendarId}`);
    await calendar.calendars.get({ calendarId: targetCalendarId });
    console.debug('SA: El calendari existeix.');
  } catch (err) {
    if (err.code === 404) {
      console.warn(`SA: El calendari amb ID ${targetCalendarId} no s'ha trobat. Ha estat eliminat per l'usuari.`);

      // Eliminar el calendari orfe de la configuració
      config.managedAppCalendars = config.managedAppCalendars.filter(c => c.id !== targetCalendarId);
      if (config.activeAppCalendarId === targetCalendarId) {
        config.activeAppCalendarId = config.managedAppCalendars.length > 0 ? config.managedAppCalendars[0].id : null;
      }
      fs.writeFileSync(GOOGLE_CONFIG_PATH, JSON.stringify(config, null, 2));

      // Retornar error específic al frontend
      return { success: false, code: 'CALENDAR_NOT_FOUND', message: `El calendari "${finalCalendarName}" ja no existeix a Google. S'ha eliminat de la llista.` };
    } else {
      console.error('Error de xarxa o desconegut verificant el calendari:', err.message, err.response?.data);
      const customMessage = err.code === 403
        ? "Permís denegat per accedir al calendari. Revisa els permisos del Compte de Servei."
        : `No s'ha pogut connectar a Google. Comprova la teva connexió. (${err.message})`;
      return { success: false, message: customMessage };
    }
  }

  // DIÀLEG DE CONFIRMACIÓ
  const choice = await dialog.showMessageBox(mainWindow, {
    type: 'question',
    buttons: ['Sí, sincronitzar', 'Cancel·lar'],
    defaultId: 1,
    cancelId: 1,
    title: 'Confirmar Sincronització',
    message: `Estàs a punt de sobreescriure el calendari "${finalCalendarName}" a Google Calendar.`,
    detail: 'Totes les dades d\'aquest calendari a Google s\'esborraran i se substituiran per les dades actuals de l\'aplicació. Qualsevol canvi que hagis fet directament a Google es perdrà. Aquesta acció és irreversible. Vols continuar?',
  });

  if (choice.response !== 0) {
    console.info("Sincronització cancel·lada per l'usuari.");
    return { success: false, message: 'Sincronització cancel·lada.' };
  }

  try {
    // --- PREPARACIÓ PER AL PROGRÉS ---
    const eventsListRes = await calendar.events.list({ calendarId: targetCalendarId, maxResults: 2500 });
    const eventsToDelete = eventsListRes.data.items || [];
    const localFramesToUpload = localData.eventFrames || [];

    const totalProgressSteps = eventsToDelete.length + localFramesToUpload.length;
    let currentProgressStep = 0;

    const sendProgress = (message) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('sync-progress', {
          current: currentProgressStep,
          total: totalProgressSteps,
          message: message,
        });
      }
    };

    // FASE 1: BUIDAR COMPLETAMENT EL CALENDARI
    console.info(`Buidant el calendari de l'app a Google: ${targetCalendarId}`);
    if (eventsToDelete.length > 0) {
      console.debug(`Trobats ${eventsToDelete.length} esdeveniments per eliminar...`);
      for (const event of eventsToDelete) {
        currentProgressStep++;
        const progressMessage = `Eliminant ${currentProgressStep} de ${totalProgressSteps}: "${event.summary || 'Esdeveniment sense títol'}"`;
        console.debug(progressMessage);
        sendProgress(progressMessage);
        try {
          await calendar.events.delete({ calendarId: targetCalendarId, eventId: event.id });
          await delay(200);
        } catch (err) {
          if (err.code !== 404 && err.code !== 410) console.error(`Error eliminant l'esdeveniment "${event.summary}":`, err.message);
        }
      }
    }

    // FASE 2: PUJAR TOTS ELS ESDEVENIMENTS DES DE L'APP LOCAL
    console.info(`Pujant ${localFramesToUpload.length} esdeveniments locals al calendari de l'app...`);
    
    for (const localFrame of localFramesToUpload) {
      currentProgressStep++;
      const progressMessage = `Pujant ${currentProgressStep} de ${totalProgressSteps}: "${localFrame.name}"`;
      console.debug(progressMessage);
      sendProgress(progressMessage);

      const getPersonGroupById = (id) => localData.peopleGroups.find(p => p.id === id);

      // --- CONSTRUCCIÓ DE LA DESCRIPCIÓ ENRIQUIDA ---
      let descriptionParts = [];
      if (localFrame.generalNotes) {
        descriptionParts.push(localFrame.generalNotes);
      }

      // Secció de Personal
      if (localFrame.techSheet?.technicalProviders?.length > 0) {
        const personnelList = localFrame.techSheet.technicalProviders.map(provider => {
          const person = getPersonGroupById(provider.personGroupId);
          const roles = provider.roles.map(r => `  - ${r.quantity}x ${r.role}${r.notes ? ` (${r.notes})` : ''}`).join('\n');
          return `${person ? person.name : 'Proveïdor desconegut'}:\n${roles}`;
        }).join('\n');
        descriptionParts.push(`--- PERSONAL TÈCNIC ---\n${personnelList}`);
      }

      // Secció d'Horaris
      if (localFrame.techSheet?.assemblySchedule?.length > 0) {
        const scheduleList = localFrame.techSheet.assemblySchedule.map(item => `- ${item.time}: ${item.description}`).join('\n');
        descriptionParts.push(`--- HORARIS ---\n${scheduleList}`);
      }

      // Altres detalls
      let otherDetails = [];
      if (localFrame.techSheet?.companyContact) otherDetails.push(`Contacte Cia: ${localFrame.techSheet.companyContact}`);
      if (localFrame.techSheet?.observations) otherDetails.push(`Observacions: ${localFrame.techSheet.observations}`);
      if (otherDetails.length > 0) {
        descriptionParts.push(`--- DETALLS ---\n${otherDetails.join('\n')}`);
      }

      const eventResource = {
        summary: localFrame.name,
        description: descriptionParts.join('\n\n'),
        location: localFrame.place || '',
        start: { date: localFrame.startDate },
        end: { date: addDaysISO(localFrame.endDate, 1) },
      };

      try {
        const newGoogleEvent = await calendar.events.insert({
          calendarId: targetCalendarId,
          requestBody: eventResource,
        });
        localFrame.googleEventId = newGoogleEvent.data.id;
        localFrame.googleCalendarId = targetCalendarId;
        localFrame.lastModified = newGoogleEvent.data.updated;
        localFrame.lastSync = new Date().toISOString();
        console.debug(`  -> Esdeveniment "${localFrame.name}" pujat amb èxit. ID de Google: ${newGoogleEvent.data.id}`);
      } catch (err) {
        console.error(`Error creant "${localFrame.name}" a Google:`, err.message, err.response?.data);
      }
      await delay(250);
    }

    // FASE 3: ACTUALITZAR L'ACTIVE CALENDAR ID I DESAR LA CONFIGURACIÓ
    console.info(`Sincronització amb ${targetCalendarId} completada. Establint-lo com a calendari actiu.`);
    config.activeAppCalendarId = targetCalendarId;
    fs.writeFileSync(GOOGLE_CONFIG_PATH, JSON.stringify(config, null, 2));

    // FASE 4: RETORNAR LES DADES LOCALS ACTUALITZADES
    console.info("SYNC: Sincronització completada amb èxit.");
    return { success: true, message: 'Sincronització completada amb èxit.', data: localData };

  } catch (error) {
    console.error('Error crític durant la sincronització unidireccional:', error.message, error.response?.data);
    const customMessage = error.code === 403
      ? "Permís denegat durant la sincronització. Assegura't que el Compte de Servei té permisos d'Editor sobre el calendari de l'aplicació."
      : `Error de sincronització: ${error.message}`;
    return { success: false, message: customMessage };
  }
});

ipcMain.handle('google-auth-start', async () => {
  console.info("[IPC_IN] Iniciant 'google-auth-start'.");

  if (isAuthenticating) {
    console.warn("AUTH WARN: Ja hi ha un procés d'autenticació en curs.");
    return { success: false, message: "Ja hi ha un procés d'autenticació en curs. Si us plau, espera que acabi." };
  }

  if (!googleAuthClient) {
    console.error("AUTH ERROR: googleAuthClient no inicialitzat.");
    return { success: false, message: "El client d'autenticació de Google no s'ha iniciat correctament." };
  }

  isAuthenticating = true;

  return new Promise((resolve) => {
    const server = http.createServer();
    let state; // Declarar 'state' en un àmbit superior

    const closeServerAndResolve = (result) => {
      if (server.listening) {
        server.close();
      }
      isAuthenticating = false; // Alliberem el bloqueig
      resolve(result);
    };

    server.listen(0, '127.0.0.1', () => {
      const { port } = server.address();
      const redirectUri = `http://localhost:${port}`;
      googleAuthClient.redirectUri = redirectUri;

      state = generateId(); // Assignar valor a 'state'
      const authUrl = googleAuthClient.generateAuthUrl({
        access_type: 'offline', prompt: 'consent',
        scope: [
          'https://www.googleapis.com/auth/userinfo.email',
          'https://www.googleapis.com/auth/userinfo.profile',
          'https://www.googleapis.com/auth/calendar.readonly'
        ],        
        state: state,
      });
      
      console.debug(`Servidor d'autenticació escoltant al port ${port}. Obrint URL d'autenticació.`);
      require('electron').shell.openExternal(authUrl);
    });

    server.on('request', async (req, res) => {
      const qs = new url.URL(req.url, 'http://localhost').searchParams;
      const code = qs.get('code');
      const receivedState = qs.get('state');

      if (receivedState !== state) {
        console.error("Error d'estat CSRF: l'estat rebut no coincideix.");
        res.writeHead(400);
        res.end('<h1>Error: Petició invàlida (CSRF detectat)</h1>');
        req.socket.destroy();
        closeServerAndResolve({ success: false, message: 'Error de validació de l\'estat (CSRF).' });
        return;
      }
      
      if (!code) {
        console.warn("Callback d'autenticació rebut sense codi. L'usuari podria haver cancel·lat.");
        res.end('<h1>Esperant codi...</h1>');
        return;
      }
      
      console.debug("Callback rebut amb codi d'autorització. Obtenint tokens...");

      try {
        const { tokens } = await googleAuthClient.getToken(code);
        googleAuthClient.setCredentials(tokens);
        fs.writeFileSync(GOOGLE_TOKENS_PATH, JSON.stringify(tokens));
        console.info("Tokens de Google obtinguts i desats correctament.");

        // NOU PAS: Obtenir l'email de l'usuari
        const people = google.people({ version: 'v1', auth: googleAuthClient });
        const profile = await people.people.get({
            resourceName: 'people/me',
            personFields: 'emailAddresses',
        });

        const primaryEmail = profile.data.emailAddresses?.find(e => e.metadata?.primary)?.value;
        if (!primaryEmail) {
            throw new Error("No s'ha pogut obtenir l'adreça de correu principal de l'usuari.");
        }
        console.info(`Correu de l'usuari obtingut: ${primaryEmail}`);

        // NOU PAS: Desar l'email i inicialitzar la configuració
        let config = loadGoogleConfigFromFile() || {};
        config.userEmail = primaryEmail;
        // Inicialitzem l'estructura de dades nova si no existeix
        if (!config.managedAppCalendars) config.managedAppCalendars = [];
        if (config.activeAppCalendarId === undefined) config.activeAppCalendarId = null;
        if (!config.selectedCalendarIds) config.selectedCalendarIds = [];

        fs.writeFileSync(GOOGLE_CONFIG_PATH, JSON.stringify(config, null, 2));
        console.info("Correu de l'usuari desat i estructura de configuració inicialitzada.");

        mainWindow.webContents.send('google-auth-success');
        res.end('<h1>Autenticació completada!</h1><p>Pots tancar aquesta pestanya.</p>');
        req.socket.destroy();
        closeServerAndResolve({ success: true });

      } catch (e) {
        console.error("Error en el callback d'autenticació:", e.message, e.response?.data);
        mainWindow.webContents.send('google-auth-error', e.message);
        res.writeHead(500);
        res.end('<h1>Error d\'autenticació</h1>');
        req.socket.destroy();
        closeServerAndResolve({ success: false, message: e.message });
      }
    });

    server.on('error', (err) => {
      console.error("Error del servidor d'autenticació:", err);
      dialog.showErrorBox('Error de Servidor', `No s'ha pogut iniciar el servidor d'autenticació: ${err.message}`);
      closeServerAndResolve({ success: false, message: err.message });
    });
  });
});

ipcMain.handle('load-google-config', async () => {
  console.debug("[IPC_IN] Rebut 'load-google-config'.");
  return loadGoogleConfigFromFile();
});

ipcMain.handle('save-google-config', async (event, config) => {
  console.debug("[IPC_IN] Rebut 'save-google-config' amb:", config);
  try {
    const existingConfig = loadGoogleConfigFromFile() || {};
    // La llista de calendaris gestionats només es modifica a través de 'create' i 'delete'.
    // Aquesta funció només desa l'estat de la selecció de l'usuari.
    const mergedConfig = { ...existingConfig, ...config };

    fs.writeFileSync(GOOGLE_CONFIG_PATH, JSON.stringify(mergedConfig, null, 2));
    console.info("Configuració de Google desada correctament:", mergedConfig);
    return { success: true, data: mergedConfig };
  } catch (err) {
    console.error('Error desant configuració de Google:', err);
    return { success: false, message: err.message };
  }
});

ipcMain.handle('google-get-calendar-list', async () => {
  console.debug("[IPC_IN] Rebut 'google-get-calendar-list'.");
  try {
    if (!googleAuthClient || !googleAuthClient.credentials.access_token) {
        throw new Error('No autenticat. Si us plau, connecta\'t a Google primer.');
    }
    const calendar = google.calendar({ version: 'v3', auth: googleAuthClient });
    const res = await calendar.calendarList.list();
    return {
      success: true,
      calendars: res.data.items?.map(cal => ({
        id: cal.id,
        summary: cal.summary,
        backgroundColor: cal.backgroundColor,
        primary: cal.primary,
      })) || [],
    };
  } catch (error) {
    console.error('Error obtenint la llista de calendaris:', error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle('get-google-events', async () => {
  console.debug("[IPC_IN] Rebut 'get-google-events'.");
  try {
    const config = loadGoogleConfigFromFile();
    if (!config?.selectedCalendarIds?.length) {
      console.debug("No hi ha calendaris de Google seleccionats per mostrar, retornant llista buida.");
      return { success: true, events: [] };
    }
    if (!googleAuthClient?.credentials?.access_token) {
      throw new Error('No autenticat amb Google.');
    }
    
    const calendar = google.calendar({ version: 'v3', auth: googleAuthClient });
    const timeMin = new Date(); timeMin.setMonth(timeMin.getMonth() - 6);
    const timeMax = new Date(); timeMax.setMonth(timeMax.getMonth() + 6);
    const allEvents = [];

    const calendarListResponse = await calendar.calendarList.list();
    const availableCalendars = calendarListResponse.data.items || [];
    const managedIds = new Set(config.managedAppCalendars?.map(c => c.id) || []);

    console.info(`Iniciant la cerca d'esdeveniments per a ${config.selectedCalendarIds.length} calendaris.`);
    for (const calendarId of config.selectedCalendarIds) {
      try {
        const res = await calendar.events.list({
          calendarId: calendarId,
          timeMin: timeMin.toISOString(),
          timeMax: timeMax.toISOString(),
          singleEvents: true,
          orderBy: 'startTime',
        });
        
        const calendarInfo = availableCalendars.find(c => c.id === calendarId);
        let color = calendarInfo?.backgroundColor || '#2196F3';
        if (managedIds.has(calendarId)) {
            color = calendarId === config.activeAppCalendarId ? '#D32F2F' : '#E67C73';
        }

        const events = res.data.items?.map(event => ({
          id: event.id,
          title: event.summary,
          start: event.start.dateTime || event.start.date,
          end: event.end.dateTime || event.end.date,
          allDay: !!event.start.date,
          backgroundColor: color,
          borderColor: color,
          extendedProps: { type: 'google', calendarId: calendarId }
        })) || [];
        
        console.debug(`  -> Trobat(s) ${events.length} esdeveniment(s) per al calendari ${calendarId}.`);
        allEvents.push(...events);

      } catch (loopError) {
        console.error(`Error obtenint esdeveniments del calendari ${calendarId}:`, loopError);
      }
    }
    console.info(`Total d'esdeveniments de Google recuperats: ${allEvents.length}.`);
    return { success: true, events: allEvents };
  } catch (error) {
    console.error('Error general a get-google-events:', error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle('google-get-event-details', async (event, { calendarId, eventId }) => {
  console.debug(`[IPC_IN] Rebut 'google-get-event-details' per a: calendarId=${calendarId}, eventId=${eventId}`);
  try {
    if (!googleAuthClient || !googleAuthClient.credentials.access_token) {
        throw new Error('No autenticat. Si us plau, connecta\'t a Google primer.');
    }
    if (!calendarId || !eventId) {
      throw new Error('Es requereix calendarId i eventId.');
    }

    const calendar = google.calendar({ version: 'v3', auth: googleAuthClient });

    const res = await calendar.events.get({
      calendarId: calendarId,
      eventId: eventId,
    });

    console.debug(`  -> Detalls de l'esdeveniment obtinguts amb èxit per a ${eventId}.`);
    return { success: true, event: res.data };

  } catch (error) {
    console.error(`Error obtenint detalls de l'esdeveniment de Google ${eventId}:`, error);
    const errorMessage = error.response?.data?.error?.message || error.message;
    return { success: false, message: `No s'han pogut obtenir els detalls de l'esdeveniment: ${errorMessage}` };
  }
});

let hasShownUncaughtExceptionDialog = false;
process.on('uncaughtException', (error) => {
  const errorMsg = `Excepció no capturada: ${JSON.stringify(error, null, 2)}\n`;
  
  // Utilitzem electron-log per registrar l'excepció no capturada
  log.error('Excepció no capturada:', error);


  if (!hasShownUncaughtExceptionDialog) {
    hasShownUncaughtExceptionDialog = true;
    dialog.showErrorBox('Error Inesperat', `S'ha produït un error no controlat: ${error.message}\n\nL'aplicació es tancarà.`);
    setTimeout(() => app.exit(1), 500);
  }
});

ipcMain.handle('factory-reset', async () => {
  console.info("[IPC_IN] Rebut 'factory-reset'.");
  console.info("Iniciant Restauració de Fàbrica...");
  
  let success = true;

  let messages = [];

  const eliminarFitxerDeFormaSegura = (filePath, fileNameForMessage) => {
    if (fs.existsSync(filePath)) {
      try {
        fs.unlinkSync(filePath);
        messages.push(`${fileNameForMessage} eliminat.`);
        console.info(`${fileNameForMessage} eliminat: ${filePath}`);
      } catch (err) {
        success = false;
        messages.push(`Error eliminant ${fileNameForMessage}: ${err.message}`);
        console.error(`Error eliminant ${fileNameForMessage} (${filePath}):`, err);
      }
    } else {
      messages.push(`${fileNameForMessage} no existia.`);
      console.debug(`${fileNameForMessage} no existia: ${filePath}`);
    }
  };

  eliminarFitxerDeFormaSegura(GOOGLE_TOKENS_PATH, `Fitxer de tokens de Google (${path.basename(GOOGLE_TOKENS_PATH)})`);
  eliminarFitxerDeFormaSegura(GOOGLE_CONFIG_PATH, `Fitxer de configuració de Google (${path.basename(GOOGLE_CONFIG_PATH)})`);
  eliminarFitxerDeFormaSegura(SESSION_FILE, `Fitxer de sessió (${path.basename(SESSION_FILE)})`);

  if (googleAuthClient) {
    googleAuthClient.setCredentials(null);
    console.info("Credencials de googleAuthClient en memòria netejades.");
    messages.push("Credencials de Google en memòria netejades.");
  }
  
  if (success) {
    console.info("Reset de fàbrica del backend completat.");
    return { success: true, message: `Reset completat:\n${messages.join('\n')}` };
  } else {
    console.error("El reset de fàbrica ha fallat en alguns passos.");
    return { success: false, message: `El reset de fàbrica ha fallat:\n${messages.join('\n')}` };
  }
});

ipcMain.handle('show-unsaved-changes-dialog', async (event, { message, buttons }) => {
  if (!mainWindow) return { response: buttons.length - 1 }; // Cancel·lar per defecte
  console.debug("[IPC_IN] Mostrant diàleg de sortida personalitzat.");

  const result = await dialog.showMessageBox(mainWindow, {
    type: 'question',
    buttons: buttons,
    defaultId: 0,
    cancelId: buttons.length - 1, // L'últim botó sempre és 'Cancel·la'
    title: 'Tancar aplicació', // Títol de la finestra del diàleg
    message: message, // El missatge dinàmic rebut del frontend
  });

  console.debug(`[IPC_OUT] Opció de diàleg seleccionada: ${result.response}`);
  // El frontend ara és responsable de gestionar l'índex directament.
  return { response: result.response };
});

ipcMain.handle('show-save-dialog', async (event, options) => {
  // Afegeix 'isDocumentSave' per a la lògica condicional de backup
  const { title, defaultPath, filters, data, isDocumentSave } = options;
  const focusedWindow = BrowserWindow.getFocusedWindow();
  if (!focusedWindow) {
    return { success: false, message: 'No hi ha cap finestra activa.' };
  }

  const result = await dialog.showSaveDialog(focusedWindow, {
    title,
    defaultPath,
    filters,
    properties: ['showOverwriteConfirmation']
  });

  if (result.canceled || !result.filePath) {
    return { success: false, canceled: true };
  }

  try {
    const buffer = Buffer.from(data);
    fs.writeFileSync(result.filePath, buffer);

    // Només crea un backup si s'està desant un document principal
    if (isDocumentSave) {
      console.info('Desant un document principal. Es crearà una còpia de seguretat.');
      await createBackup(result.filePath);
      await cleanupOldBackups(result.filePath);
    } else {
      console.info('Desant un fitxer exportat (PDF/CSV). No es crearà cap còpia de seguretat.');
    }

    return { success: true, filePath: result.filePath };
  } catch (error) {
    console.error('Error desant el fitxer:', error);
    return { success: false, message: `Error en desar el fitxer: ${error.message}` };
  }
});

ipcMain.handle('google-disconnect', async () => {
  console.info("[IPC_IN] Rebut 'google-disconnect'.");
  try {
    const config = loadGoogleConfigFromFile();

    if (config?.managedAppCalendars?.length > 0 && googleServiceAccountClient) {
      const calendar = google.calendar({ version: 'v3', auth: googleServiceAccountClient });
      console.info(`Eliminant ${config.managedAppCalendars.length} calendaris de l'app de Google...`);
      for (const cal of config.managedAppCalendars) {
        try {
          console.debug(`  -> Eliminant ${cal.name} (${cal.id})`);
          await calendar.calendars.delete({ calendarId: cal.id });
        } catch (err) {
          if (err.code === 404 || err.code === 410) {
            console.warn(`El calendari ${cal.name} (${cal.id}) no s'ha trobat (potser ja estava eliminat).`);
          } else {
            console.error(`Error eliminant el calendari ${cal.name}:`, err.message);
            dialog.showMessageBox(mainWindow, {
              type: 'warning',
              title: 'Avís de Desconnexió',
              message: `No s'ha pogut eliminar el calendari "${cal.name}". Potser hauràs d'esborrar-lo manualment des de Google Calendar.`,
            });
          }
        }
      }
    } else {
      console.debug("No hi ha calendaris gestionats per eliminar, o el client de servei no està disponible.");
    }

    if (googleAuthClient && googleAuthClient.credentials.access_token) {
        await googleAuthClient.revokeCredentials();
        console.info("Tokens de l'usuari revocats correctament.");
    }

    const eliminarFitxer = (filePath, fileName) => {
      if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.info(`Fitxer local eliminat: ${fileName}`);
      }
    };

    eliminarFitxer(GOOGLE_TOKENS_PATH, 'google-tokens.json');
    eliminarFitxer(GOOGLE_CONFIG_PATH, 'google-config.json');

    if (googleAuthClient) {
      googleAuthClient.setCredentials(null);
    }

    return { success: true, message: 'Desconnexió de Google completada.' };
  } catch (err) {
    console.error("Error durant la desconnexió de Google:", err.message);
    return { success: false, message: `S'ha produït un error durant la desconnexió: ${err.message}` };
  }
});

ipcMain.handle('create-new-app-calendar', async (event, suffix) => {
    console.info(`[IPC_IN] Rebut 'create-new-app-calendar' amb sufix: "${suffix}"`);
    if (!googleServiceAccountClient) {
        return { success: false, message: 'El client del compte de servei de Google no està inicialitzat.' };
    }

    const config = loadGoogleConfigFromFile();
    console.debug("Configuració de Google actual carregada:", config);

    if (!config) {
        return { success: false, message: 'El fitxer de configuració de Google no existeix. Si us plau, connecta\'t a Google primer.' };
    }
    if (!config.userEmail) {
        return { success: false, message: 'No s\'ha trobat l\'email de l\'usuari. Si us plau, connecta\'t a Google primer.' };
    }

    const finalSuffix = suffix.trim();
    const finalCalendarName = `${APP_CALENDAR_BASE_NAME}${finalSuffix ? ` - ${finalSuffix}` : ''}`;

    if (config.managedAppCalendars?.some(cal => cal.name === finalCalendarName)) {
        return { success: false, message: `Ja existeix un calendari gestionat amb el nom "${finalCalendarName}".` };
    }

    try {
        const calendar = google.calendar({ version: 'v3', auth: googleServiceAccountClient });
        const newCalendarId = await findOrCreateAppCalendar(calendar, config.userEmail, finalSuffix);

        if (config.managedAppCalendars?.some(cal => cal.id === newCalendarId)) {
            console.warn(`S'ha intentat crear un calendari que ja existeix i està gestionat: ID ${newCalendarId}`);
            return { success: false, message: `El calendari resultant ("${finalCalendarName}") ja existeix i està gestionat per l'aplicació. No es pot afegir un duplicat.` };
        }

        const newCalendarObject = {
            id: newCalendarId,
            name: finalCalendarName,
            suffix: finalSuffix,
        };

        config.managedAppCalendars = [...(config.managedAppCalendars || []), newCalendarObject];
        config.activeAppCalendarId = newCalendarId;

        fs.writeFileSync(GOOGLE_CONFIG_PATH, JSON.stringify(config, null, 2));

        console.info(`Nou calendari de l'app creat i afegit a la configuració:`, newCalendarObject);
        return { success: true, data: { managedAppCalendars: config.managedAppCalendars, activeAppCalendarId: config.activeAppCalendarId } };

    } catch (error) {
        console.error("Error creant el nou calendari de l'app:", error);
        return { success: false, message: `No s'ha pogut crear el calendari: ${error.message}` };
    }
});

ipcMain.handle('get-session-data', async () => {
  return loadSessionData();
});

ipcMain.handle('save-session-data', async (event, { key, value }) => {
  if (!key) {
    console.error('Error: "key" és necessari per a desar dades de sessió.');
    return { success: false, message: 'La clau no pot ser buida.' };
  }
  try {
    await saveSessionData({ [key]: value });
    return { success: true };
  } catch (error) {
    console.error(`Error desant la clau de sessió "${key}":`, error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle('delete-app-calendar', async (event, calendarIdToDelete) => {
  console.info(`[IPC_IN] Rebut 'delete-app-calendar' per a l'ID: ${calendarIdToDelete}`);

  if (!googleServiceAccountClient) {
    return { success: false, message: 'El client del compte de servei de Google no està inicialitzat.' };
  }

  if (!calendarIdToDelete) {
    return { success: false, message: "No s'ha proporcionat cap ID de calendari per eliminar." };
  }

  const config = loadGoogleConfigFromFile();
  if (!config?.managedAppCalendars?.some(c => c.id === calendarIdToDelete)) {
      return { success: false, message: "El calendari no es troba a la llista de calendaris gestionats." };
  }

  try {
    const calendar = google.calendar({ version: 'v3', auth: googleServiceAccountClient });
    console.debug(`Eliminant el calendari de Google: ${calendarIdToDelete}`);
    await calendar.calendars.delete({ calendarId: calendarIdToDelete });
    console.info('Calendari eliminat correctament de Google.');
  } catch (err) {
    if (err.code === 404 || err.code === 410) {
      console.warn(`El calendari ${calendarIdToDelete} no s'ha trobat a Google (potser ja estava eliminat).`);
    } else {
      console.error("Error eliminant el calendari de Google:", err.message, err.response?.data);
      const message = err.code === 403
        ? "No s'ha pogut eliminar el calendari de Google per falta de permisos."
        : "No s'ha pogut eliminar el calendari de Google.";
      return { success: false, message: message };
    }
  }

  config.managedAppCalendars = config.managedAppCalendars.filter(c => c.id !== calendarIdToDelete);

  if (config.activeAppCalendarId === calendarIdToDelete) {
      config.activeAppCalendarId = config.managedAppCalendars.length > 0 ? config.managedAppCalendars[0].id : null;
  }

  if (config.selectedCalendarIds) {
    config.selectedCalendarIds = config.selectedCalendarIds.filter(id => id !== calendarIdToDelete);
  }

  fs.writeFileSync(GOOGLE_CONFIG_PATH, JSON.stringify(config, null, 2));
  console.info('Calendari eliminat de la configuració local.');

  return { success: true, message: 'El calendari ha estat eliminat correctament.', data: { managedAppCalendars: config.managedAppCalendars, activeAppCalendarId: config.activeAppCalendarId } };
});

ipcMain.handle('open-logs-folder', async () => {
  console.info("[IPC_IN] Rebut 'open-logs-folder'.");
  try {
    const logFilePath = log.transports.file.getFile().path;
    const logDirPath = path.dirname(logFilePath);
    await shell.openPath(logDirPath);
    return { success: true };
  } catch (error) {
    console.error('Error obrint la carpeta de logs:', error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle('open-backups-folder', async () => {
  console.info("[IPC_IN] Rebut 'open-backups-folder'.");
  try {
    // Assegurar que el directori existeix abans d'obrir-lo
    if (!fs.existsSync(BACKUP_DIR)) {
      console.debug(`El directori de backups no existeix, creant-lo a: ${BACKUP_DIR}`);
      fs.mkdirSync(BACKUP_DIR, { recursive: true });
    }
    await shell.openPath(BACKUP_DIR);
    return { success: true };
  } catch (error) {
    console.error('Error obrint la carpeta de còpies de seguretat:', error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle('get-app-metadata', async () => {
  return appMetadata;
});

app.whenReady().then(() => {
  console.debug('[Startup] App està llesta, cridant a createWindow...');
  createWindow();
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

ipcMain.on('trigger-menu-action', (event, action) => {
  const focusedWindow = BrowserWindow.getFocusedWindow();

  // Per a accions de la finestra, necessitem una finestra enfocada.
  // Les accions de l'app (com 'quit') o les que depenen de mainWindow poden funcionar igualment.
  if (!focusedWindow && !['quit', 'load-all', 'load-material', 'load-people'].includes(action)) {
    console.warn(`S'ha rebut l'acció de menú "${action}" però no hi ha cap finestra enfocada.`);
    return;
  }

  switch (action) {
    // Accions de càrrega de fitxers (ara gestionades pel renderer)
    case 'load-all':
    case 'load-material':
    case 'load-people':
      // Simplement reenviem l'acció al renderer, que conté la lògica completa.
      if (mainWindow) {
        mainWindow.webContents.send('menu-action', action);
      }
      break;

    // Control de l'aplicació
    case 'quit':
      app.quit();
      break;

    // Controls de la vista (usant la finestra enfocada)
    case 'reload':
      focusedWindow.webContents.reload();
      break;
    case 'forceReload':
      focusedWindow.webContents.reloadIgnoringCache();
      break;
    case 'toggleDevTools':
      focusedWindow.webContents.toggleDevTools();
      break;
    case 'resetZoom':
      focusedWindow.webContents.setZoomLevel(0);
      break;
    case 'zoomIn':
      // Per evitar un zoom excessiu, limitem el nivell
      focusedWindow.webContents.setZoomLevel(focusedWindow.webContents.getZoomLevel() + 0.5);
      break;
    case 'zoomOut':
      focusedWindow.webContents.setZoomLevel(focusedWindow.webContents.getZoomLevel() - 0.5);
      break;
    case 'togglefullscreen':
      focusedWindow.setFullScreen(!focusedWindow.isFullScreen());
      break;

    // Altres accions es redirigeixen al procés de renderització (com abans)
    default:
      if (mainWindow) {
        mainWindow.webContents.send('menu-action', action);
      }
      break;
  }
});
--- END: ../Gestor-Events_i_Personal/main.cjs -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/metadata.json -- branca DEV_pre-monorepoV1.3.0 ---
{
  "name": "Gestor d'Esdeveniments React",
  "description": "Aplicació integral per a la gestió d'esdeveniments, personal i inventari. Permet la planificació d'esdeveniments, l'assignació de personal amb detecció de conflictes, la generació de fitxes tècniques detallades (fitxes de bolo), i el control d'estoc de material amb càlcul de disponibilitat. Inclou visualització en calendari, filtratge avançat i exportació a PDF/CSV.",
  "requestFramePermissions": [],
  "prompt": ""
}
--- END: ../Gestor-Events_i_Personal/metadata.json -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/package.json -- branca DEV_pre-monorepoV1.3.0 ---
{
  "name": "gestor-esdeveniments-personal",
  "productName": "GestorEsdevenimentsPersonal",
  "version": "1.3.0",
  "description": "Una aplicació per gestionar esdeveniments i personal",
  "author": "Pep",
  "license": "GPL-3.0-or-later",
  "main": "main.cjs",
  "type": "module",
  "scripts": {
    "dev": "vite --force --clearScreen false",
    "build:theme": "node scripts/build-theme.cjs",
    "wait": "node -e \"setTimeout(() => process.exit(0), 500)\"",
    "build": "npm run build:theme && tsc && vite build",
    "preview": "vite preview",
    "electron": "wait-on tcp:5173 && cross-env NODE_ENV=development electron .",
    "electron-dev": "concurrently \"npm run dev\" \"npm run electron\"",
    "start": "npm run build:theme && npm run wait && npm run electron-dev",
    "clean": "rm -rf dist node_modules/.vite",
    "fresh-start": "npm run clean && npm start",
    "build:electron": "npm run build && electron-builder",
    "dist": "electron-builder",
    "build:mac": "npm run build && electron-builder --mac --x64 --publish never",
    "build:linux": "npm run build && electron-builder --linux --x64 --publish never",
    "build:win": "npm run build && electron-builder --win --x64 --publish never"
  },
  "dependencies": {
    "@dnd-kit/core": "6.1.0",
    "@dnd-kit/sortable": "8.0.0",
    "@dnd-kit/utilities": "3.2.2",
    "@fullcalendar/core": "6.1.17",
    "@fullcalendar/daygrid": "6.1.17",
    "@fullcalendar/interaction": "6.1.17",
    "@fullcalendar/list": "6.1.17",
    "@fullcalendar/multimonth": "6.1.17",
    "@fullcalendar/react": "6.1.17",
    "@fullcalendar/timegrid": "6.1.17",
    "@heroicons/react": "2.2.0",
    "@types/react-router-dom": "5.3.3",
    "electron-log": "^5.4.3",
    "file-saver": "2.0.5",
    "googleapis": "150.0.1",
    "html2canvas": "1.4.1",
    "immer": "10.1.3",
    "jspdf": "3.0.2",
    "jspdf-autotable": "5.0.2",
    "lucide-react": "0.417.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-hot-toast": "2.6.0",
    "react-router-dom": "7.6.3",
    "use-sync-external-store": "^1.5.0",
    "zundo": "2.3.0",
    "zustand": "5.0.8"
  },
  "devDependencies": {
    "@types/file-saver": "2.0.7",
    "@types/node": "20.14.12",
    "@types/react": "18.3.3",
    "@types/react-dom": "18.3.0",
    "@vitejs/plugin-react": "4.5.0",
    "autoprefixer": "10.4.21",
    "concurrently": "8.2.2",
    "cross-env": "^10.1.0",
    "electron": "38.1.1",
    "electron-builder": "24.13.3",
    "postcss": "8.5.4",
    "tailwindcss": "3.4.17",
    "typescript": "5.5.3",
    "vite": "6.3.6",
    "wait-on": "7.2.0"
  },
  "build": {
    "appId": "com.gestorevents.app",
    "productName": "GestorEsdevenimentsPersonal",
    "directories": {
      "output": "dist"
    },
    "files": [
      "dist/**/*",
      "main.cjs",
      "preload.cjs",
      "metadata.json",
      "google-credentials.json",
      "service-account.json"
    ],
    "extraResources": [
      {
        "from": "examples json",
        "to": "examples json"
      },
      {
        "from": "LICENSE",
        "to": "LICENSE"
      },
      {
        "from": "README.md",
        "to": "README.md"
      },
      {
        "from": "DEVELOPING.md",
        "to": "DEVELOPING.md"
      }
    ],
    "linux": {
      "target": "AppImage",
      "category": "Office",
      "artifactName": "${productName}_v${version}-Linux-Ubuntu18.04+.${ext}"
    },
    "win": {
      "target": [
        "nsis",
        "portable"
      ],
      "icon": "public/icon.ico"
    },
    "mac": {
      "target": [
        "dmg",
        "zip"
      ],
      "category": "public.app-category.productivity",
      "icon": "public/icon.icns",
      "identity": null,
      "artifactName": "${productName}_v${version}-macOS-10.15+.${ext}"
    }
  }
}

--- END: ../Gestor-Events_i_Personal/package.json -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/postcss.config.cjs -- branca DEV_pre-monorepoV1.3.0 ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
--- END: ../Gestor-Events_i_Personal/postcss.config.cjs -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/preload.cjs -- branca DEV_pre-monorepoV1.3.0 ---
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  // Document Management
  openFileDialog: () => ipcRenderer.invoke('open-file-dialog'),
  readFile: (filePath) => ipcRenderer.invoke('read-file', filePath),
  saveFile: (options) => ipcRenderer.invoke('save-file', options),
  showSaveDialog: (options) => ipcRenderer.invoke('show-save-dialog', options),
  showUnsavedChangesDialog: (options) => ipcRenderer.invoke('show-unsaved-changes-dialog', options),

  // Session & App Lifecycle
  onConfirmQuit: (callback) => {
    const subscription = (event, ...args) => callback(...args);
    ipcRenderer.on('confirm-quit-signal', subscription);
    return () => ipcRenderer.removeListener('confirm-quit-signal', subscription);
  },
  quitApplication: () => ipcRenderer.invoke('quit-application'),
  getSessionData: () => ipcRenderer.invoke('get-session-data'),
  saveSessionData: (key, value) => ipcRenderer.invoke('save-session-data', { key, value }),
  getRecentFiles: () => ipcRenderer.invoke('get-recent-files'),
  addRecentFile: (filePath) => ipcRenderer.invoke('add-recent-file', filePath),
  getAppMetadata: () => ipcRenderer.invoke('get-app-metadata'),

  // Google Integration
  loadGoogleConfig: () => ipcRenderer.invoke('load-google-config'),
  startGoogleAuth: () => ipcRenderer.invoke('google-auth-start'),
  onGoogleAuthSuccess: (callback) => {
    const subscription = (event, ...args) => callback(...args);
    ipcRenderer.on('google-auth-success', subscription);
    return () => ipcRenderer.removeListener('google-auth-success', subscription);
  },
  onGoogleAuthError: (callback) => {
    const subscription = (event, ...args) => callback(...args);
    ipcRenderer.on('google-auth-error', subscription);
    return () => ipcRenderer.removeListener('google-auth-error', subscription);
  },
  getCalendarList: () => ipcRenderer.invoke('google-get-calendar-list'),
  saveGoogleConfig: (config) => ipcRenderer.invoke('save-google-config', config),
  getGoogleEvents: () => ipcRenderer.invoke('get-google-events'),
  getEventDetails: (calendarId, eventId) => ipcRenderer.invoke('google-get-event-details', { calendarId, eventId }),
  syncWithGoogle: (payload) => ipcRenderer.invoke('sync-with-google', payload),
  onSyncProgress: (callback) => {
    const subscription = (event, ...args) => callback(...args);
    ipcRenderer.on('sync-progress', subscription);
    return () => ipcRenderer.removeListener('sync-progress', subscription);
  },
  googleDisconnect: () => ipcRenderer.invoke('google-disconnect'),
  deleteAppCalendar: (calendarId) => ipcRenderer.invoke('delete-app-calendar', calendarId),
  createNewAppCalendar: (suffix) => ipcRenderer.invoke('create-new-app-calendar', suffix),

  // Menu and Notifications
  onMenuAction: (callback) => {
    const handler = (event, action) => callback(action);
    ipcRenderer.on('menu-action', handler);
    return () => ipcRenderer.removeListener('menu-action', handler);
  },
  triggerMenuAction: (action) => ipcRenderer.send('trigger-menu-action', action),

  // Misc & Obsolete
  factoryReset: () => ipcRenderer.invoke('factory-reset'),
  loadAppData: () => ipcRenderer.invoke('load-app-data'),
  getPlatformSync: () => process.platform,
  openLogsFolder: () => ipcRenderer.invoke('open-logs-folder'),
  openBackupsFolder: () => ipcRenderer.invoke('open-backups-folder'),
});

// Expose electron-log to the renderer process
const log = require('electron-log');
contextBridge.exposeInMainWorld('electronLog', log.functions);
--- END: ../Gestor-Events_i_Personal/preload.cjs -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/tailwind.config.cjs -- branca DEV_pre-monorepoV1.3.0 ---
const plugin = require('tailwindcss/plugin');

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
    // Escaneja els paquets de FullCalendar per a les classes fc-*
    "./node_modules/@fullcalendar/**/*.js",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))",
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))",
        },
        info: {
          DEFAULT: "hsl(var(--info))",
          foreground: "hsl(var(--info-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      }
    },
  },
  plugins: [
    plugin(function({ addBase }) {
      addBase({
        // --- Estils per als esdeveniments (ARA AMB ESTIL FOSC FIX) ---
        '.event-complete': {
          backgroundColor: 'hsl(var(--calendar-event-bg))',
          borderColor: 'hsl(var(--success))',
          borderWidth: '3px',
          color: 'hsl(var(--calendar-event-fg))',
        },
        '.event-incomplete': {
          backgroundColor: 'hsl(var(--calendar-event-bg))',
          borderColor: 'hsl(var(--warning))',
          borderWidth: '3px',
          color: 'hsl(var(--calendar-event-fg))',
        },

        // --- Estils Generals de FullCalendar (ARA DINÀMICS) ---
        '.fc': {
          '--fc-border-color': 'hsl(var(--border))',
          '--fc-today-bg-color': 'hsla(var(--accent) / 0.5)',
          '--fc-list-event-hover-bg-color': 'hsl(var(--accent))',

          '.fc-button': {
            backgroundColor: 'hsl(var(--secondary))',
            color: 'hsl(var(--secondary-foreground))',
            borderColor: 'hsl(var(--border))',
          },
          '.fc-button:hover': {
            backgroundColor: 'hsl(var(--accent))',
          },
          '.fc-button-primary:not(:disabled).fc-button-active': {
            backgroundColor: 'hsl(var(--primary))',
            color: 'hsl(var(--primary-foreground))',
            borderColor: 'hsl(var(--primary))',
          },
          '.fc-col-header-cell-cushion, .fc-daygrid-day-number, .fc-list-event-title a, .fc-list-table, .fc-list-event td, .fc-multimonth-title, .fc-popover-body': {
            color: 'hsl(var(--muted-foreground))',
            textDecoration: 'none',
          },
          '.fc-col-header, .fc-popover-header': {
            backgroundColor: 'hsl(var(--secondary))',
            color: 'hsl(var(--card-foreground))',
          },
          '.fc-list-day-cushion, .fc-multimonth-month': {
            backgroundColor: 'hsl(var(--muted))',
          },
          '.fc-daygrid-day': {
            backgroundColor: 'hsl(var(--card))',
            overflow: 'visible',
          },
          '.fc-popover': {
            backgroundColor: 'hsl(var(--popover))',
            borderColor: 'hsl(var(--border))',
          },
          '.fc-popover-header': {
              color: 'hsl(var(--popover-foreground))',
          }
        },
        '.fc-day-today .fc-daygrid-day-number': {
          backgroundColor: 'hsl(var(--primary))',
          color: 'hsl(var(--primary-foreground))',
          borderRadius: '9999px',
          width: '24px',
          height: '24px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          padding: '0',
          margin: '2px',
        },
      });
    })
  ],
}
--- END: ../Gestor-Events_i_Personal/tailwind.config.cjs -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/theme.config.cjs -- branca DEV_pre-monorepoV1.3.0 ---
// theme.config.js
// Aquesta és l'única font de veritat per a la paleta de colors de l'aplicació.
// Aquest fitxer és utilitzat per l'script 'scripts/build-theme.js' per generar automàticament:
// 1. Les variables CSS a 'src/index.css' per als temes clar i fosc.
// 2. L'objecte JavaScript a 'src/utils/themeDefinition.ts' per a la generació de PDFs.

const themeConfig = {
  // Colors amb variants per al tema clar i fosc.
  // Els valors són strings HSL "H S% L%".
 

  // NOVA PALETA DE COLORS PER AL TEMA CLAR (Càlid, Fons Foscos, Text Saturat - "Taller d'Artesà")
light: {
  // --- BASE DE FONS CÀLIDA (SENSE CANVIS, MANTENIM "TALLER D'ARTESÀ") ---
  'background':           '35 25% 92%',
  'card':                 '35 15% 85%',
  'popover':              '35 15% 85%',
  'secondary': '35 20% 88%',
  'muted': '35 10% 83%',
  'border':               '35 10% 50%',
  'input':                '35 15% 88%',
  'accent': '220 15% 86%',
  
  // --- TEXTOS AMB BASE GRIS/NEGRE (MÉS FOSCOS I NEUTRES) ---
  'foreground':           '240 10% 10%', // Text principal quasi negre, amb un to fred subtil.
  'card-foreground':      '240 10% 10%',
  'popover-foreground':   '240 10% 10%',
  'secondary-foreground': '240 8% 25%',
  'muted-foreground':     '240 5% 40%',  // Text secundari més fosc per a millor contrast.
  'accent-foreground':    '240 10% 10%',
  'primary-foreground':   '210 40% 98%',

  // --- COLORS D'ACCIÓ HARMONITZATS (SENSE CANVIS) ---
  'primary':              '220 35% 25%',
  'destructive':          '0 75% 55%',
  'success':              '140 65% 40%',
  'warning':              '45 85% 55%',
  'info':                 '210 70% 45%',
  'mixed-status':         '280 40% 55%',
  'ring':                 '220 35% 45%',

  // --- TEXTOS SOBRE COLORS D'ACCIÓ (AJUSTATS A LA NOVA BASE NEUTRA) ---
  'destructive-foreground': '30 100% 98%',
  'success-foreground':   '140 100% 98%',
  'warning-foreground':   '240 10% 10%', // Text principal fosc per a màxima llegibilitat sobre groc.
  'info-foreground':      '210 100% 98%',
  'mixed-status-foreground':'280 100% 98%',
},
  
  dark: {
    // --- BASE DE GRISOS CÀLIDS FOSCOS UNIFICADA ---
    'background':           '40 6% 10%', // Color de fons principal de l'aplicació en mode fosc.
    'card':                 '40 6% 15%', // Color de fons per a "targetes" en mode fosc.
    'popover':              '40 6% 15%', // Color de fons per a "popovers" en mode fosc.
    'border':               '40 6% 50%', // Color per a les vores en mode fosc.
    'input':                '40 6% 21%', // Color de fons per als camps d'entrada en mode fosc.
    'secondary': '40 6% 20%',
    'muted': '40 4% 17%',
    'accent': '220 10% 22%',
    
    // --- TEXTOS ---
    'foreground':           '40 5% 96%', // Color principal del text en mode fosc.
    'card-foreground':      '40 5% 96%', // Color del text dins de les "targetes" en mode fosc.
    'popover-foreground':   '40 5% 96%', // Color del text dins dels "popovers" en mode fosc.
    'secondary-foreground': '40 5% 96%', // Color del text sobre fons 'secondary' en mode fosc.
    'muted-foreground':     '40 4% 65%', // Color per a textos secundaris o atenuats en mode fosc.
    'accent-foreground':    '40 5% 96%', // Color del text sobre fons 'accent' en mode fosc.
    
    // --- COLORS D'ACCIÓ ---
    'primary':              '221.2 76% 53.3%', // Color principal per a accions en mode fosc.
    'destructive':          '0 68% 50.6%',    // Color per a accions destructives en mode fosc.
    'success':              '142.1 65% 45.3%',// Color per a indicadors d'èxit en mode fosc.
    'warning':              '47.9 88% 55%',   // Color per a advertències en mode fosc.
    'info':                 '215 68% 48%',    // Color per a informació en mode fosc.
    'mixed-status':         '283 65% 50%',    // Color per a estats mixts en mode fosc.
    'ring':                 '221.2 83.2% 53.3%',// Color de l'anell de focus en mode fosc.

    // --- TEXTOS SOBRE COLORS D'ACCIÓ ---
    'primary-foreground':   '220 13% 97%',   // Color del text sobre fons 'primary' en mode fosc.
    'destructive-foreground':'210 20% 98%', // Color del text sobre fons 'destructive' en mode fosc.
    'success-foreground':   '145 60% 98%',   // Color del text sobre fons 'success' en mode fosc.
    'warning-foreground':   '48 95% 98%',   // CANVIAT: Ara és un color clar (groc molt pàl·lid) per a la consistència.
    'info-foreground':      '210 20% 98%',   // Color del text sobre fons 'info' en mode fosc.
    'mixed-status-foreground':'280 60% 98%', // Color del text sobre fons 'mixed-status' en mode fosc.
  },
  pdfExtras: {
    grayMedium: [75, 85, 99],
    graySubtle: [240, 5, 92],
    grayLightest: [240, 5, 98],
    orange: [25, 95, 53],
  },
  pdfMapping: {
    primary: 'light.primary',
    success: 'light.success',
    warning: 'light.warning',
    destructive: 'light.destructive',
    foreground: 'light.foreground',
    foregroundMuted: 'light.muted-foreground',
    foregroundWhite: 'light.primary-foreground',
    grayDark: 'dark.secondary',
    grayBorder: 'light.border',
    grayMuted: 'light.muted',
  }
};

module.exports = { themeConfig };
--- END: ../Gestor-Events_i_Personal/theme.config.cjs -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/tsconfig.json -- branca DEV_pre-monorepoV1.3.0 ---
{
  // Re-eval comment
  "compilerOptions": {
    "target": "ES2020",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "allowJs": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    "paths": {
      "@/*" :  ["./src/*"]
    }
  },
  // LÍNIES AFEGIDES:
  "include": [
    "src",
    "vite.config.ts",
    "tailwind.config.cjs",
    "postcss.config.cjs",
    "main.cjs",
    "preload.cjs"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "chekpoints" // La clau: ignorem explícitament les còpies de seguretat
  ]
}
--- END: ../Gestor-Events_i_Personal/tsconfig.json -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/vite.config.ts -- branca DEV_pre-monorepoV1.3.0 ---
import path from 'path';
import { defineConfig } from 'vite';
import { builtinModules } from 'module';
import { fileURLToPath } from 'url';
import react from '@vitejs/plugin-react';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default defineConfig(() => {
    return {
      plugins: [react()],
      base: './',
      define: {
        'process.env.NODE_ENV': JSON.stringify('development'),
      },
      build: {
        outDir: 'dist',
        emptyOutDir: true,
        sourcemap: true,
        minify: false,
        rollupOptions: {
          external: [
            ...builtinModules,
            'electron'
          ],
        }
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, './src'),
        }
      },
    };
});

--- END: ../Gestor-Events_i_Personal/vite.config.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/App.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import { generateDefaultFileName } from './utils/dateFormat';
import { initializeGoogleAuthListeners } from './stores/googleConfigStore';
import React, { useState, useEffect, useCallback, Suspense, lazy } from 'react';
import { HashRouter, Routes, Route } from 'react-router-dom';
import logger from './utils/logger';
import { THEME_STORAGE_KEY } from './constants';
import Modal from './components/ui/Modal';
import { ShowToastFunction, PersonGroup, MaterialItem } from './types';
import { useModalStore } from './stores/modalStore';
import { useEventDataStore } from './stores/eventDataStore';
import { useStore } from 'zustand';
import ErrorBoundary from './components/ErrorBoundary';
import { Toaster } from 'react-hot-toast';
import { notificationService } from './utils/notificationService';

const MainDisplay = lazy(() => import('./components/MainDisplay'));
const Controls = lazy(() => import('./components/Controls'));
const Navigation = lazy(() => import('./components/Navigation'));
const TechSheetsDisplay = lazy(() => import('./components/TechSheetsDisplay'));
const SyncProgressOverlay = lazy(() => import('./components/ui/SyncProgressOverlay'));
import CustomMenuBar from './components/ui/CustomMenuBar';
import SplashScreen from './components/ui/SplashScreen';
import WelcomeScreen from './components/ui/WelcomeScreen';

const PeopleDisplay = lazy(() => import('./components/PeopleDisplay'));
const MaterialDisplay = lazy(() => import('./components/MaterialDisplay'));

const AboutModal = lazy(() => import('./components/modals/AboutModal'));
const EventFrameFormModal = lazy(() => import('./components/modals/EventFrameFormModal'));
const AssignmentFormModal = lazy(() => import('./components/modals/AssignmentFormModal'));
const AddMaterialFromTechSheetModal = lazy(() => import('./components/modals/AddMaterialFromTechSheetModal'));

const ConfirmDeleteModal = lazy(() => import('./components/modals/ConfirmDeleteModal'));
const ConfirmDuplicateModal = lazy(() => import('./components/modals/ConfirmDuplicateModal'));
const EventFrameDetailsModal = lazy(() => import('./components/modals/EventFrameDetailsModal'));
const GoogleSettingsModal = lazy(() => import('./components/modals/GoogleSettingsModal'));
const MergeOrReplaceModal = lazy(() => import('./components/modals/MergeOrReplaceModal'));
const SelectSyncCalendarModal = lazy(() => import('./components/modals/SelectSyncCalendarModal'));
const CreateCalendarModal = lazy(() => import('./components/modals/CreateCalendarModal'));
const UpdateFromAssignmentsModal = lazy(() => import('./components/modals/UpdateFromAssignmentsModal'));
const ConfirmRepairModal = lazy(() => import('./components/modals/ConfirmRepairModal'));
const HistoryModal = lazy(() => import('./components/modals/HistoryModal'));
const GoogleEventDetailsModal = lazy(() => import('./components/modals/GoogleEventDetailsModal'));


import { useRef } from 'react';

let globalInitialLoadAttempted = false;

const App: React.FC = () => {
  const mainDisplayRef = useRef<{ resize: () => void }>(null);
  // Determina la tecla modificadora de la plataforma de forma síncrona a l'inici.
  // Això evita el parpelleig de la UI que passava amb l'enfocament asíncron anterior.
  const platformModifierKey = window.electronAPI?.getPlatformSync() === 'darwin' ? '⌘' : 'Ctrl';
  
  const [showSplash, setShowSplash] = useState(true);
  const [splashScreenEnabled, setSplashScreenEnabled] = useState(true);
  const [splashConfigLoaded, setSplashConfigLoaded] = useState(false);
  const [theme, setTheme] = useState(() => localStorage.getItem(THEME_STORAGE_KEY) || 'light');
  const [isDocumentOpen, setIsDocumentOpen] = useState<boolean>(false);
  const [currentFilePath, setCurrentFilePath] = useState<string | null>(null);
  const [recentFiles, setRecentFiles] = useState<string[]>([]);
  const [appMetadata, setAppMetadata] = useState<{ name: string; version: string; description: string; } | null>(null);
  const { openModal: openModalFromStore, closeModal } = useModalStore.getState();
  const isOpen = useModalStore(state => state.isOpen);
  const type = useModalStore(state => state.type);
  const data = useModalStore(state => state.data);

  // --- State from Zustand Store (Reactive) ---
  // Subscribe to only the pieces of state that cause re-renders.
  const hasUnsavedChanges = useEventDataStore(state => state.hasUnsavedChanges);

  // Ref to track the latest state of hasUnsavedChanges to avoid stale state in listeners.
  const hasUnsavedChangesRef = useRef(hasUnsavedChanges);
  useEffect(() => {
    hasUnsavedChangesRef.current = hasUnsavedChanges;
  }, [hasUnsavedChanges]);

  const isSyncing = useEventDataStore(state => state.isSyncing);
  const isUpdatingMaterial = useEventDataStore(state => state.isUpdatingMaterial);
  const syncProgress = useEventDataStore(state => state.syncProgress);
  const canUndo = useStore(useEventDataStore.temporal, state => state.pastStates.length > 0);
  const canRedo = useStore(useEventDataStore.temporal, state => state.futureStates.length > 0);

  // --- Actions from Zustand Store (Non-reactive) ---
  // Actions are stable functions, so we can get them once with getState().
  // This avoids re-running useEffects that depend on them.
  const {
    loadData: loadDataFromManager,
    exportData: exportDataFromManager,
    setHasUnsavedChanges,
    getPersonGroupById,
    deleteEventFrame,
    deleteAssignment,
    mergePeopleGroups,
    addMaterialItemsFromFile,
    replacePeopleGroups,
    replaceMaterialItems,
    loadGoogleConfigFromDataFile,
  } = useEventDataStore.getState();

  const showToast: ShowToastFunction = useCallback((message, type = 'success') => {
    switch (type) {
      case 'success':
        notificationService.success(message);
        break;
      case 'error':
        notificationService.error(message);
        break;
      case 'info':
        notificationService.info(message);
        break;
      case 'warning':
        notificationService.warning(message);
        break;
      default:
        notificationService.success(message);
    }
  }, []);

  useEffect(() => {
    // Inicialitza els listeners de la store de Google un sol cop
    initializeGoogleAuthListeners();

    const fetchMetadata = async () => {
      if (window.electronAPI?.getAppMetadata) {
        const metadata = await window.electronAPI.getAppMetadata();
        setAppMetadata(metadata);
      }
    };
    fetchMetadata();
  }, []);

  useEffect(() => {
    const timer = setTimeout(() => setShowSplash(false), 3500);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    const { undoWithToast, redoWithToast } = useEventDataStore.getState();
    const handleKeyDown = (event: KeyboardEvent) => {
        const target = event.target as HTMLElement;
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
            return;
        }
        if (event.ctrlKey || event.metaKey) {
            if (event.key.toLowerCase() === 'z' && !event.shiftKey) {
                event.preventDefault();
                undoWithToast();
            } else if (event.key.toLowerCase() === 'y' || (event.shiftKey && event.key.toLowerCase() === 'z')) {
                event.preventDefault();
                redoWithToast();
            }
        }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  logger.info('App.tsx - Component renderitzat.');

  const [isLoadingOverlayVisible, setIsLoadingOverlayVisible] = useState(false);
  const [loadingOverlayMessage, setLoadingOverlayMessage] = useState('');

  useEffect(() => {
    if (isSyncing && !syncProgress.visible) {
      setLoadingOverlayMessage('Sincronitzant amb Google Calendar...');
      setIsLoadingOverlayVisible(true);
    } else if (!isSyncing && !syncProgress.visible) {
      setIsLoadingOverlayVisible(false);
      setLoadingOverlayMessage('');
    }
  }, [isSyncing, syncProgress.visible]);


  useEffect(() => {
    const body = document.body;
    if (isOpen) {
      body.style.overflow = 'hidden';
    } else {
      body.style.overflow = 'auto';
    }
    return () => {
      body.style.overflow = 'auto';
    };
  }, [isOpen]);
  
  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  useEffect(() => {
    const root = window.document.documentElement;
    if (theme === 'dark') {
      root.classList.add('dark');
    } else {
      root.classList.remove('dark');
    }
    localStorage.setItem(THEME_STORAGE_KEY, theme);
  }, [theme]);

  // --- Document Management ---

  const handleSaveAsDocument = async (): Promise<boolean> => {
    if (!window.electronAPI) {
      showToast('Aquesta funció només està disponible a l\'aplicació d\'escriptori.', 'warning');
      return false;
    }
    try {
        const dataToSave = await exportDataFromManager();
        const jsonString = JSON.stringify(dataToSave, null, 2);
        const fileName = currentFilePath ? currentFilePath.split(/[/\\]/).pop() : 'document.json';

        const result = await window.electronAPI.showSaveDialog({
            title: 'Guardar com...',
            defaultPath: fileName || 'document.json',
            filters: [{ name: 'JSON', extensions: ['json'] }],
            data: jsonString,
            isDocumentSave: true, // Indica al backend que això és un desat de document principal
        });

        if (result.success && result.filePath) {
            setHasUnsavedChanges(false);
            setCurrentFilePath(result.filePath);
            const recentFilesResult = await window.electronAPI.addRecentFile(result.filePath);
            if(recentFilesResult.success) {
                setRecentFiles(recentFilesResult.recentFiles);
            }
            showToast('Document desat correctament.', 'success');
            return true;
        } else if (!result.canceled) {
            showToast(`Error en desar: ${result.message}`, 'error');
        }
    } catch (error) {
        showToast(`Error en desar: ${(error as Error).message}`, 'error');
    }
    return false;
};

const handleSaveDocument = async (): Promise<boolean> => {
    if (!currentFilePath) {
        return handleSaveAsDocument();
    }
    if (!window.electronAPI) {
      showToast('Aquesta funció només està disponible a l\'aplicació d\'escriptori.', 'warning');
      return false;
    }
    try {
        const dataToSave = await exportDataFromManager();
        const jsonString = JSON.stringify(dataToSave, null, 2);
        const result = await window.electronAPI.saveFile({
            filePath: currentFilePath,
            data: jsonString,
        });

        if (result.success) {
            setHasUnsavedChanges(false);
            showToast('Document desat.', 'success');
            return true;
        } else {
            showToast(`Error en desar: ${result.message}`, 'error');
        }
    } catch (error) {
        showToast(`Error en desar: ${(error as Error).message}`, 'error');
    }
    return false;
};

  const confirmContinueWithUnsavedChanges = async (): Promise<boolean> => {
    if (!hasUnsavedChangesRef.current) {
        return true; // No unsaved changes, can continue
    }

    if (window.electronAPI?.showUnsavedChangesDialog) {
        const message = 'Teniu canvis sense desar. Voleu desar-los abans de continuar?';
        const buttons = ['Desa', 'No desis', 'Cancel·la'];

        const { response } = await window.electronAPI.showUnsavedChangesDialog({ message, buttons });
        // 0: Desa, 1: No desis, 2: Cancel·la
        switch (response) {
            case 0: // Desa
                const saved = await handleSaveDocument();
                return saved;
            case 1: // No desis
                return true;
            case 2: // Cancel·la
            default:
                return false;
        }
    }
    // Fallback for web or if API is not available
    return confirm('You have unsaved changes. Are you sure you want to continue?');
  };

  const handleNewDocument = async () => {
      const canContinue = await confirmContinueWithUnsavedChanges();
      if (!canContinue) return;

      loadDataFromManager(null);
      setCurrentFilePath(null);
      setIsDocumentOpen(true);
      setHasUnsavedChanges(false);
      showToast('Nou espai de treball creat.', 'success');
  };

  const handleOpenDocument = async (filePathToOpen?: string) => {
    const canContinue = await confirmContinueWithUnsavedChanges();
    if (!canContinue) return;

    let filePath = filePathToOpen;
    if (!filePath && window.electronAPI) {
        const dialogResult = await window.electronAPI.openFileDialog();
        if (!dialogResult.success || !dialogResult.filePath) {
            return; // User cancelled or error
        }
        filePath = dialogResult.filePath;
    }

    if (!filePath) {
        showToast('Aquesta funció només està disponible a l\'aplicació d\'escriptori.', 'warning');
        return;
    }

    try {
        if (window.electronAPI) {
            const fileReadResult = await window.electronAPI.readFile(filePath);
            if (!fileReadResult.success || typeof fileReadResult.content !== 'string') {
                showToast(`Error en llegir el fitxer: ${fileReadResult.message}`, 'error');
                return;
            }


            const data = JSON.parse(fileReadResult.content);
            const loadResult = await loadDataFromManager(data);

            if (loadResult.status === 'error') {
                showToast(loadResult.message || 'Hi ha hagut un error en carregar les dades.', 'error');
                return;
            }

            if (data.googleConfig) {
                logger.info("Trobada configuració de Google al fitxer, restaurant-la...");
                await loadGoogleConfigFromDataFile(data);
            }

            setCurrentFilePath(filePath);
            setIsDocumentOpen(true);
            const recentFilesResult = await window.electronAPI.addRecentFile(filePath);
            if(recentFilesResult.success) {
                setRecentFiles(recentFilesResult.recentFiles);
            }

            const fileName = filePath.split(/[/\\]/).pop() || filePath;
            showToast(`Document "${fileName}" carregat.`, 'success');
        }
    } catch (error) {
        showToast(`Error en processar el fitxer: ${(error as Error).message}`, 'error');
    }
  };

  const handleOpenRecent = (filePath: string) => {
    handleOpenDocument(filePath);
  };

  const handleExportData = async (type: 'people' | 'material') => {
    try {
      let dataToSave: any;
      let filename: string;
      const fullData = await exportDataFromManager();

      switch (type) {
        case 'people':
          dataToSave = { peopleGroups: fullData.peopleGroups };
          filename = 'persones_grups_dades.json';
          break;
        case 'material':
          dataToSave = { materialItems: fullData.materialItems };
          filename = 'material_dades.json';
          break;
      }
      const jsonString = JSON.stringify(dataToSave, null, 2);

      if (window.electronAPI?.showSaveDialog) {
        const result = await window.electronAPI.showSaveDialog({
          title: `Exportar ${type} a JSON`,
          defaultPath: filename,
          filters: [{ name: 'JSON', extensions: ['json'] }],
          data: jsonString,
          isDocumentSave: false, // Indica al backend que això NO és un desat de document
        });
        if (result.success) {
          showToast(`Dades de ${type} exportades correctament.`, 'success');
        } else if (!result.canceled) {
          showToast(`Error en exportar les dades: ${result.message}`, 'error');
        }
      }
    } catch (error) {
      showToast(`Error en exportar les dades: ${(error as Error).message}`, 'error');
    }
  };

  const handleImportPeople = async () => {
    if (!window.electronAPI) {
      showToast('Aquesta funció només està disponible a l\'aplicació d\'escriptori.', 'warning');
      return;
    }
    const dialogResult = await window.electronAPI.openFileDialog();
    if (!dialogResult.success || !dialogResult.filePath) return;

    const fileReadResult = await window.electronAPI.readFile(dialogResult.filePath);
    if (!fileReadResult.success || typeof fileReadResult.content !== 'string') {
        showToast(`Error en llegir el fitxer: ${fileReadResult.message}`, 'error');
        return;
    }

    try {
        const jsonData = JSON.parse(fileReadResult.content);
        let newPeople: PersonGroup[] = [];
        if (Array.isArray(jsonData.peopleGroups)) {
            newPeople = jsonData.peopleGroups;
        } else {
            showToast("Error: El format del fitxer JSON de persones no és vàlid.", 'error');
            return;
        }
        openModalFromStore('mergeOrReplace', { itemType: 'persones', newData: newPeople });
    } catch (error) {
        showToast(`Error en processar el fitxer de persones: ${(error as Error).message}`, 'error');
    }
  };

  const handleImportMaterial = async () => {
    if (!window.electronAPI) {
      showToast('Aquesta funció només està disponible a l\'aplicació d\'escriptori.', 'warning');
      return;
    }
    const dialogResult = await window.electronAPI.openFileDialog();
    if (!dialogResult.success || !dialogResult.filePath) return;

    const fileReadResult = await window.electronAPI.readFile(dialogResult.filePath);
    if (!fileReadResult.success || typeof fileReadResult.content !== 'string') {
        showToast(`Error en llegir el fitxer: ${fileReadResult.message}`, 'error');
        return;
    }

    try {
      const jsonData = JSON.parse(fileReadResult.content);
      if (Array.isArray(jsonData.materialItems)) {
        openModalFromStore('mergeOrReplace', {
          itemType: 'material',
          newData: jsonData.materialItems,
        });
      } else {
        showToast("Error: El fitxer JSON de material ha de contenir un array anomenat 'materialItems'.", 'error');
      }
    } catch (error) {
      showToast(`Error en processar el fitxer de material: ${(error as Error).message}`, 'error');
    }
  };

  const handleFactoryReset = () => {
    openModalFromStore('confirmHardReset', {
      titleOverride: "Restaurar Configuració de Fàbrica",
      itemName: "Estàs segur que vols restaurar la configuració de fàbrica? Aquesta acció esborrarà la teva connexió amb Google i la llista de fitxers recents. Els teus documents desats no seran afectats. Aquesta acció és irreversible.",
      confirmButtonText: "Sí, Restaurar",
      cancelButtonText: "Cancel·lar",
      onConfirmSpecial: async () => {
        if (window.electronAPI?.factoryReset) {
          try {
            const result = await window.electronAPI.factoryReset();
              if (result.success) {
                showToast("Configuració restaurada. L'aplicació es reiniciarà.", 'success');
                setTimeout(() => window.location.reload(), 2000);
              } else {
                showToast(result.message || "Error durant la restauració.", 'error');
              }
          } catch (error) {
            showToast(`Error greu durant la restauració: ${(error as Error).message}`, 'error');
          }
        } else {
          showToast("La funcionalitat de restauració no està disponible.", 'error');
        }
      },
    });
  };

  const handleConnectGoogle = async () => {
    if (window.electronAPI) {
      const result = await window.electronAPI.startGoogleAuth();
      if (result.success) {
        showToast('Obrint el navegador per autenticar-se amb Google...', 'info');
      } else {
        showToast(result.message || 'No s\'ha pogut iniciar l\'autenticació.', 'error');
      }
    } else {
      showToast('Aquesta funcionalitat només està disponible a l\'aplicació d\'escriptori.', 'warning');
    }
  };

  useEffect(() => {
    const initializeApp = async () => {
        logger.info('[Startup] App.tsx: Iniciant la càrrega de la sessió.');
        if (window.electronAPI) {
            if (window.electronAPI.getRecentFiles) {
                const files = await window.electronAPI.getRecentFiles();
                setRecentFiles(files);
                logger.info('[Startup] Fitxers recents carregats:', files);
            }
            if (window.electronAPI.getSessionData) {
                const sessionData = await window.electronAPI.getSessionData();
                setSplashScreenEnabled(sessionData.splashScreenEnabled !== false);
                logger.info('[Startup] Configuració del splash screen carregada.');
            }
        }
        setSplashConfigLoaded(true);
        globalInitialLoadAttempted = true;
        logger.info('[Startup] App.tsx: Marcat initialLoadAttempted com a true.');
    };

    if (!globalInitialLoadAttempted) {
        logger.info('[Startup] App.tsx: Primer render, cridant a initializeApp.');
        initializeApp();
    }
  }, []);

  // Lògica de sortida refactoritzada per eliminar el backup de sessió.
  // El tancament ara és gestionat per un IPC handler simple que no crea backups.
  const quitLogicRef = useRef<() => Promise<void>>();
  useEffect(() => {
    quitLogicRef.current = async () => {
      logger.info("[Exit Flow] Executant la lògica de sortida refactoritzada.");

      const quitApp = () => {
        if (window.electronAPI?.quitApplication) {
          window.electronAPI.quitApplication();
        }
      };

      if (hasUnsavedChangesRef.current) {
        // Cas 1: Hi ha canvis no desats
        if (window.electronAPI?.showUnsavedChangesDialog) {
          const fileName = currentFilePath
            ? currentFilePath.split(/[/\\]/).pop()
            : generateDefaultFileName();

          const message = `Vols desar els canvis fets a '${fileName}'?`;
          const buttons = ['Desa', 'Tanca sense desar', 'Cancel·la'];
          const { response } = await window.electronAPI.showUnsavedChangesDialog({ message, buttons });

          switch (response) {
            case 0: // Desa
              if (await handleSaveDocument()) {
                quitApp();
              } else {
                showToast("El desat ha fallat o ha estat cancel·lat. La sortida s'ha avortat.", "warning");
              }
              break;
            case 1: // Tanca sense desar
              quitApp();
              break;
            case 2: // Cancel·la
            default:
              logger.info("Sortida cancel·lada per l'usuari.");
              break;
          }
        }
      } else {
        // Cas 2: No hi ha canvis, però igualment es demana confirmació
        if (window.electronAPI?.showUnsavedChangesDialog) {
          const { response } = await window.electronAPI.showUnsavedChangesDialog({
            message: 'Estàs segur que vols sortir de l\'aplicació?',
            buttons: ['Sortir', 'Cancel·lar'],
          });
          if (response === 0) { // 0: Sortir
            quitApp();
          } else {
            logger.info("Sortida cancel·lada per l'usuari.");
          }
        }
      }
    };
  });

  // El listener de 'confirm-quit' es registra un sol cop, garantint que no hi ha múltiples listeners.
  // Crida a la versió més recent de la lògica de sortida a través de la ref.
  useEffect(() => {
    if (window.electronAPI?.onConfirmQuit) {
      const cleanup = window.electronAPI.onConfirmQuit(() => {
        quitLogicRef.current?.();
      });

      // Neteja el listener quan el component es desmunta, per higiene.
      return cleanup;
    }
  }, []);

  useEffect(() => {
    logger.info('[Startup] App.tsx: Configurant listeners per a l\'autenticació de Google.');
    if (window.electronAPI?.onGoogleAuthSuccess && window.electronAPI?.onGoogleAuthError) {
      const onSuccess = () => showToast('Connectat a Google Calendar amb èxit!', 'success');
      const onError = (message: string) => showToast(`Error d'autenticació: ${message}`, 'error');

      const cleanupSuccess = window.electronAPI.onGoogleAuthSuccess(onSuccess);
      const cleanupError = window.electronAPI.onGoogleAuthError(onError);

      return () => {
        logger.info('[Cleanup] App.tsx: Netejant listeners d\'autenticació de Google.');
        cleanupSuccess();
        cleanupError();
      };
    }
  }, [showToast]);

  // Listener per al progrés de sincronització
  useEffect(() => {
    if (window.electronAPI?.onSyncProgress) {
      const { setSyncProgress } = useEventDataStore.getState();
      const cleanup = window.electronAPI.onSyncProgress((progress) => {
        setSyncProgress({ ...progress, visible: true });
      });
      return cleanup;
    }
  }, []);

  // Listeners per a notificacions del backend
  useEffect(() => {
    if (window.electronAPI) {
      const cleanupFunctions: (() => void)[] = [];

      // Listener per a l'aplicació que es reiniciarà després del reset
      if (window.electronAPI.onAppWillRelaunchAfterReset) {
        const cleanup = window.electronAPI.onAppWillRelaunchAfterReset(() => {
          showToast('L\'aplicació es reiniciarà després del reset...', 'info');
        });
        cleanupFunctions.push(cleanup);
      }

      // Listener per a errors de sincronització
      if (window.electronAPI.onSyncError) {
        const cleanup = window.electronAPI.onSyncError((error: string) => {
          showToast(`Error de sincronització: ${error}`, 'error');
        });
        cleanupFunctions.push(cleanup);
      }

      // Listener per a èxits de sincronització
      if (window.electronAPI.onSyncSuccess) {
        const cleanup = window.electronAPI.onSyncSuccess((message: string) => {
          showToast(message || 'Sincronització completada', 'success');
        });
        cleanupFunctions.push(cleanup);
      }

      // Listener per a notificacions generals del backend
      if (window.electronAPI.onBackendNotification) {
        const cleanup = window.electronAPI.onBackendNotification((notification: { message: string; type: 'success' | 'error' | 'info' | 'warning' }) => {
          showToast(notification.message, notification.type);
        });
        cleanupFunctions.push(cleanup);
      }

      return () => {
        cleanupFunctions.forEach(cleanup => cleanup());
      };
    }
  }, [showToast]);

  // Obsolete functions for file handling have been removed.
  // The new logic is in handleOpenDocument, handleSaveDocument, etc.

  useEffect(() => {
    logger.info('[Startup] App.tsx: Configurant listener per a les accions del menú.');
    const { undoWithToast, redoWithToast } = useEventDataStore.getState();

    if (window.electronAPI) {
      const cleanup = window.electronAPI.onMenuAction((action) => {
        logger.info(`[Menu] Acció rebuda: ${action}`);

        if (action.startsWith('open-recent:')) {
            const filePath = action.substring('open-recent:'.length);
            handleOpenDocument(filePath);
            return;
        }

        switch (action) {
          case 'undo':
            undoWithToast();
            break;
          case 'redo':
            redoWithToast();
            break;
          case 'new-document':
            handleNewDocument();
            break;
          case 'open-document':
            handleOpenDocument();
            break;
          case 'save-document':
            handleSaveDocument();
            break;
          case 'save-as-document':
            handleSaveAsDocument();
            break;
          case 'import-people':
            handleImportPeople();
            break;
          case 'export-people':
            handleExportData('people');
            break;
          case 'import-material':
            handleImportMaterial();
            break;
          case 'export-material':
            handleExportData('material');
            break;
          case 'factory-reset':
            handleFactoryReset();
            break;
          case 'sync-google':
            useEventDataStore.getState().syncWithGoogle();
            break;
          case 'config-google':
            openModalFromStore('googleSettings');
            break;
          case 'connect-google':
            handleConnectGoogle();
            break;
          case 'toggle-theme':
            toggleTheme();
            break;
          case 'open-logs-folder':
            window.electronAPI?.openLogsFolder();
            break;
          case 'open-backups-folder':
            window.electronAPI?.openBackupsFolder();
            break;
          case 'open-about-modal':
            openModalFromStore('about');
            break;
          default:
            break;
        }
      });

      return cleanup;
    }
  }, [
    openModalFromStore,
    closeModal,
    canUndo,
    canRedo,
    hasUnsavedChanges,
    currentFilePath, // Added to deps
    isDocumentOpen,  // Added to deps
    recentFiles      // Added to deps
  ]);


  const renderModalContent = () => {
    if (!type) return null;
    switch (type) {
      case 'addEventFrame':
        return <EventFrameFormModal onClose={closeModal} showToast={showToast} />;
      case 'editEventFrame':
        return <EventFrameFormModal onClose={closeModal} showToast={showToast} />;
      case 'addAssignment':
        return <AssignmentFormModal onClose={closeModal} showToast={showToast} />;
      case 'editAssignment':
        return <AssignmentFormModal onClose={closeModal} showToast={showToast} />;
      case 'addMaterialFromTechSheet':
        return <AddMaterialFromTechSheetModal />;
      
      case 'eventFrameDetails':
        return <EventFrameDetailsModal onClose={closeModal} eventFrame={data!.eventFrame!} showToast={showToast} />;
      case 'confirmHardReset':
        return <ConfirmDeleteModal
                  onClose={closeModal}
                  itemType={data!.itemType!}
                  itemName={data!.itemName!}
                  onConfirm={data!.onConfirmSpecial!}
                  showToast={showToast}
                  titleOverride={data!.titleOverride}
                  confirmButtonText={data!.confirmButtonText}
                  cancelButtonText={data!.cancelButtonText}
                  requiresInput={data!.requiresInput}
                  suppressSuccessToast={data?.titleOverride?.includes('Google') || data?.titleOverride?.includes('Calendari')}
                />;
      case 'confirmDataRepair':
          return <ConfirmRepairModal
                    isOpen={true}
                    onClose={data!.onCancel!}
                    onConfirm={data!.onConfirm!}
                    fixes={data!.fixes!}
                  />;
      case 'confirmDeleteEventFrame':
        return <ConfirmDeleteModal
                  onClose={closeModal}
                  itemType="Marc d'Esdeveniment"
                  itemName={data!.itemName!}
                  onConfirm={() => {
                    if (data?.itemId) deleteEventFrame(data.itemId);
                  }}
                  showToast={showToast}
                />;

      case 'confirmDelete':
        return <ConfirmDeleteModal
                  onClose={closeModal}
                  itemType={data!.itemType!}
                  itemName={data!.itemName!}
                  onConfirm={data!.onConfirm!}
                  showToast={showToast}
                />;
                
      case 'confirmDeleteAssignment':
        return <ConfirmDeleteModal
                  onClose={closeModal}
                  itemType="Assignació"
                  itemName={data!.itemName!}
                  onConfirm={() => {
                    if (data?.eventFrameId && data?.assignmentId) deleteAssignment(data.eventFrameId, data.assignmentId);
                  }}
                  showToast={showToast}
                />;
      
      case 'googleSettings':
        return <GoogleSettingsModal onClose={closeModal} showToast={showToast} />;
      case 'createAppCalendar':
        return <CreateCalendarModal onClose={closeModal} showToast={showToast} />;
      case 'selectSyncCalendar':
        return <SelectSyncCalendarModal
                  onClose={closeModal}
                  onConfirm={data!.onConfirmSync!}
                  managedCalendars={data!.managedCalendars!}
                  activeCalendarId={data!.activeCalendarId!}
                />;
      case 'mergeOrReplace':
        return (
          <MergeOrReplaceModal
            isOpen={true}
            onClose={closeModal}
            itemType={data!.itemType!}
            onMerge={() => {
              let result;
              if (data?.itemType === 'persones' && data.newData) {
                result = mergePeopleGroups(data.newData as PersonGroup[]);
              } else if (data?.itemType === 'material' && data.newData) {
                result = addMaterialItemsFromFile(data.newData as MaterialItem[]);
              }
              if (result) {
                showToast(result.message, result.type);
              }
              closeModal();
            }}
            onReplace={() => {
              if (data?.itemType === 'persones' && data.newData) {
                replacePeopleGroups(data.newData as PersonGroup[]);
                showToast('Llista de persones reemplaçada.', 'success');
              } else if (data?.itemType === 'material' && data.newData) {
                replaceMaterialItems(data.newData as MaterialItem[]);
                showToast('Inventari de material reemplaçat.', 'success');
              }
              closeModal();
            }}
          />
        );
      case 'updateFromAssignments':
        return <UpdateFromAssignmentsModal
                  onClose={closeModal}
                  onConfirm={data!.onConfirm!}
                  toAdd={data!.toAdd || []}
                  toRemove={data!.toRemove || []}
                  toUpdate={data!.toUpdate || []}
                  getPersonGroupById={getPersonGroupById}
                />;
      case 'confirmDuplicate':
        return <ConfirmDuplicateModal
                  onClose={closeModal}
                  onConfirm={() => {
                    if (data?.onConfirm) {
                      (data.onConfirm as () => void)();
                    }
                    closeModal();
                  }}
                  message={data?.message || ''}
                />;
      case 'history':
        return <HistoryModal />;
      case 'googleEventDetails':
        return <GoogleEventDetailsModal />;
      case 'about':
        return appMetadata ? (
          <AboutModal
            name={appMetadata.name}
            version={appMetadata.version}
            description={appMetadata.description}
            onClose={closeModal}
          />
        ) : null;
      default:
        return null;
    }
  };

  const getModalTitle = (): string => {
    if (!type) return '';
    if (type === 'confirmDeleteEventFrame' && data?.titleOverride) {
        return data.titleOverride;
    }
    switch (type) {
      case 'googleEventDetails': return "Detalls de l'Esdeveniment de Google";
      case 'addEventFrame': return "Afegir Nou Marc d'Esdeveniment";
      case 'editEventFrame': return "Editar Marc d'Esdeveniment";
      case 'addAssignment': return `Nova Assignació per a: ${data?.eventFrame?.name || ''}`;
      case 'editAssignment': return `Editar Assignació per a: ${data?.eventFrame?.name || ''}`;
      case 'addMaterialFromTechSheet': return "Afegir Material a l'Inventari";
      case 'selectSyncCalendar': return "Seleccionar Calendari per Sincronitzar";
      case 'createAppCalendar': return "Crear Nou Calendari de l'App";
      case 'confirmDuplicate': return "Conflicte d'Assignació Detectat";
      case 'confirmDataRepair': return "Reparació de Dades";
      
      case 'eventFrameDetails': return `Detalls de: ${data?.eventFrame?.name || ''}`;
      case 'confirmHardReset':
      case 'confirmDeleteEventFrame':
      case 'confirmDeleteAssignment':
      case 'confirmDelete':
        return "Confirmar Eliminació";
      case 'updateFromAssignments': return "Actualitzar Personal des d'Assignacions";
      case 'about': return `Sobre ${appMetadata?.name || 'l\'Aplicació'}`;
      default: return "Diàleg";
    }
  };

  const getModalSize = (): 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl' | '4xl' | '5xl' | '6xl' | '7xl' => {
    if (!type) return 'xl';
    switch (type) {
      case 'addEventFrame':
      case 'editEventFrame':
      case 'addAssignment':
      case 'editAssignment':
      case 'eventFrameDetails':
        return '4xl';
      case 'googleEventDetails':
        return '2xl';
      case 'confirmDeleteEventFrame':
      case 'confirmDeleteAssignment':
      case 'confirmHardReset':
      case 'confirmDataRepair':
        return 'xl';
      case 'googleSettings':
        return '2xl';
      case 'selectSyncCalendar':
      case 'createAppCalendar':
          return 'xl';
      case 'mergeOrReplace':
        return 'lg';
      default: return 'xl';
    }
  }

  const handleToggleSplashScreen = async () => {
    const newValue = !splashScreenEnabled;
    setSplashScreenEnabled(newValue);
    if (window.electronAPI?.saveSessionData) {
      await window.electronAPI.saveSessionData('splashScreenEnabled', newValue);
    }
  };

  return (
      <HashRouter>
        <ErrorBoundary>
          <div className="h-screen overflow-hidden flex flex-col bg-background text-foreground">
            {splashConfigLoaded && splashScreenEnabled && showSplash && <SplashScreen />}
            <header className="sticky top-0 z-40 bg-background/80 backdrop-blur-sm border border-border">
            <CustomMenuBar
              modifierKey={platformModifierKey}
              canUndo={canUndo}
              canRedo={canRedo}
              splashScreenEnabled={splashScreenEnabled}
              onToggleSplashScreen={handleToggleSplashScreen}
              isDocumentOpen={isDocumentOpen}
              hasUnsavedChanges={hasUnsavedChanges}
              recentFiles={recentFiles}
              theme={theme}
              onToggleTheme={toggleTheme}
              onUndo={() => useEventDataStore.getState().undoWithToast()}
              onRedo={() => useEventDataStore.getState().redoWithToast()}
              onOpenHistory={() => openModalFromStore('history')}
            />
            <div className="px-1 py-1 border-t border-border">
              <Suspense fallback={<div className="text-center p-4">Carregant controls...</div>}>
                <Controls
                  theme={theme}
                  toggleTheme={toggleTheme}
                  currentFilePath={currentFilePath}
                />
              </Suspense>
              <Suspense fallback={<div className="text-center p-2">Carregant navegació...</div>}>
                <Navigation />
              </Suspense>
            </div>
          </header>

          <main className="flex-grow px-1 pt-2 overflow-y-auto">
            {!isDocumentOpen ? (
              <WelcomeScreen
                recentFiles={recentFiles}
                onNewDocument={handleNewDocument}
                onOpenDocument={() => handleOpenDocument()}
                onOpenRecent={handleOpenRecent}
              />
            ) : (
              <Suspense fallback={<div className="text-center p-8">Carregant vista...</div>}>
                <Routes>
                  <Route
                    path="/"
                    element={
                      <MainDisplay
                        ref={mainDisplayRef}
                        setToastMessage={showToast}
                      />
                    }
                  />
                  <Route path="/tech-sheets" element={<TechSheetsDisplay showToast={showToast} />} />
                  <Route path="/people" element={<PeopleDisplay showToast={showToast} />} />
                  <Route path="/material" element={<MaterialDisplay showToast={showToast} />} />
                </Routes>
              </Suspense>
            )}
          </main>


          <footer className="bg-secondary p-4 text-center text-sm text-muted-foreground border-t border-border">
            <span>© {new Date().getFullYear()} (Pëp) Gestor de Esdeveniments i Personal V1.3.0. Llicència GNU GPL v3.0. </span>
            <span>Si vols col·laborar, pots fer-ho al <a href="https://github.com/Pepelocotango/Gestor-Events_i_Personal" target="_blank" rel="noopener noreferrer" className="underline">projecte de GitHub</a> o amb una aportació a <a href="https://paypal.me/RosePep" target="_blank" rel="noopener noreferrer" className="underline">PayPal</a>.</span>
          </footer>

          <Modal
            isOpen={isOpen}
            onClose={closeModal}
            title={getModalTitle()}
            size={getModalSize()}
          >
            <Suspense fallback={<div className="p-8 text-center">Carregant...</div>}>
              {renderModalContent()}
            </Suspense>
          </Modal>

          <Toaster
            position="top-right"
            toastOptions={{
              className: 'bg-popover text-popover-foreground border-border border p-4 rounded-lg shadow-lg',
              duration: 4000,
              success: {
                duration: 3000,
                className: 'bg-success text-success-foreground border-border border p-4 rounded-lg shadow-lg',
              },
              error: {
                duration: 5000,
                className: 'bg-destructive text-destructive-foreground border-border border p-4 rounded-lg shadow-lg',
              },
            }}
          />

          <Suspense fallback={<div></div>}>
            <SyncProgressOverlay progress={syncProgress} />
          </Suspense>

          {isLoadingOverlayVisible && !syncProgress.visible && (
            <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex flex-col justify-center items-center z-[9998]" aria-live="assertive" role="alert">
              <svg className="animate-spin h-10 w-10 text-foreground mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <p className="text-foreground text-lg">{loadingOverlayMessage || "Processant..."}</p>
            </div>
          )}
          {isUpdatingMaterial && (
            <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex flex-col justify-center items-center z-[9999]" aria-live="assertive" role="alert">
              <svg className="animate-spin h-10 w-10 text-foreground mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <p className="text-foreground text-lg">Actualitzant material a tota l'aplicació...</p>
            </div>
          )}
          </div>
        </ErrorBoundary>
      </HashRouter>
  );
};

export default App;
--- END: ../Gestor-Events_i_Personal/src/App.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/calendar-styles.d.ts -- branca DEV_pre-monorepoV1.3.0 ---
declare module '*.css';
--- END: ../Gestor-Events_i_Personal/src/calendar-styles.d.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/AssignmentCard.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useRef, useMemo } from 'react';
import { useEventDataStore } from '../stores/eventDataStore';
import { EventFrame, Assignment, AssignmentStatus } from '../types';
import { EditIcon, TrashIcon } from '../constants';
import { formatDateDMY, formatDateRangeDMY } from '../utils/dateFormat';
import { getStatusSummaryText } from '../utils/statusUtils';
import Tooltip from './ui/Tooltip';

const getDaysInRange = (startDateStr: string, endDateStr: string): string[] => {
  const dates: string[] = [];
  let currentDate = new Date(startDateStr);
  const endDate = new Date(endDateStr);
  currentDate.setUTCHours(0, 0, 0, 0);
  endDate.setUTCHours(0, 0, 0, 0);
  while (currentDate <= endDate) {
    dates.push(currentDate.toISOString().split('T')[0]);
    currentDate.setDate(currentDate.getDate() + 1);
  }
  return dates;
};

interface AssignmentCardProps {
  assignment: Assignment;
  eventFrame: EventFrame;
  isDailyViewExpanded: boolean;
  onToggleDailyView: (assignmentId: string) => void;
  onGeneralStatusChange: (eventFrameId: string, assignmentId: string, newStatus: AssignmentStatus) => void;
  onDailyStatusChange: (eventFrameId: string, assignment: Assignment, date: string, newStatus: AssignmentStatus) => void;
  onEdit: (eventFrameId: string, assignmentId: string) => void;
  onDelete: (eventFrameId: string, assignmentId: string) => void;
}

const AssignmentCard: React.FC<AssignmentCardProps> = ({
  assignment,
  eventFrame,
  isDailyViewExpanded,
  onToggleDailyView,
  onGeneralStatusChange,
  onDailyStatusChange,
  onEdit,
  onDelete,
}) => {
  const peopleGroups = useEventDataStore(state => state.peopleGroups);
  const peopleMap = useMemo(() => {
    const m = new Map<string, string>();
    peopleGroups.forEach(p => m.set(p.id, p.name));
    return m;
  }, [peopleGroups]);
  const personName = peopleMap.get(assignment.personGroupId);
  if (!personName) {
    console.error(`PersonGroup not found for ID: ${assignment.personGroupId}`);
  }

  // Ensure assignment and eventFrame are valid
  if (!assignment || !eventFrame) {
    console.error('Invalid assignment or eventFrame passed to AssignmentCard:', { assignment, eventFrame });
    return null;
  }

  const isMultiDay = assignment.startDate !== assignment.endDate;
  const skipNextCollapse = useRef(false);

  const statusBorderClasses: { [key in AssignmentStatus]: string } = {
    [AssignmentStatus.Yes]: 'border-l-success',
    [AssignmentStatus.Pending]: 'border-l-warning',
    [AssignmentStatus.No]: 'border-l-destructive',
    [AssignmentStatus.Mixed]: 'border-l-primary',
  };
  const borderClass = statusBorderClasses[assignment.status] || 'border-l-transparent';

  const statusButtonClasses: { [key in AssignmentStatus]?: string } = {
    [AssignmentStatus.Yes]: 'bg-success text-success-foreground',
    [AssignmentStatus.Pending]: 'bg-warning text-warning-foreground',
    [AssignmentStatus.No]: 'bg-destructive text-destructive-foreground',
  };

  const toggleDailyView = () => {
    onToggleDailyView(assignment.id);
  };

  const liClasses = useMemo(() => {
    const base = 'rounded-lg';
    // La vora per 'Mixt' utilitzarà el color 'primary' per defecte
    const borderClassForMixed = 'border-l-primary'; 
    const borderClasses = `border-l-4 ${borderClass}`;

    switch (assignment.status) {
      case AssignmentStatus.Yes:
        return `${base} bg-success/15 ${borderClasses}`;
      case AssignmentStatus.Pending:
        return `${base} bg-warning/15 ${borderClasses}`;
      case AssignmentStatus.No:
        return `${base} bg-destructive/15 ${borderClasses}`;
      case AssignmentStatus.Mixed:
        // Només apliquem la classe del degradat. La transparència la definirem al CSS.
        // Afegim la vora per consistència visual.
        return `${base} bg-gradient-mixed border-l-4 ${borderClassForMixed}`; 
      default:
        return `${base} bg-card ${borderClasses}`;
    }
}, [assignment.status, borderClass]);

  return (
    <li className={liClasses}>
      <div
        className={`flex flex-col sm:flex-row justify-between sm:items-start gap-0.5 p-2 ${isMultiDay ? 'cursor-pointer' : ''}`}
        onClick={(e) => {
          if (!isMultiDay) return;
          if ((e.target as HTMLElement).closest('button, input, select, a')) {
            skipNextCollapse.current = true;
            return;
          }
          if (!skipNextCollapse.current) {
            toggleDailyView();
          }
          skipNextCollapse.current = false;
        }}
      >
        <div className="flex-grow">
          <p className="font-semibold text-sm">{personName || 'Persona Desconeguda'}</p>
          <p className="text-xs text-muted-foreground">{formatDateRangeDMY(assignment.startDate, assignment.endDate)}</p>
          <p className="text-xs font-bold">
            {getStatusSummaryText(assignment)}
          </p>
          {assignment.notes && <p className="text-xs mt-0.5 italic text-muted-foreground whitespace-pre-wrap">Nota: {assignment.notes}</p>}
        </div>
        <div className="flex flex-col space-y-0.5 sm:space-y-0 sm:flex-row sm:items-center sm:space-x-0.5 self-start sm:self-center flex-shrink-0">
          <div className="flex items-center space-x-0.5">
            {isMultiDay && (
              <Tooltip text={isDailyViewExpanded ? "Ocultar vista diària" : "Mostrar vista diària"}>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    toggleDailyView();
                  }}
                  className={`px-1.5 py-0.5 rounded-md text-xs font-medium transition-colors ${
                    isDailyViewExpanded ? 'bg-primary text-primary-foreground' : 'bg-secondary text-secondary-foreground hover:bg-accent'
                  }`}
                >
                  {isDailyViewExpanded ? "Ocultar" : "Mostrar"}
                </button>
              </Tooltip>
            )}
            {[AssignmentStatus.Yes, AssignmentStatus.Pending, AssignmentStatus.No].map(status => (
              <Tooltip key={status} text={`Marcar tot com a '${status}'`}>
                <button
                  onClick={() => onGeneralStatusChange(eventFrame.id, assignment.id, status)}
                  className={`font-semibold px-1.5 py-0.5 text-xs rounded-md transition-opacity ${
                    assignment.status === status && assignment.status !== AssignmentStatus.Mixed
                      ? 'opacity-100 ring-1 ring-offset-1 ring-offset-card ring-ring/50'
                      : 'opacity-60 hover:opacity-100'
                  } ${statusButtonClasses[status]}`}
                >
                  {status}
                </button>
              </Tooltip>
            ))}
          </div>
          <div className="flex items-center justify-end space-x-0.5">
            <Tooltip text="Editar assignació">
              <button onClick={() => onEdit(eventFrame.id, assignment.id)} className="p-0.5 rounded-full text-muted-foreground hover:text-foreground hover:bg-accent">
                <EditIcon className="w-4 h-4" />
              </button>
            </Tooltip>
            <Tooltip text="Eliminar assignació">
              <button onClick={() => onDelete(eventFrame.id, assignment.id)} className="p-0.5 rounded-full text-muted-foreground hover:text-foreground hover:bg-accent">
                <TrashIcon className="w-4 h-4" />
              </button>
            </Tooltip>
          </div>
        </div>
      </div>
      {isMultiDay && isDailyViewExpanded && (
        <div className="mt-1 pt-1 border-t border-border bg-muted/50 p-1 rounded-b-lg">
          <h6 className="text-xs font-semibold mb-0.5">Estat per dia:</h6>
          <div className="space-y-0.5">
            {getDaysInRange(assignment.startDate, assignment.endDate).map(date => {
              const currentDailyStatus = assignment.dailyStatuses?.[date] || (assignment.status !== AssignmentStatus.Mixed ? assignment.status : AssignmentStatus.Pending);
              
              const statusRowClasses: { [key in AssignmentStatus]?: string } = {
                [AssignmentStatus.Yes]: 'bg-success/60',      // Fons verd al 60%
                [AssignmentStatus.No]: 'bg-destructive/60',   // Fons vermell al 60%
                [AssignmentStatus.Pending]: 'bg-warning/60',   // Fons groc al 60%
              };
              const rowClass = statusRowClasses[currentDailyStatus] || 'bg-muted/50';

              return (
                <div key={date} className={`flex items-center justify-between p-0.5 rounded-md transition-colors duration-200 ${rowClass}`}>
                  <span className="text-xs font-medium">{formatDateDMY(date)}:</span>
                  <div className="flex space-x-0.5">
                    {[AssignmentStatus.Yes, AssignmentStatus.Pending, AssignmentStatus.No].map(s => (
                      <Tooltip key={s} text={`Marcar dia com a '${s}'`}>
                        <button
                          onClick={() => onDailyStatusChange(eventFrame.id, assignment, date, s)}
                          className={`status-pill ${currentDailyStatus === s ?
                              (s === AssignmentStatus.Yes ? 'status-pill-selected-yes' : s === AssignmentStatus.No ? 'status-pill-selected-no' : 'status-pill-selected-pending') :
                              'status-pill-unselected'}`}
                        >
                          {s}
                        </button>
                      </Tooltip>
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </li>
  );
};

export default AssignmentCard;
--- END: ../Gestor-Events_i_Personal/src/components/AssignmentCard.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/Controls.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import { useState } from 'react';
import { useEventDataStore } from '../stores/eventDataStore';
import { useModalStore } from '../stores/modalStore';
import { startGoogleAuthFlow } from '../stores/googleConfigStore';
import { GoogleIcon, CloudArrowUpIcon, ChevronDownIcon, ChevronUpIcon } from '../constants';
import Tooltip from './ui/Tooltip';

interface ControlsProps {
  theme: string;
  toggleTheme: () => void;
  currentFilePath: string | null;
}

const Controls: React.FC<ControlsProps> = ({ currentFilePath }) => {
  const { syncWithGoogle } = useEventDataStore.getState();
  const isSyncing = useEventDataStore(state => state.isSyncing);
  const { openModal } = useModalStore.getState();

  const [isExpanded, setIsExpanded] = useState(true);

  const toggleExpansion = () => setIsExpanded(prev => !prev);

  return (
    <div className="bg-card text-card-foreground rounded-lg w-full p-2">
      <Tooltip text={isExpanded ? "Col·lapsar controls" : "Expandir controls"}>
        <div
          onClick={toggleExpansion}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              toggleExpansion();
            }
          }}
          role="button"
          tabIndex={0}
          className="flex justify-between items-center w-full cursor-pointer"
        >
          {/* Aquest div atura la propagació de l'esdeveniment onMouseEnter per evitar que es mostrin dos tooltips alhora */}
          <div onMouseEnter={(e) => e.stopPropagation()}>
            <Tooltip text={currentFilePath || 'Cap fitxer carregat'}>
              <div className="text-xs text-muted-foreground truncate">
                Fitxer de dades: <strong>{currentFilePath || 'Document nou sense desar'}</strong>
              </div>
            </Tooltip>
          </div>

          <div>
            {isExpanded ? <ChevronUpIcon className="w-5 h-5" /> : <ChevronDownIcon className="w-5 h-5" />}
          </div>
        </div>
      </Tooltip>

      {isExpanded && (
        <div className="pt-2 mt-2 border-t border-border flex flex-col gap-1">
          <div className="flex items-center justify-end w-full">
            <div className="border border-border rounded-lg p-1 flex items-center gap-0.5">
              <Tooltip text="Sincronitzar manualment amb Google Calendar">
                <button
                  onClick={syncWithGoogle}
                  disabled={isSyncing}
                  className="flex items-center justify-center gap-1 bg-warning hover:bg-warning/90 text-warning-foreground font-semibold py-1 px-2 rounded-md transition-colors text-sm disabled:opacity-50 disabled:cursor-wait w-40"
                >
                  {isSyncing ? (
                    <>
                      <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                      </svg>
                      <span>Sincronitzant...</span>
                    </>
                  ) : (
                    <>
                      <CloudArrowUpIcon />
                      <span>Sincronitzar</span>
                    </>
                  )}
                </button>
              </Tooltip>
              <Tooltip text="Configurar la connexió amb Google">
                <button onClick={() => openModal('googleSettings')} className="flex items-center justify-center gap-1 bg-secondary hover:bg-accent text-secondary-foreground font-semibold py-1 px-2 rounded-md transition-colors text-sm">
                    <GoogleIcon /> Configurar
                </button>
              </Tooltip>
              <Tooltip text="Connectar amb Google Calendar">
                <button
                    onClick={startGoogleAuthFlow}
                    className="flex items-center justify-center gap-1 bg-background hover:bg-accent text-foreground font-semibold py-1 px-2 rounded-md transition-colors text-sm border border-border"
                >
                    <GoogleIcon />
                    <span>Connectar Google</span>
                </button>
              </Tooltip>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Controls;
--- END: ../Gestor-Events_i_Personal/src/components/Controls.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ErrorBoundary.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import { Component, ErrorInfo, ReactNode } from 'react';
import logger from '../utils/logger';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log a more detailed error object for better diagnostics
    logger.error('[ERROR BOUNDARY] Uncaught rendering error:', {
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name,
      },
      componentStack: errorInfo.componentStack,
    });
  }

  public handleReload = () => {
    window.location.reload();
  };

  public render() {
    if (this.state.hasError) {
      return (
        <div className="flex flex-col items-center justify-center h-screen bg-destructive/10 text-destructive-foreground p-8">
          <h1 className="text-2xl font-bold mb-4">S'ha produït un error a l'aplicació</h1>
          <p className="text-center mb-4">S'ha produït un error inesperat a la interfície. Si us plau, reinicia l'aplicació.</p>
          <button
            onClick={this.handleReload}
            className="mb-4 px-4 py-2 bg-destructive text-destructive-foreground font-semibold rounded-md hover:bg-destructive/90 transition-colors"
          >
            Recarregar Aplicació
          </button>
          <details className="w-full max-w-2xl bg-card p-4 rounded-md shadow">
            <summary className="cursor-pointer font-semibold">Detalls de l'error</summary>
            <pre className="mt-2 text-xs whitespace-pre-wrap overflow-auto">
              {this.state.error?.toString()}
            </pre>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

--- END: ../Gestor-Events_i_Personal/src/components/ErrorBoundary.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/EventFrameCard.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import { forwardRef, useMemo } from 'react';
import logger from '@/utils/logger';
import { useModalStore } from '@/stores/modalStore';
import { useEventDataStore } from '@/stores/eventDataStore';
import { EventFrame, Assignment, AssignmentStatus } from '@/types';
import { PersonAddIcon, EditIcon, TrashIcon, ChevronDownIcon, ChevronUpIcon, GoogleIcon, RestoreIcon } from '@/constants';
import { CheckCircleIcon } from '@heroicons/react/24/solid';
import { formatDateRangeDMY } from '@/utils/dateFormat';
import AssignmentCard from './AssignmentCard';
import Tooltip from './ui/Tooltip';

interface EventFrameCardProps {
  eventFrame: EventFrame;
  isExpanded: boolean;
  expandedDailyViewAssignmentIds: Set<string>;
  filters: { person: string; status: AssignmentStatus | ''; };
  onToggleExpand: (id: string) => void;
  onToggleDailyView: (id: string) => void;
  onUpdateEventFrame: (eventFrame: EventFrame) => void;
  onGeneralStatusChange: (eventFrameId: string, assignmentId: string, newStatus: AssignmentStatus) => void;
  onDailyStatusChange: (eventFrameId: string, assignment: Assignment, date: string, newStatus: AssignmentStatus) => void;
  onEditAssignment: (eventFrameId: string, assignmentId: string) => void;
  onDeleteAssignment: (eventFrameId: string, assignmentId: string) => void;
  setToastMessage: (message: string, type?: 'success' | 'error' | 'info' | 'warning') => void;
  isArchived?: boolean;
}

const EventFrameCard = forwardRef<HTMLDivElement, EventFrameCardProps>(({
  eventFrame, isExpanded, expandedDailyViewAssignmentIds, filters, onToggleExpand,
  onToggleDailyView, onUpdateEventFrame, onGeneralStatusChange,
  onDailyStatusChange, onEditAssignment, onDeleteAssignment, setToastMessage,
  isArchived = false,
}, ref) => {
  logger.info(`[EventFrameCard] Render for ${eventFrame.name}. isExpanded: ${isExpanded}`);
  const { peopleGroups, restoreEventFrame } = useEventDataStore.getState();
  const peopleMap = useMemo(() => {
    const m = new Map<string, string>();
    peopleGroups.forEach(p => m.set(p.id, p.name));
    return m;
  }, [peopleGroups]);
  const { openModal } = useModalStore.getState();

  const filteredAssignments = eventFrame.assignments
    .filter(assign => 
      (!filters.person || assign.personGroupId === filters.person) && 
      (!filters.status || assign.status === filters.status || (assign.status === AssignmentStatus.Mixed && assign.dailyStatuses && Object.values(assign.dailyStatuses).includes(filters.status)))
    )
  .sort((a, b) => (peopleMap.get(a.personGroupId) || '').localeCompare(peopleMap.get(b.personGroupId) || ''));

  return (
    <div ref={ref} id={`event-card-${eventFrame.id}`} className="mb-1 rounded-lg overflow-hidden bg-card text-card-foreground border border-border" aria-labelledby={`event-frame-title-${eventFrame.id}`}>
      <div
        className="px-1 py-0.5 bg-muted cursor-pointer border-b border-border"
        onClick={(e) => {
          e.stopPropagation();
          // Only toggle expand if the click is not on an interactive element like a button.
          // Those elements have their own onClick handlers with e.stopPropagation().
          if ((e.target as HTMLElement).closest('button, input, select, a')) {
            return;
          }
          onToggleExpand(eventFrame.id);
        }}
      >
        <div className="flex flex-col sm:flex-row justify-between sm:items-center">
          <div className="mb-0.5 sm:mb-0 flex items-center gap-1">
            <Tooltip text={eventFrame.personnelComplete ? 'Marcar com a incomplet' : 'Marcar com a complet'}>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onUpdateEventFrame({ ...eventFrame, personnelComplete: !eventFrame.personnelComplete });
                  setToastMessage(eventFrame.personnelComplete ? 'Marc marcat com a incomplet.' : 'Marc marcat com a complet.', 'success');
                }}
                className="focus:outline-none"
              >
              <CheckCircleIcon className={`w-5 h-5 transition-colors ${eventFrame.personnelComplete ? 'text-success' : 'text-warning'}`} />
              </button>
            </Tooltip>
            <h4
              id={`event-frame-title-${eventFrame.id}`}
              className="text-sm font-semibold hover:text-primary flex items-center gap-1"
              onClick={(e) => {
                e.stopPropagation();
                openModal('eventFrameDetails', { eventFrame });
              }}
            >
              {eventFrame.googleEventId && (
                <Tooltip text="Aquest esdeveniment està sincronitzat amb Google Calendar">
                  <span>
                    <GoogleIcon className="w-4 h-4" />
                  </span>
                </Tooltip>
              )}

              {eventFrame.name}
            </h4>
            {eventFrame.place && <p className="text-xs text-muted-foreground">{eventFrame.place}</p>}
            <p className="text-xs text-muted-foreground">{formatDateRangeDMY(eventFrame.startDate, eventFrame.endDate)}</p>
          </div>
          <div className="flex items-center space-x-0.5 sm:space-x-0.5 flex-wrap">
            {isArchived ? (
              <Tooltip text="Restaurar l'esdeveniment">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    restoreEventFrame(eventFrame.id);
                    setToastMessage(`Esdeveniment "${eventFrame.name}" restaurat.`, 'success');
                  }}
                  className="flex items-center gap-1 p-0.5 text-success hover:text-success/90 rounded-md hover:bg-accent"
                >
                  <RestoreIcon className="w-4 h-4" />
                  Restaurar
                </button>
              </Tooltip>
            ) : (
              <>
                <Tooltip text="Editar els detalls de l'esdeveniment">
                  <button onClick={(e) => { e.stopPropagation(); openModal('editEventFrame', { eventFrameToEdit: eventFrame }); }} className="p-0.5 text-primary hover:text-primary/80 rounded-md hover:bg-accent"><EditIcon className="w-4 h-4" /></button>
                </Tooltip>
                <Tooltip text="Eliminar l'esdeveniment">
                  <button onClick={(e) => { e.stopPropagation(); openModal('confirmDeleteEventFrame', { itemType: "Marc d'Esdeveniment", itemName: eventFrame.name, itemId: eventFrame.id }); }} className="p-0.5 text-destructive hover:text-destructive/80 rounded-md hover:bg-accent"><TrashIcon className="w-4 h-4" /></button>
                </Tooltip>
                <Tooltip text="Afegir una nova assignació de personal">
                  <button onClick={(e) => {
                    e.stopPropagation();
                    const defaultPersonGroupId = peopleGroups.length > 0 ? peopleGroups[0].id : '';
                    openModal('addAssignment', {
                      eventFrame,
                      personGroupId: defaultPersonGroupId,
                      startDate: eventFrame.startDate,
                      endDate: eventFrame.endDate,
                      status: AssignmentStatus.Pending,
                      notes: '',
                    });
                  }} className="p-0.5 text-primary hover:text-primary/80 rounded-md hover:bg-accent"><PersonAddIcon className="w-4 h-4" /></button>
                </Tooltip>
              </>
            )}
            <Tooltip text={isExpanded ? "Col·lapsar secció" : "Expandir secció"}>
              <button onClick={(e) => { e.stopPropagation(); logger.info(`[EventFrameCard] Chevron clicked for ${eventFrame.name}. Calling onToggleExpand.`); onToggleExpand(eventFrame.id); }} className="p-0.5 text-muted-foreground hover:text-foreground rounded-md hover:bg-accent">
                {isExpanded ? <ChevronUpIcon className="w-4 h-4" /> : <ChevronDownIcon className="w-4 h-4" />}
              </button>
            </Tooltip>
          </div>
        </div>
      </div>

      {isExpanded && (
        <div className="px-1 py-0.5 bg-card">
          {eventFrame.generalNotes && (
            <div className="mb-0.5">
              <h5 className="font-medium text-sm">Notes Generals</h5>
              <p className="text-xs text-muted-foreground whitespace-pre-wrap">{eventFrame.generalNotes}</p>
            </div>
          )}
          <h5 className="font-medium text-sm mb-0.5">Assignacions</h5>
          {filteredAssignments.length === 0 ? (
            <p className="text-xs text-muted-foreground">No hi ha assignacions que coincideixin amb els filtres.</p>
          ) : (
            <ul className="space-y-0.5">
              {filteredAssignments.map(assign => (
                <AssignmentCard
                  key={assign.id}
                  assignment={assign}
                  eventFrame={eventFrame}
                  isDailyViewExpanded={expandedDailyViewAssignmentIds.has(assign.id)}
                  onToggleDailyView={onToggleDailyView}
                  onGeneralStatusChange={onGeneralStatusChange}
                  onDailyStatusChange={onDailyStatusChange}
                  onEdit={onEditAssignment}
                  onDelete={onDeleteAssignment}
                />
              ))}
            </ul>
          )}
        </div>
      )}
    </div>
  );
});

export default EventFrameCard;
--- END: ../Gestor-Events_i_Personal/src/components/EventFrameCard.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/MainDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useRef, useEffect, useMemo, useImperativeHandle } from 'react';
import { Assignment, AssignmentStatus, ShowToastFunction, EventFrame } from '../types';
import { useEventDataStore } from '../stores/eventDataStore';
import { useModalStore } from '../stores/modalStore';
import Tooltip from './ui/Tooltip';
import { PlusIcon, CalendarIcon, ListIcon, ChartBarIcon, ChevronUpIcon, ChevronDownIcon, DocumentArrowDownIcon, ArchiveIcon } from '../constants';
import FullCalendar from '@fullcalendar/react';
import dayGridPlugin from '@fullcalendar/daygrid';
import timeGridPlugin from '@fullcalendar/timegrid';
import listPlugin from '@fullcalendar/list';
import interactionPlugin from '@fullcalendar/interaction';
import multiMonthPlugin from '@fullcalendar/multimonth';
import caLocale from '@fullcalendar/core/locales/ca';
import SummaryReports from './SummaryReports';
import { addDaysISO, formatDateDMY } from '../utils/dateFormat';
import { exportEventListToPdf } from '../utils/pdfGenerator';
import { exportEventListToCsv } from '../utils/csvUtils';
import EventFrameCard from './EventFrameCard';
import { selectFilteredEventFrames } from '../utils/selectors';
import logger from '../utils/logger';

import CollapsibleSection from './ui/CollapsibleSection';

interface MainDisplayProps {
  setToastMessage: ShowToastFunction;
}

const MainDisplay = React.forwardRef<
  { resize: () => void },
  MainDisplayProps
>(({ setToastMessage }, ref) => {
  const calendarRef = useRef<FullCalendar>(null);
  const openModal = useModalStore(state => state.openModal);

  useImperativeHandle(ref, () => ({
    resize: () => {
      if (calendarRef.current) {
        calendarRef.current.getApi().updateSize();
      }
    },
  }));

  // --- State from Zustand Store (Reactive) ---
  const eventFrames = useEventDataStore(state => state.eventFrames);
  const googleEvents = useEventDataStore(state => state.googleEvents);
  const peopleGroups = useEventDataStore(state => state.peopleGroups);
  const peopleMap = useMemo(() => {
    const m = new Map<string, string>();
    peopleGroups.forEach(p => m.set(p.id, p.name));
    return m;
  }, [peopleGroups]);
  
  // Filtres centralitzats de l'store
  const filterText = useEventDataStore(state => state.filterText);
  const filterStatus = useEventDataStore(state => state.filterStatus);
  const filterDate = useEventDataStore(state => state.filterDate);
  const localFilterUIPerson = useEventDataStore(state => state.localFilterUIPerson);
  const filterPlace = useEventDataStore(state => state.filterPlace);
  const filterUIEventFrame = useEventDataStore(state => state.filterUIEventFrame);
  const setManualExpandedFrameIds = useEventDataStore(state => state.setManualExpandedFrameIds);

  // --- Actions from Zustand Store (Non-reactive) ---
  // Actions are stable and can be safely retrieved once.
  const {
    getPersonGroupById,
    getEventFrameById,
    getAssignmentById,
    updateAssignment,
    updateEventFrame, // This is intentionally kept for the child component
    setFilterText,
    setFilterStatus,
    setFilterDate,
    setLocalFilterUIPerson,
    setFilterPlace,
    setFilterUIEventFrame,
    clearAllFilters,
    archiveOldEventFrames,
    confirmArchiveEventFrames,
  } = useEventDataStore.getState();

  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');
  const [showArchived, setShowArchived] = useState(false);

  // Estats d'expansió centralitzats
  const isEventListExpanded = useEventDataStore(state => state.isEventListExpanded);
  const manualExpandedFrameIds = useEventDataStore(state => state.manualExpandedFrameIds);
  const [manualExpandedDailyView, setManualExpandedDailyView] = useState<Set<string>>(new Set());

  const highlightedEventId = useEventDataStore(state => state.highlightedEventId);

  // Removed noisy render logs to avoid spamming console and potential perf issues

  const validationResult = useMemo(() => {
  // Validació iniciada

    if (!eventFrames || !Array.isArray(eventFrames)) {
      console.error('[MainDisplay] Error: eventFrames no és vàlid');
      return { isValid: false, error: 'eventFrames no és vàlid.' };
    }

    if (!googleEvents || !Array.isArray(googleEvents)) {
      console.error('[MainDisplay] Error: googleEvents no és vàlid');
      return { isValid: false, error: 'googleEvents no és vàlid.' };
    }

    if (!peopleGroups || !Array.isArray(peopleGroups)) {
      console.error('[MainDisplay] Error: peopleGroups no és vàlid');
      return { isValid: false, error: 'peopleGroups no és vàlid.' };
    }

  // Dades carregades correctament
    return { isValid: true, error: null };
  }, [eventFrames, googleEvents, peopleGroups]);

  if (!validationResult.isValid) {
    return <p>Error: {validationResult.error}</p>;
  }

  const filteredEventFrames = useMemo(() => {
    return selectFilteredEventFrames({
      eventFrames,
      peopleGroups,
      filterText,
      filterStatus,
      filterDate,
      localFilterUIPerson,
      filterPlace,
      filterUIEventFrame,
      showArchived,
    });
  }, [eventFrames, peopleGroups, filterText, filterStatus, filterDate, localFilterUIPerson, filterPlace, filterUIEventFrame, showArchived]);

  const filteredAndSortedEventFrames = useMemo(() => {
    return filteredEventFrames.sort((a, b) => sortOrder === 'asc'
      ? new Date(a.startDate).getTime() - new Date(b.startDate).getTime()
      : new Date(b.startDate).getTime() - new Date(a.startDate).getTime()
    );
  }, [filteredEventFrames, sortOrder]);

  useEffect(() => {
    logger.info(`[MainDisplay] Highlight useEffect triggered. highlightedEventId: ${highlightedEventId}`);
    if (highlightedEventId) {
      // Afegeix un petit retard per donar temps al DOM a actualitzar-se,
      // especialment si la secció de la llista estava col·lapsada.
      const effectTimer = setTimeout(() => {
        logger.info(`[MainDisplay] Highlight setTimeout running for ID: ${highlightedEventId}`);
        const element = document.getElementById(`event-card-${highlightedEventId}`);

        if (!element) {
          logger.warn(`[MainDisplay] Highlight Effect: Element with ID event-card-${highlightedEventId} not found in DOM.`);
          return;
        }

        logger.info(`[MainDisplay] Highlight Effect: Element found. Scrolling and highlighting.`);
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        element.classList.add('highlight-event-frame');

        const highlightEndTimer = setTimeout(() => {
          element.classList.remove('highlight-event-frame');
          useEventDataStore.getState().setHighlightedEventId(null);
        }, 3000);

        return () => clearTimeout(highlightEndTimer);
      }, 100); // 100ms de retard

      return () => clearTimeout(effectTimer);
    }
  }, [highlightedEventId, filteredAndSortedEventFrames]);

  useEffect(() => {
    logger.info(`[MainDisplay] manualExpandedFrameIds state changed:`, Array.from(manualExpandedFrameIds));
  }, [manualExpandedFrameIds]);

  const isAnyFilterActive = !!(filterText || filterPlace || filterStatus || filterDate || localFilterUIPerson || filterUIEventFrame);

  const handleToggleExpand = (id: string) => {
    logger.info(`[MainDisplay] handleToggleExpand called for ID: ${id}`);
    setManualExpandedFrameIds((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };

  const expandedEventFrameIds = useMemo(() => {
    // When any filter is active, all visible cards are expanded by default to show context.
    if (isAnyFilterActive) {
      return new Set(filteredAndSortedEventFrames.map(ef => ef.id));
    }
    // When no filters are active, expansion is controlled manually by the user.
    return manualExpandedFrameIds;
  }, [isAnyFilterActive, filteredAndSortedEventFrames, manualExpandedFrameIds]);

  const areAllVisibleExpanded = useMemo(() => {
    if (isAnyFilterActive || filteredAndSortedEventFrames.length === 0) return true;
    return filteredAndSortedEventFrames.every(ef => manualExpandedFrameIds.has(ef.id));
  }, [manualExpandedFrameIds, filteredAndSortedEventFrames, isAnyFilterActive]);

  const handleToggleAllCards = () => {
    if (areAllVisibleExpanded) {
      // If all are expanded, collapse all
      setManualExpandedFrameIds(() => new Set());
    } else {
      // If some or none are expanded, expand all
      const allVisibleIds = new Set(filteredAndSortedEventFrames.map(ef => ef.id));
      setManualExpandedFrameIds(() => allVisibleIds);
    }
  };

  const expandedDailyViewAssignmentIds = useMemo(() => {
    if (!isAnyFilterActive) return manualExpandedDailyView;
    const newExpandedAssignments = new Set<string>();
    filteredAndSortedEventFrames.forEach(ef => {
      if (localFilterUIPerson || filterStatus) {
        ef.assignments.forEach(a => {
          const personMatch = !localFilterUIPerson || a.personGroupId === localFilterUIPerson;
          const statusMatch = !filterStatus || a.status === filterStatus || (a.status === AssignmentStatus.Mixed && a.dailyStatuses && Object.values(a.dailyStatuses).includes(filterStatus));
          if (personMatch && statusMatch) {
            newExpandedAssignments.add(a.id);
          }
        });
      }
    });
    return newExpandedAssignments;
  }, [isAnyFilterActive, filteredAndSortedEventFrames, localFilterUIPerson, filterStatus, manualExpandedDailyView]);

  const handleToggleDailyView = (id: string) => {
    setManualExpandedDailyView((prev: Set<string>) => {
      const newSet = new Set(prev);
      if (newSet.has(id)) newSet.delete(id);
      else newSet.add(id);
      return newSet;
    });
  };

  const calendarEvents = useMemo(() => {
  // Actualitzant esdeveniments del calendari
    try {
      const localEventGoogleIds = new Set(eventFrames.map(ef => ef.googleEventId).filter(Boolean));
      const localEventsForCalendar = eventFrames.map(ef => ({
        id: ef.id, title: ef.name, start: ef.startDate, end: addDaysISO(ef.endDate, 1), allDay: true,
        className: ef.personnelComplete ? 'event-complete' : 'event-incomplete',
        extendedProps: { type: 'local', googleEventId: ef.googleEventId } 
      }));
      const filteredGoogleEventsForCalendar = googleEvents
        .filter(gEvent => !localEventGoogleIds.has(gEvent.id))
        .map(gEvent => ({
          ...gEvent, backgroundColor: gEvent.backgroundColor, borderColor: gEvent.borderColor,
          extendedProps: { ...gEvent.extendedProps, type: 'google' }
        }));
      const events = [...localEventsForCalendar, ...filteredGoogleEventsForCalendar];
  // Calendari actualitzat
      return events;
    } catch (error) {
      console.error('[MainDisplay] Error actualitzant esdeveniments del calendari:', error);
      return [];
    }
  }, [eventFrames, googleEvents]);

  const handleGeneralStatusChange = (eventFrameId: string, assignmentId: string, newStatus: AssignmentStatus) => {
    const assignment = getAssignmentById(eventFrameId, assignmentId);
    if (!assignment) return;

    const performUpdate = (force = false) => {
        const result = updateAssignment({ ...assignment, status: newStatus, dailyStatuses: undefined }, force);
        if (result.success) {
            if (result.warningMessage && result.warningMessage.startsWith('DUPLICATE_CONFLICT:')) {
                openModal('confirmDuplicate', {
                    message: result.warningMessage.replace('DUPLICATE_CONFLICT:', ''),
                    onConfirm: () => performUpdate(true),
                });
            } else {
                setToastMessage(`Estat general de l'assignació actualitzat a ${newStatus}`, 'success');
                setManualExpandedDailyView(prev => {
                    const newSet = new Set(prev);
                    newSet.delete(assignmentId);
                    return newSet;
                });
            }
        } else if (result.message) {
            setToastMessage(result.message, 'error');
        }
    };

    if (assignment.status === AssignmentStatus.Mixed) {
        openModal('confirmDeleteEventFrame', {
            itemType: "Actualització massiva",
            itemName: `Estàs a punt de canviar l'estat general de l'assignació de <strong>${peopleMap.get(assignment.personGroupId) || ''}</strong>. Això <strong>esborrarà tots els estats diaris personalitzats</strong>. Vols continuar?`,
            onConfirmSpecial: () => performUpdate(false),
            titleOverride: "Confirmar Canvi General",
            confirmButtonText: "Sí, canviar tot",
            cancelButtonText: "No, mantenir estats diaris"
        });
    } else {
        performUpdate(false);
    }
  };
  
  const handleDailyStatusChange = (_efId: string, assign: Assignment, dateYYYYMMDD: string, newDailyStatus: AssignmentStatus) => {
    const performUpdate = (force = false) => {
        const newDailyStatuses = assign.dailyStatuses ? { ...assign.dailyStatuses } :
            Array.from({ length: (new Date(assign.endDate).getTime() - new Date(assign.startDate).getTime()) / (1000 * 3600 * 24) + 1 }, (_, i) => addDaysISO(assign.startDate, i))
           .reduce((acc, date) => { acc[date] = assign.status; return acc; }, {} as { [date: string]: AssignmentStatus });

        newDailyStatuses[dateYYYYMMDD] = newDailyStatus;
        const newAssignmentData = { ...assign, status: AssignmentStatus.Mixed, dailyStatuses: newDailyStatuses };
        const result = updateAssignment(newAssignmentData, force, { changedDate: dateYYYYMMDD });

        if (result.success) {
            if (result.warningMessage && result.warningMessage.startsWith('DUPLICATE_CONFLICT:')) {
                openModal('confirmDuplicate', {
                    message: result.warningMessage.replace('DUPLICATE_CONFLICT:', ''),
                    onConfirm: () => performUpdate(true),
                });
            } else {
                setToastMessage(`Estat del dia actualitzat a ${newDailyStatus}`, 'success');
            }
        } else if (result.message) {
          setToastMessage(result.message, 'error');
        }
    };
    performUpdate(false);
  };

  const handleEditAssignment = (eventFrameId: string, assignmentId: string) => {
    setManualExpandedFrameIds(prev => new Set(prev).add(eventFrameId));
    const eventFrame = getEventFrameById(eventFrameId);
    const assignment = getAssignmentById(eventFrameId, assignmentId);
    if (eventFrame && assignment) openModal('editAssignment', { eventFrame, assignmentToEdit: assignment });
  };

  const handleDeleteAssignment = (eventFrameId: string, assignmentId: string) => {
    setManualExpandedFrameIds(prev => new Set(prev).add(eventFrameId));
    const eventFrame = getEventFrameById(eventFrameId);
    const assignment = getAssignmentById(eventFrameId, assignmentId);
    const person = assignment ? getPersonGroupById(assignment.personGroupId) : null;
    if (eventFrame && assignment) {
      openModal('confirmDeleteAssignment', {
        itemType: "Assignació", itemName: `${person?.name || 'Desconeguda'} a ${eventFrame.name}`,
        eventFrameId, assignmentId
      });
    }
  };

    return (
    <CollapsibleSection
      title="Calendari i Llista"
      defaultOpen={true}
    >
      <div className="space-y-1">
        <CollapsibleSection title="Vista de Calendari" icon={<CalendarIcon />} defaultOpen={true} id="calendar-section">
          <div className="calendar-wrapper border border-border rounded-lg" style={{ padding: '0.25rem' }}>
            <FullCalendar
                  ref={calendarRef}
                plugins={[dayGridPlugin, timeGridPlugin, listPlugin, interactionPlugin, multiMonthPlugin]}
                initialView="dayGridMonth"
                views={{
                  dayGridMonth: { buttonText: 'Mes' },
                  timeGridWeek: { buttonText: 'Setmana' },
                  listWeek: { buttonText: 'Agenda' },
                  multiMonth2: { type: 'multiMonth', duration: { months: 2 }, buttonText: '2 Mesos', multiMonthMaxColumns: 2 },
                  multiMonth4: { type: 'multiMonth', duration: { months: 4 }, buttonText: '4 Mesos', multiMonthMaxColumns: 2 },
                  multiMonth6: { type: 'multiMonth', duration: { months: 6 }, buttonText: '6 Mesos', multiMonthMaxColumns: 2 }
                }}
                headerToolbar={{ left: 'prev,next today', center: 'title', right: 'multiMonth6,multiMonth4,multiMonth2,dayGridMonth,timeGridWeek,listWeek' }}
                locale={caLocale}
                buttonText={{ today: 'Avui' }}
                height="auto"
                contentHeight="auto"
                aspectRatio={1.5}
                events={calendarEvents}
                dateClick={(info) => openModal('addEventFrame', {
                  name: '',
                  place: '',
                  startDate: info.dateStr,
                  endDate: info.dateStr,
                  generalNotes: '',
                })}
                eventClick={async (info) => {
                  info.jsEvent.preventDefault(); // Prevenim l'acció per defecte per a tots els clics

                  if (info.event.extendedProps.type === 'google') {
                    if (window.electronAPI) {
                      const { calendarId } = info.event.extendedProps;
                      const eventId = info.event.id;

                      try {
                        const result = await window.electronAPI.getEventDetails(calendarId, eventId);
                        if (result.success && result.event) {
                          openModal('googleEventDetails', { eventData: result.event });
                        } else {
                          setToastMessage(result.message || "No s'han pogut obtenir els detalls de l'esdeveniment.", 'error');
                        }
                      } catch (error) {
                        setToastMessage(`Error de comunicació: ${(error as Error).message}`, 'error');
                      }
                    }
                  } else {
                    const ef = getEventFrameById(info.event.id);
                    if (ef) openModal('eventFrameDetails', { eventFrame: ef });
                  }
                }}
                />
        </div>
      </CollapsibleSection>

      <CollapsibleSection
        title={showArchived ? `Esdeveniments Arxivats (${filteredAndSortedEventFrames.length})` : `Llista d'Esdeveniments (${filteredAndSortedEventFrames.length})`}
        icon={<ListIcon />}
        isExpanded={isEventListExpanded}
        onToggle={() => useEventDataStore.getState().toggleEventListExpanded()}
        id="event-list-section"
      >
        <div className="mb-1 flex justify-start items-center gap-1">
          <Tooltip text="Crear un nou marc d'esdeveniment">
            <button data-testid="add-event-frame-button" onClick={() => {
              const today = new Date().toISOString().split('T')[0];
              openModal('addEventFrame', {
                name: '',
                place: '',
                startDate: today,
                endDate: today,
                generalNotes: '',
              });
            }} className="px-2 py-1 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 font-semibold flex items-center gap-1">
              <PlusIcon className="w-4 h-4"/> Afegir Nou Marc
            </button>
          </Tooltip>
          <Tooltip text={`Ordena per data ${sortOrder === 'asc' ? 'descendent' : 'ascendent'}`}>
            <button
              onClick={() => setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')}
              className="flex items-center gap-1 px-2 py-0.5 rounded-md border border-border bg-secondary text-secondary-foreground hover:bg-accent text-xs font-medium"
            >
              {sortOrder === 'asc' ? <ChevronUpIcon className="w-4 h-4" /> : <ChevronDownIcon className="w-4 h-4" />} Ordena
            </button>
          </Tooltip>
            <div className="border-l border-border h-6 mx-1"></div>
            <Tooltip text="Mostrar o ocultar els esdeveniments arxivats">
                <div className="flex items-center">
                    <input
                        type="checkbox"
                        id="showArchived"
                        checked={showArchived}
                        onChange={(e) => setShowArchived(e.target.checked)}
                        className="h-4 w-4 rounded border-border bg-background text-primary focus:ring-ring"
                    />
                    <label htmlFor="showArchived" className="ml-2 text-sm font-medium text-foreground">
                        Mostrar arxivats
                    </label>
                </div>
            </Tooltip>
            <Tooltip text={areAllVisibleExpanded ? "Col·lapsar totes les targetes" : "Expandir totes les targetes"}>
              <button
                onClick={handleToggleAllCards}
                className="px-2 py-0.5 rounded-md border border-border bg-secondary text-secondary-foreground hover:bg-accent text-xs font-medium"
                disabled={isAnyFilterActive || filteredAndSortedEventFrames.length === 0}
              >
                {areAllVisibleExpanded ? "Col·lapsar Tot" : "Expandir Tot"}
              </button>
            </Tooltip>
            <div className="flex-grow"></div>
            <Tooltip text="Arxivar esdeveniments antics (finalitzats fa més d'un mes)">
                <button
                    onClick={() => {
                        const eventsToArchive = archiveOldEventFrames();
                        if (eventsToArchive.length > 0) {
                            const oneMonthAgo = new Date();
                            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                            const formattedDate = oneMonthAgo.toLocaleDateString('ca-ES');

                            openModal('confirmDelete', {
                                itemType: 'Esdeveniments',
                                itemName: `S'arxivaran <strong>${eventsToArchive.length}</strong> esdeveniments finalitzats abans del <strong>${formattedDate}</strong>.`,
                                onConfirm: () => {
                                    const eventIds = eventsToArchive.map(e => e.id);
                                    confirmArchiveEventFrames(eventIds);
                                    setToastMessage(`${eventIds.length} esdeveniment(s) arxivat(s) correctament.`, 'success');
                                },
                                titleOverride: "Confirmació Arxivar",
                                confirmButtonText: "Arxivar Antics",
                                suppressSuccessToast: true,
                                intent: 'destructive'
                            });
                        } else {
                            setToastMessage("No hi ha esdeveniments antics per arxivar.", 'info');
                        }
                    }}
                    className="flex items-center justify-center gap-1 bg-destructive hover:bg-destructive/90 text-destructive-foreground font-semibold py-1 px-2 rounded-md transition-colors text-sm"
                >
                    <ArchiveIcon className="w-4 h-4" /> Arxivar Antics
                </button>
            </Tooltip>
              <Tooltip text="Exportar la llista d'esdeveniments i assignacions a PDF">
                <button
                  onClick={() => exportEventListToPdf(
                    filteredAndSortedEventFrames,
                    peopleGroups,
                    setToastMessage,
                    { filterText, filterStatus, filterDate, localFilterUIPerson, filterPlace, filterUIEventFrame }
                  )}
                  className="flex items-center justify-center gap-1 bg-primary hover:bg-primary/90 text-primary-foreground font-semibold py-1 px-2 rounded-md transition-colors text-sm"
                >
                  <DocumentArrowDownIcon className="w-4 h-4" /> PDF
                </button>
              </Tooltip>
              <Tooltip text="Exportar la llista d'esdeveniments i assignacions a CSV">
                <button
                  onClick={() => exportEventListToCsv(
                    filteredAndSortedEventFrames,
                    peopleGroups,
                    setToastMessage,
                    { filterText, filterStatus, filterDate, localFilterUIPerson, filterPlace, filterUIEventFrame }
                  )}
                  className="flex items-center justify-center gap-1 bg-success hover:bg-success/90 text-success-foreground font-semibold py-1 px-2 rounded-md transition-colors text-sm"
                >
                  <DocumentArrowDownIcon className="w-4 h-4" /> CSV
                </button>
              </Tooltip>
        </div>
        
        <div className="mb-1 p-1 bg-muted rounded-lg flex flex-wrap items-end gap-1 border border-border">
            <div className="flex-grow min-w-[180px]"><label htmlFor="filterText" className="block text-xs font-medium text-muted-foreground">Cerca general</label><Tooltip text="Cerca per nom d'esdeveniment, lloc, notes o nom de persona assignada"><input type="text" id="filterText" value={filterText} onChange={e => setFilterText(e.target.value)} className="mt-1 block w-full px-1.5 py-0.5 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm" placeholder="Nom, lloc, persona..."/></Tooltip></div>
            <div className="flex-grow min-w-[140px]"><label htmlFor="filterUIEventFrame" className="block text-xs font-medium text-muted-foreground">Marc</label><Tooltip text="Filtrar per un marc d'esdeveniment específic"><select id="filterUIEventFrame" value={filterUIEventFrame || ''} onChange={e => setFilterUIEventFrame(e.target.value || null)} className="mt-1 block w-full px-1.5 py-0.5 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm"><option value="">-- Tots --</option>{eventFrames.map(ef => <option key={ef.id} value={ef.id}>{ef.name}</option>)}</select></Tooltip></div>
            <div className="flex-grow min-w-[140px]"><label htmlFor="filterUIPerson" className="block text-xs font-medium text-muted-foreground">Persona</label><Tooltip text="Filtrar per persona o grup assignat"><select id="filterUIPerson" value={localFilterUIPerson} onChange={e => setLocalFilterUIPerson(e.target.value)} className="mt-1 block w-full px-1.5 py-0.5 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm"><option value="">-- Totes --</option>{peopleGroups.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}</select></Tooltip></div>
            <div className="flex-grow min-w-[110px]"><label htmlFor="filterStatus" className="block text-xs font-medium text-muted-foreground">Estat</label><Tooltip text="Filtrar per estat de l'assignació"><select id="filterStatus" value={filterStatus} onChange={e => setFilterStatus(e.target.value as AssignmentStatus | '')} className="mt-1 block w-full px-1.5 py-0.5 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm"><option value="">-- Tots --</option>{Object.values(AssignmentStatus).map(s => <option key={s} value={s}>{s}</option>)}</select></Tooltip></div>
            
            <div className="flex-grow min-w-[140px]"><label htmlFor="filterDate" className="block text-xs font-medium text-muted-foreground">Conté Data</label>
              <Tooltip text="Mostrar només esdeveniments que estiguin actius en aquesta data">
                <input type="date" id="filterDate" value={filterDate} onChange={e => setFilterDate(e.target.value)} className="mt-1 block w-full px-1.5 py-0.5 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm" />
              </Tooltip>
               
                {filterDate && <p className="text-xs text-primary mt-0.5"><span className="font-semibold">Filtre:</span> {formatDateDMY(filterDate)}</p>}
            </div>
            <div className="flex-grow min-w-[140px]"><label htmlFor="filterPlace" className="block text-xs font-medium text-muted-foreground">Lloc</label><Tooltip text="Filtrar per lloc de l'esdeveniment"><select id="filterPlace" value={filterPlace} onChange={e => setFilterPlace(e.target.value)} className="mt-1 block w-full px-1.5 py-0.5 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm"><option value="">-- Tots --</option>{Array.from(new Set(eventFrames.map(ef => ef.place).filter(Boolean))).sort().map(place => (<option key={place} value={place!}>{place}</option>))}</select></Tooltip></div>
            <div className="flex items-center gap-1">
              <Tooltip text="Netejar tots els filtres">
                <button onClick={clearAllFilters} className="px-2 py-1 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border">Netejar</button>
              </Tooltip>
            </div>
        </div>

        {filteredAndSortedEventFrames.length === 0 && <p className="text-center text-muted-foreground py-4">No s'han trobat marcs d'esdeveniment.</p>}
        {filteredAndSortedEventFrames.map((ef: EventFrame) => (
          <EventFrameCard
            key={ef.id}
            eventFrame={ef}
            isArchived={showArchived}
            isExpanded={expandedEventFrameIds.has(ef.id)}
            expandedDailyViewAssignmentIds={expandedDailyViewAssignmentIds}
            filters={{ person: localFilterUIPerson, status: filterStatus }}
            onToggleExpand={handleToggleExpand}
            onToggleDailyView={handleToggleDailyView}
            onUpdateEventFrame={updateEventFrame}
            onGeneralStatusChange={handleGeneralStatusChange}
            onDailyStatusChange={handleDailyStatusChange}
            onEditAssignment={handleEditAssignment}
            onDeleteAssignment={handleDeleteAssignment}
            setToastMessage={setToastMessage}
          />
        ))}
      </CollapsibleSection>

      <CollapsibleSection title="Resums" icon={<ChartBarIcon />} defaultOpen={false} id="summary-section">
         <SummaryReports
            setToastMessage={setToastMessage}
            filteredEventFrames={filteredAndSortedEventFrames}
            activeFilters={{ filterText, filterStatus, filterDate, localFilterUIPerson, filterPlace, filterUIEventFrame }}
         />
      </CollapsibleSection>
    </div>
  </CollapsibleSection>
  );
});

export default MainDisplay;
--- END: ../Gestor-Events_i_Personal/src/components/MainDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/MaterialControlCenter.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useMemo } from 'react';
import { useEventDataStore } from '../stores/eventDataStore';
import { selectMaterialControlData, selectAvailableOrigins, MaterialControlFilters as FiltersState } from '../stores/eventDataStore';
import { ShowToastFunction } from '../types';
import { exportMaterialControlSummaryPdf, exportMaterialControlDetailedPdf } from '../utils/pdfGenerator';
import { exportMaterialControlCsv } from '../utils/csvUtils';
import MaterialControlFilters from './MaterialControlFilters';
import MaterialControlTable from './MaterialControlTable';
import Tooltip from './ui/Tooltip';

interface MaterialControlCenterProps {
  showToast: ShowToastFunction;
}

const MaterialControlCenter: React.FC<MaterialControlCenterProps> = ({ showToast }) => {
  const eventFrames = useEventDataStore(state => state.eventFrames);
  const materialItems = useEventDataStore(state => state.materialItems);
  const isUpdatingMaterial = useEventDataStore(state => state.isUpdatingMaterial);

  const [filters, setFilters] = useState<FiltersState>({
    dateRange: { start: '', end: '' },
    selectedEventIds: [],
    selectedOrigins: [],
    selectedCategories: [],
    searchText: '',
  });

  const allOrigins = useMemo(() => selectAvailableOrigins({ materialItems } as any), [materialItems]);
  const allCategories = useMemo(() => {
    const categories = new Set(materialItems.map(item => item.category));
    return Array.from(categories).sort((a, b) => a.localeCompare(b));
  }, [materialItems]);

  const filteredData = useMemo(() => {
    if (isUpdatingMaterial) {
      return [];
    }
    const data = selectMaterialControlData({ eventFrames, materialItems } as any, filters);

    // Centralized sorting: 1. Category, 2. Origin, 3. Name
    const sortedData = [...data].sort((a, b) => {
      const categoryComparison = a.item.category.localeCompare(b.item.category);
      if (categoryComparison !== 0) {
        return categoryComparison;
      }

      const originComparison = a.item.location.localeCompare(b.item.location);
      if (originComparison !== 0) {
        return originComparison;
      }

      return a.item.name.localeCompare(b.item.name);
    });

    return sortedData;
  }, [eventFrames, materialItems, filters, isUpdatingMaterial]);


  const handleExportSummaryPdf = () => {
    if (filteredData.length === 0) {
        showToast('No hi ha dades per exportar.', 'warning');
        return;
    }
    exportMaterialControlSummaryPdf(filteredData, showToast);
  };

  const handleExportDetailedPdf = () => {
    if (filteredData.length === 0) {
      showToast('No hi ha dades per exportar.', 'warning');
      return;
    }

    // Deduce relevant events from the filtered data that is being displayed
    const relevantEventIds = new Set<string>();
    filteredData.forEach(row => {
      row.breakdown.forEach(bd => {
        relevantEventIds.add(bd.eventFrameId);
      });
    });

    if (relevantEventIds.size === 0) {
      showToast('No hi ha cap esdeveniment associat a les dades filtrades per exportar.', 'warning');
      return;
    }

    const eventsToExport = eventFrames.filter(ef => relevantEventIds.has(ef.id));

    exportMaterialControlDetailedPdf(filteredData, eventsToExport, showToast);
  };

  const handleExportCsv = () => {
     if (filteredData.length === 0) {
        showToast('No hi ha dades per exportar.', 'warning');
        return;
    }
    exportMaterialControlCsv(filteredData, showToast);
  };

  const activeEventFrames = useMemo(() => {
    return eventFrames.filter(ef => ef.isArchived !== true);
  }, [eventFrames]);

  return (
    <div className="space-y-4">
      <MaterialControlFilters
        filters={filters}
        setFilters={setFilters}
        availableOrigins={allOrigins}
        availableCategories={allCategories}
        eventFrames={activeEventFrames}
        dateRange={filters.dateRange}
      />

      <div className="flex justify-end space-x-2">
        <Tooltip text="Exporta un resum del control de material en format PDF.">
          <button
            onClick={handleExportSummaryPdf}
            className="px-3 py-1 text-sm rounded-md bg-primary/10 text-primary hover:bg-primary/20 disabled:opacity-50"
            disabled={filteredData.length === 0}
          >
            PDF Resum
          </button>
        </Tooltip>
        <Tooltip text="Exporta un informe detallat del control de material, incloent el desglossament per esdeveniment, en format PDF.">
          <button
            onClick={handleExportDetailedPdf}
            className="px-3 py-1 text-sm rounded-md bg-primary/10 text-primary hover:bg-primary/20 disabled:opacity-50"
            disabled={filteredData.length === 0}
          >
            PDF Detallat
          </button>
        </Tooltip>
        <Tooltip text="Exporta les dades del control de material en format CSV, compatible amb fulls de càlcul.">
          <button
            onClick={handleExportCsv}
            className="px-3 py-1 text-sm rounded-md bg-success/10 text-success hover:bg-success/20 disabled:opacity-50"
            disabled={filteredData.length === 0}
          >
            CSV
          </button>
        </Tooltip>
      </div>

      {isUpdatingMaterial ? (
          <div className="text-center p-8 text-muted-foreground">Actualitzant dades de material...</div>
      ) : (
          <MaterialControlTable
            data={filteredData}
          />
      )}
    </div>
  );
};

export default MaterialControlCenter;
--- END: ../Gestor-Events_i_Personal/src/components/MaterialControlCenter.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/MaterialControlFilters.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useMemo } from 'react';
import { EventFrame } from '../types';
import { MaterialControlFilters as FiltersState } from '../stores/eventDataStore';
import CollapsibleSection from './ui/CollapsibleSection';
import Tooltip from './ui/Tooltip';

interface MaterialControlFiltersProps {
  filters: FiltersState;
  setFilters: React.Dispatch<React.SetStateAction<FiltersState>>;
  availableOrigins: string[];
  availableCategories: string[];
  eventFrames: EventFrame[];
  dateRange?: { start?: string; end?: string };
}

interface CheckboxListProps {
  title: string;
  field: 'selectedEventIds' | 'selectedOrigins' | 'selectedCategories';
  items: any[];
  displayProp: string;
  idProp: string;
}

const commonInputClass = "mt-1 block w-full px-3 py-2 bg-background border border-border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm";
const commonCheckboxContainerClass = "max-h-40 overflow-y-auto p-2 border border-border rounded-md bg-muted/50";
const commonLabelClass = "flex items-center space-x-2 cursor-pointer hover:bg-accent rounded p-1";

const MaterialControlFilters: React.FC<MaterialControlFiltersProps> = ({
  filters,
  setFilters,
  availableOrigins,
  availableCategories,
  eventFrames,
}) => {
  const handleDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFilters(prev => ({
      ...prev,
      dateRange: { ...prev.dateRange, [name]: value },
    }));
  };

  const handleMultiSelectChange = (field: 'selectedEventIds' | 'selectedOrigins' | 'selectedCategories', value: string) => {
    setFilters(prev => {
      const currentSelection = prev[field] || [];
      const newSelection = currentSelection.includes(value)
        ? currentSelection.filter(item => item !== value)
        : [...currentSelection, value];
      return { ...prev, [field]: newSelection };
    });
  };

  const handleSelectAll = (field: 'selectedEventIds' | 'selectedOrigins' | 'selectedCategories', items: { id: string }[] | string[]) => {
    const allIds = items.map(item => (typeof item === 'string' ? item : item.id));
    setFilters(prev => ({ ...prev, [field]: allIds }));
  };

  const handleSelectNone = (field: 'selectedEventIds' | 'selectedOrigins' | 'selectedCategories') => {
    setFilters(prev => ({ ...prev, [field]: [] }));
  };

  const visibleEvents = useMemo(() => {
    const { start, end } = filters.dateRange || {};
    if (!start && !end) {
      return eventFrames;
    }
    return eventFrames.filter(event => {
      const eventStart = new Date(event.startDate);
      const eventEnd = new Date(event.endDate);
      const filterStart = start ? new Date(start) : null;
      const filterEnd = end ? new Date(end) : null;

      if (filterStart && !isNaN(filterStart.getTime())) {
          if (eventEnd < filterStart) return false;
      }
      if (filterEnd && !isNaN(filterEnd.getTime())) {
          const inclusiveFilterEnd = new Date(filterEnd);
          inclusiveFilterEnd.setDate(inclusiveFilterEnd.getDate() + 1);
          if (eventStart >= inclusiveFilterEnd) return false;
      }

      return true;
    });
  }, [eventFrames, filters.dateRange]);

  const CheckboxList = ({ title, field, items, displayProp, idProp }: CheckboxListProps) => (
    <div>
      <label className="block text-sm font-medium text-muted-foreground">{title}</label>
      <div className="flex items-center gap-2 mt-1">
        <Tooltip text={`Selecciona tots els ${title.toLowerCase()}.`}>
            <button onClick={() => handleSelectAll(field, items)} className="text-xs text-primary hover:underline">Tots</button>
        </Tooltip>
        <Tooltip text={`Deselecciona tots els ${title.toLowerCase()}.`}>
            <button onClick={() => handleSelectNone(field)} className="text-xs text-primary hover:underline">Cap</button>
        </Tooltip>
      </div>
      <div className={commonCheckboxContainerClass}>
        {items.map((item: any) => (
          <label key={item[idProp]} className={commonLabelClass}>
            <input
              type="checkbox"
              checked={filters[field]?.includes(item[idProp])}
              onChange={() => handleMultiSelectChange(field, item[idProp])}
              className="rounded border-border text-primary focus:ring-ring"
            />
            <span className="text-foreground">{item[displayProp]}</span>
          </label>
        ))}
      </div>
    </div>
  );


  return (
    <CollapsibleSection title="Filtres" defaultOpen={true}>
        <div className="p-4 bg-card text-card-foreground rounded-b-lg border-t border-border space-y-4">
            {/* Fila 1: Cerca i Rang de dates */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Text Search */}
                <div>
                    <label htmlFor="search" className="block text-sm font-medium text-muted-foreground">Cerca per text</label>
                    <Tooltip text="Filtra la taula per qualsevol text present a les files (nom, categoria, origen, etc.).">
                        <input
                            type="text"
                            id="search"
                            value={filters.searchText || ''}
                            onChange={(e) => setFilters(prev => ({ ...prev, searchText: e.target.value }))}
                            placeholder="Nom, categoria, origen..."
                            className={commonInputClass}
                        />
                    </Tooltip>
                </div>
                {/* Date Range */}
                <div>
                    <label className="block text-sm font-medium text-muted-foreground">Rang de Dates</label>
                    <div className="flex items-center space-x-2 mt-1">
                        <Tooltip text="Filtra els esdeveniments per data d'inici.">
                            <input
                                type="date"
                                name="start"
                                value={filters.dateRange?.start || ''}
                                onChange={handleDateChange}
                                className={commonInputClass + " mt-0"}
                            />
                        </Tooltip>
                        <span>-</span>
                        <Tooltip text="Filtra els esdeveniments per data de finalització.">
                            <input
                                type="date"
                                name="end"
                                value={filters.dateRange?.end || ''}
                                onChange={handleDateChange}
                                className={commonInputClass + " mt-0"}
                            />
                        </Tooltip>
                    </div>
                </div>
            </div>

            {/* Fila 2: Checkboxes */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                {/* Events */}
                <div>
                    <CheckboxList
                        title="Esdeveniments"
                        field="selectedEventIds"
                        items={visibleEvents}
                        displayProp="name"
                        idProp="id"
                    />
                </div>

                {/* Origins */}
                <div>
                    <CheckboxList
                        title="Orígens"
                        field="selectedOrigins"
                        items={availableOrigins.map(o => ({ id: o, name: o }))}
                        displayProp="name"
                        idProp="id"
                    />
                </div>

                {/* Categories */}
                <div>
                    <CheckboxList
                        title="Categories"
                        field="selectedCategories"
                        items={availableCategories.map(c => ({ id: c, name: c }))}
                        displayProp="name"
                        idProp="id"
                    />
                </div>
            </div>
        </div>
    </CollapsibleSection>
  );
};

export default MaterialControlFilters;

--- END: ../Gestor-Events_i_Personal/src/components/MaterialControlFilters.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/MaterialControlTable.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState } from 'react';
import { MaterialControlRow } from '../types';
import { ChevronDownIcon, ChevronRightIcon } from '../constants';
import { formatDateRangeDMY } from '../utils/dateFormat';
import Tooltip from './ui/Tooltip';

interface MaterialControlTableProps {
  data: MaterialControlRow[];
}

const MaterialControlTable: React.FC<MaterialControlTableProps> = ({ data }) => {
  const [expandedRows, setExpandedRows] = useState<Set<string>>(new Set());

  const toggleRow = (itemId: string) => {
    setExpandedRows(prev => {
      const newSet = new Set(prev);
      if (newSet.has(itemId)) {
        newSet.delete(itemId);
      } else {
        newSet.add(itemId);
      }
      return newSet;
    });
  };

  if (data.length === 0) {
    return <div className="text-center p-8 text-muted-foreground bg-card rounded-lg border border-border">No s'han trobat resultats amb els filtres aplicats.</div>;
  }

  return (
    <div className="overflow-x-auto border border-border rounded-lg">
      <table className="min-w-full divide-y divide-border">
        <thead className="bg-muted">
          <tr>
            <th scope="col" className="w-8 px-1 py-3"></th>
            <th scope="col" className="px-2 py-3 text-right text-xs font-medium text-muted-foreground uppercase tracking-wider">
              <Tooltip text="Quantitat inicial de material disponible.">
                <span>Estoc</span>
              </Tooltip>
            </th>
            <th scope="col" className="px-2 pl-4 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">
              <Tooltip text="Nom del material">
                <span>Nom</span>
              </Tooltip>
            </th>
            <th scope="col" className="px-2 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">
              <Tooltip text="Categoria del material">
                <span>Categoria</span>
              </Tooltip>
            </th>
            <th scope="col" className="px-2 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">
              <Tooltip text="Origen o magatzem del material">
                <span>Origen</span>
              </Tooltip>
            </th>
            <th scope="col" className="px-2 py-3 text-right text-xs font-medium text-muted-foreground uppercase tracking-wider">
              <Tooltip text="Quantitat total de material assignada als esdeveniments filtrats.">
                <span>Demanada</span>
              </Tooltip>
            </th>
            <th scope="col" className="px-2 pr-4 py-3 text-right text-xs font-medium text-muted-foreground uppercase tracking-wider">
              <Tooltip text="Balanç final del material (Estoc - Demanada).">
                <span>Balanç</span>
              </Tooltip>
            </th>
          </tr>
        </thead>
        <tbody className="bg-card divide-y divide-border">
          {data.map(row => {
            const isExpanded = expandedRows.has(row.item.id);
            const balanceIsNegative = row.balance < 0;
            const hasBreakdown = row.breakdown.length > 0;

            return (
              <React.Fragment key={row.item.id}>
                <tr className={`hover:bg-accent ${balanceIsNegative ? 'bg-destructive/10' : ''}`}>
                  <td className="px-1 py-3 text-center">
                    {hasBreakdown && (
                      <button onClick={() => toggleRow(row.item.id)} className="p-1 rounded-full hover:bg-secondary">
                        {isExpanded ? <ChevronDownIcon className="w-5 h-5" /> : <ChevronRightIcon className="w-5 h-5" />}
                      </button>
                    )}
                  </td>
                  <td className="px-2 py-3 whitespace-nowrap text-right text-sm font-medium">{row.item.stock}</td>
                  <td className="px-2 pl-4 py-3 whitespace-nowrap">
                    <div className="font-medium text-foreground">{row.item.name}</div>
                    {row.item.notes && <div className="text-xs text-muted-foreground">{row.item.notes}</div>}
                  </td>
                  <td className="px-2 py-3 whitespace-nowrap text-sm text-muted-foreground">{row.item.category}</td>
                  <td className="px-2 py-3 whitespace-nowrap text-sm text-muted-foreground">{row.item.location}</td>
                  <td className="px-2 py-3 whitespace-nowrap text-right text-sm font-medium">{row.totalDemand}</td>
                  <td className={`px-2 pr-4 py-3 whitespace-nowrap text-right text-sm font-bold ${balanceIsNegative ? 'text-destructive' : 'text-success'}`}>
                    {row.balance}
                  </td>
                </tr>
                {isExpanded && hasBreakdown && (
                  <tr>
                    <td colSpan={7} className="p-0">
                      <div className="p-4 bg-muted/50">
                        <h4 className="font-semibold text-sm mb-2">Desglossament per Esdeveniment:</h4>
                        <ul className="list-disc pl-5 space-y-1">
                          {row.breakdown.map(bd => (
                            <li key={bd.eventFrameId} className="text-sm text-muted-foreground">
                              <span className="font-medium">{bd.eventName} ({formatDateRangeDMY(bd.startDate, bd.endDate)}):</span>
                              <span className="ml-2">{bd.quantity} unitat(s)</span>
                            </li>
                          ))}
                        </ul>
                      </div>
                    </td>
                  </tr>
                )}
              </React.Fragment>
            );
          })}
        </tbody>
      </table>
    </div>
  );
};

export default MaterialControlTable;

--- END: ../Gestor-Events_i_Personal/src/components/MaterialControlTable.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/MaterialDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { useModalStore } from '../stores/modalStore';
import MaterialControlCenter from './MaterialControlCenter';
import { useEventDataStore } from '../stores/eventDataStore';
import { MaterialItem, ShowToastFunction } from '../types';
import { TrashIcon, EditIcon, PdfIcon } from '../constants';
import { exportMaterialToPdf } from '../utils/pdfGenerator';
import CollapsibleSection from './ui/CollapsibleSection';
import Tooltip from './ui/Tooltip';
import MaterialForm from './forms/MaterialForm';

const SortArrow = ({ direction }: { direction: 'ascending' | 'descending' | null }) => {
  if (!direction) return null;
  return <span>{direction === 'ascending' ? ' ↑' : ' ↓'}</span>;
};

interface MaterialDisplayProps {
  showToast: ShowToastFunction;
}

const MaterialDisplay: React.FC<MaterialDisplayProps> = ({ showToast }) => {
  const { addMaterialItem, updateMaterialItem, deleteMaterialItem } = useEventDataStore.getState();
  const materialItems = useEventDataStore(state => state.materialItems);
  const { openModal } = useModalStore();
  
  const [editingItem, setEditingItem] = useState<MaterialItem | null>(null);
  const [search, setSearch] = useState('');
  const [sortConfig, setSortConfig] = useState<{ key: keyof MaterialItem; direction: 'ascending' | 'descending' }>({ key: 'name', direction: 'ascending' });
  const [expandedCategories, setExpandedCategories] = useState<{ [key: string]: boolean }>({});
  const [sortMode, setSortMode] = useState<'category' | 'name'>('category');

  const commonInputClass = "mt-1 block w-full px-3 py-2 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm";

  const categories = useMemo(() => Array.from(new Set(materialItems.map((item: MaterialItem) => item.category))).sort((a,b) => a.localeCompare(b, 'ca', { sensitivity: 'base' })), [materialItems]);
  const locations = useMemo(() => Array.from(new Set(materialItems.map((item: MaterialItem) => item.location).filter(Boolean))).sort((a,b) => a.localeCompare(b, 'ca', { sensitivity: 'base' })), [materialItems]);

  const resetForm = () => {
    setEditingItem(null);
  };

  const handleEdit = (item: MaterialItem) => {
    setEditingItem(item);
  };
  
  const handleSubmit = (itemData: Omit<MaterialItem, 'id'>) => {
    if (editingItem) {
      updateMaterialItem({ ...editingItem, ...itemData });
      showToast('Material actualitzat.', 'success');
    } else {
      addMaterialItem(itemData);
      showToast('Nou material afegit.', 'success');
    }
    resetForm();
  };

  const handleDelete = (item: MaterialItem) => {
    openModal('confirmDelete', {
      itemType: 'Material',
      itemName: `Segur que vols eliminar <strong>${item.name}</strong>?`,
      onConfirm: () => {
        deleteMaterialItem(item.id);
        if (editingItem?.id === item.id) {
          resetForm();
        }
      },
      confirmButtonText: 'Eliminar',
      intent: 'destructive',
    });
  };

  const handleExportPdf = () => {
    exportMaterialToPdf(filteredItems, showToast);
  };

  const requestSort = useCallback((key: keyof MaterialItem) => {
    let direction: 'ascending' | 'descending' = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  }, [sortConfig]);

  const filteredItems = useMemo(() => materialItems.filter((item: MaterialItem) => {
    const searchTerm = search.toLowerCase();
    return (
      item.name.toLowerCase().includes(searchTerm) ||
      item.category.toLowerCase().includes(searchTerm) ||
      item.location.toLowerCase().includes(searchTerm)
    );
  }), [materialItems, search]);
  
  const sortedItems = useMemo(() => {
    const sortableItems = [...filteredItems];

    if (sortMode === 'category') {
      const grouped: { [category: string]: MaterialItem[] } = {};
      sortableItems.forEach(item => {
        const category = item.category || 'Sense Categoria';
        if (!grouped[category]) grouped[category] = [];
        grouped[category].push(item);
      });

      Object.values(grouped).forEach(items => {
        items.sort((a, b) => {
          const valA = a[sortConfig.key];
          const valB = b[sortConfig.key];
          let comparison = 0;
          if (typeof valA === 'number' && typeof valB === 'number') comparison = valA - valB;
          else if (valA !== undefined && valB !== undefined) comparison = String(valA).localeCompare(String(valB), 'ca', { sensitivity: 'base' });
          else if (valA !== undefined) comparison = 1;
          else if (valB !== undefined) comparison = -1;
          return sortConfig.direction === 'ascending' ? comparison : -comparison;
        });
      });
      return Object.entries(grouped).sort(([catA], [catB]) => catA.localeCompare(catB, 'ca', { sensitivity: 'base' }));
    } else { // sortMode === 'name'
      sortableItems.sort((a, b) => {
        const comparison = a.name.localeCompare(b.name, 'ca', { sensitivity: 'base' });
        return sortConfig.direction === 'ascending' ? comparison : -comparison;
      });
      return sortableItems;
    }
  }, [filteredItems, sortConfig, sortMode]);

  useEffect(() => {
    if (sortMode === 'category') {
      const initialExpandedState = (sortedItems as [string, MaterialItem[]][]).reduce((acc, [category]) => {
        acc[category] = true; // Default to all expanded
        return acc;
      }, {} as { [key: string]: boolean });
      setExpandedCategories(initialExpandedState);
    }
  }, [sortedItems, sortMode]);

  const handleSortModeChange = (mode: 'category' | 'name') => {
    setSortMode(mode);
    if (mode === 'category') {
      setSortConfig({ key: 'category', direction: 'ascending' });
    } else { // mode === 'name'
      setSortConfig({ key: 'name', direction: 'ascending' });
    }
  };

  const toggleAll = () => {
    const allCurrentlyExpanded = Object.values(expandedCategories).every(Boolean);
    const newState = { ...expandedCategories };
    for (const key in newState) {
      newState[key] = !allCurrentlyExpanded;
    }
    setExpandedCategories(newState);
  };

  const handleToggleCategory = (category: string) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  };

  const renderItemRow = (item: MaterialItem) => (
    <li key={item.id} className="p-2 border border-border rounded-md bg-muted/50 hover:bg-accent transition-colors">
      <div className="flex justify-between items-start gap-2">
        <div className="w-2/5">
          <p className="font-semibold text-foreground">{item.name}</p>
          {item.notes && <p className="text-xs italic mt-1 text-muted-foreground">{item.notes}</p>}
        </div>
        <div className="w-1/5">
          <p className="text-sm text-foreground">{item.stock}</p>
        </div>
        <div className="w-2/5">
          <p className="text-sm text-foreground">{item.location}</p>
        </div>
        <div className="w-16 flex-shrink-0 flex items-center justify-end space-x-2">
          <Tooltip text={`Editar ${item.name}`}>
            <button onClick={() => handleEdit(item)} className="p-1 text-primary hover:text-primary/80"><EditIcon className="w-4 h-4" /></button>
          </Tooltip>
          <Tooltip text={`Eliminar ${item.name}`}>
            <button onClick={() => handleDelete(item)} className="p-1 text-destructive hover:text-destructive/80"><TrashIcon className="w-4 h-4" /></button>
          </Tooltip>
        </div>
      </div>
    </li>
  );

  return (
    <div className="space-y-4">
      <CollapsibleSection
        title="Gestor de Material"
        defaultOpen={true}
      >
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
          {/* Columna del formulari (25%) */}
          <div className="lg:col-span-1">
            <CollapsibleSection
              title={editingItem ? 'Editar Material' : 'Afegir Nou Material'}
              defaultOpen={true}
            >
              <MaterialForm
                key={editingItem ? editingItem.id : 'new'}
                initialData={editingItem || {}}
                onSubmit={handleSubmit}
                onCancel={editingItem ? resetForm : undefined}
                submitButtonText={editingItem ? 'Actualitzar' : 'Afegir'}
                categories={categories}
                locations={locations}
                materialItems={materialItems}
              />
            </CollapsibleSection>
          </div>

          {/* Columna de la llista (75%) */}
          <div className="lg:col-span-2">
            <CollapsibleSection
              title="Inventari"
              defaultOpen={true}
            >
              <div className="flex items-center justify-end mb-2 gap-2">
                  <Tooltip text="Cercar per nom, categoria o ubicació">
                    <input type="search" placeholder="Cerca..." value={search} onChange={e => setSearch(e.target.value)} className={`${commonInputClass} mt-0 w-auto`} />
                  </Tooltip>
                  <Tooltip text="Exportar llista a PDF">
                    <button
                      onClick={handleExportPdf}
                      className="p-2 rounded-md bg-primary/10 text-primary hover:bg-primary/20"
                      aria-label="Exportar llista de material a PDF"
                      disabled={filteredItems.length === 0}
                    >
                      <PdfIcon className="w-5 h-5" />
                    </button>
                  </Tooltip>
              </div>
              <div className="flex items-center gap-4 mb-3 border-b border-border pb-3">
              <div className="flex items-center gap-2">
                <span className="text-sm font-semibold">Ordenar per:</span>
                <Tooltip text="Agrupar per categoria i ordenar dins de cada grup">
                  <button onClick={() => handleSortModeChange('category')} className={`px-2 py-1 text-sm rounded-md ${sortMode === 'category' ? 'bg-primary text-primary-foreground' : 'bg-secondary text-secondary-foreground'}`}>Categoria</button>
                </Tooltip>
                <Tooltip text="Ordenar tota la llista per nom d'ítem">
                  <button onClick={() => handleSortModeChange('name')} className={`px-2 py-1 text-sm rounded-md ${sortMode === 'name' ? 'bg-primary text-primary-foreground' : 'bg-secondary text-secondary-foreground'}`}>Nom d'Ítem</button>
                </Tooltip>
              </div>
              {sortMode === 'category' && Object.keys(expandedCategories).length > 0 && (
                <Tooltip text="Expandir o col·lapsar totes les categories">
                  <button onClick={toggleAll} className="px-2 py-1 text-sm rounded-md bg-secondary text-secondary-foreground">
                    {Object.values(expandedCategories).every(Boolean) ? 'Col·lapsar Tot' : 'Expandir Tot'}
                  </button>
                </Tooltip>
              )}
            </div>

            <div className="max-h-[60vh] overflow-y-auto space-y-2">
              {sortMode === 'category' && (
                <div className="hidden md:flex items-center gap-2 p-2 text-xs font-bold text-muted-foreground border-b border-border mb-2">
                  <Tooltip text="Ordenar per nom">
                    <button onClick={() => requestSort('name')} className="w-2/5 text-left hover:text-foreground">
                      Nom
                      {sortConfig.key === 'name' && <SortArrow direction={sortConfig.direction} />}
                    </button>
                  </Tooltip>
                  <Tooltip text="Ordenar per estoc">
                    <button onClick={() => requestSort('stock')} className="w-1/5 text-left hover:text-foreground">
                      Estoc
                      {sortConfig.key === 'stock' && <SortArrow direction={sortConfig.direction} />}
                    </button>
                  </Tooltip>
                  <Tooltip text="Ordenar per ubicació">
                    <button onClick={() => requestSort('location')} className="w-2/5 text-left hover:text-foreground">
                      Ubicació
                      {sortConfig.key === 'location' && <SortArrow direction={sortConfig.direction} />}
                    </button>
                  </Tooltip>
                  <div className="w-16 flex-shrink-0 text-right">Accions</div>
                </div>
              )}
              {filteredItems.length > 0 ? (
                sortMode === 'category' ? (
                  (sortedItems as [string, MaterialItem[]][]).map(([category, items]) => (
                    <CollapsibleSection
                      key={category}
                      title={`${category} (${items.length})`}
                      isExpanded={expandedCategories[category]}
                      onToggle={() => handleToggleCategory(category)}
                      headerClassName="bg-muted/50 text-md"
                      contentClassName="space-y-2"
                    >
                      <ul className="space-y-2 list-none">
                        {items.map(renderItemRow)}
                      </ul>
                    </CollapsibleSection>
                  ))
                ) : (
                  <ul className="space-y-2">
                    {(sortedItems as MaterialItem[]).map(renderItemRow)}
                  </ul>
                )
              ) : <p className="text-center text-muted-foreground">No s'ha trobat material o l'inventari està buit.</p>}
            </div>
          </CollapsibleSection>
          </div>
        </div>
      </CollapsibleSection>

      <CollapsibleSection
        title="Centre de Control de Material"
        defaultOpen={false}
        headerClassName="text-xl font-semibold"
      >
        <div className="p-4 bg-muted rounded-b-lg border-t border-border">
          <MaterialControlCenter showToast={showToast} />
        </div>
      </CollapsibleSection>
    </div>
  );
};

export default MaterialDisplay;
--- END: ../Gestor-Events_i_Personal/src/components/MaterialDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/Navigation.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { NavLink } from 'react-router-dom';
import { CalendarIcon, BoxIcon, UsersIcon } from '../constants';
import Tooltip from './ui/Tooltip';

const DocumentTextIcon = ({ className = "w-5 h-5" }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
  </svg>
);

const Navigation: React.FC = () => {
  const getLinkClassName = ({ isActive }: { isActive: boolean }) =>
    `flex items-center gap-1 px-1.5 text-xs font-medium rounded-md transition-colors ${
      isActive
        ? 'bg-primary text-primary-foreground'
        : 'text-muted-foreground hover:bg-accent hover:text-accent-foreground'
    }`;

  return (
    <nav className="flex justify-center">
      <div className="flex space-x-2 bg-muted p-1 rounded-lg border border-border">
        <Tooltip text="Anar a la vista principal del calendari i llista d'esdeveniments">
          <NavLink to="/" className={getLinkClassName}>
            <CalendarIcon className="h-5 w-5" />
            <span>Calendari i Llista</span>
          </NavLink>
        </Tooltip>
        
        <Tooltip text="Anar a la gestió de fitxes tècniques (bolos)">
          <NavLink to="/tech-sheets" className={getLinkClassName}>
            <DocumentTextIcon className="h-5 w-5" />
            <span>Fitxes de Bolo</span>
          </NavLink>
        </Tooltip>

        <Tooltip text="Anar a la gestió de persones i grups">
          <NavLink to="/people" className={getLinkClassName}>
            <UsersIcon className="h-5 w-5" />
            <span>Persones</span>
          </NavLink>
        </Tooltip>

        <Tooltip text="Anar a la gestió d'inventari de material">
          <NavLink to="/material" className={getLinkClassName}>
            <BoxIcon className="h-5 w-5" />
            <span>Material</span>
          </NavLink>
        </Tooltip>
      
      </div>
    </nav>
  );
};

export default Navigation;
--- END: ../Gestor-Events_i_Personal/src/components/Navigation.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/PeopleDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, FormEvent, useMemo } from 'react';
import { saveAs } from 'file-saver';
import { useEventDataStore } from '../stores/eventDataStore';
import { useModalStore } from '../stores/modalStore';
import { PersonGroup, ShowToastFunction } from '../types';
import { TrashIcon, EditIcon, CsvIcon, PdfIcon } from '../constants';
import { exportPeopleToPdf } from '../utils/pdfGenerator';
import { escapeCsvCell } from '../utils/csvUtils';
import Tooltip from './ui/Tooltip';
import AutosizeTextarea from './ui/AutosizeTextarea';
import CollapsibleSection from './ui/CollapsibleSection';

interface PeopleDisplayProps {
  showToast: ShowToastFunction;
}

const PeopleDisplay: React.FC<PeopleDisplayProps> = ({ showToast }) => {
  const { addPersonGroup, updatePersonGroup, deletePersonGroup: deletePersonGroupContext } = useEventDataStore.getState();
  const openModal = useModalStore(state => state.openModal);
  const peopleGroups = useEventDataStore(state => state.peopleGroups);
  const [name, setName] = useState('');
  const [role, setRole] = useState('');
  const [tel1, setTel1] = useState('');
  const [tel2, setTel2] = useState('');
  const [email, setEmail] = useState('');
  const [web, setWeb] = useState('');
  const [notes, setNotes] = useState('');
  const [editingContact, setEditingContact] = useState<PersonGroup | null>(null);
  const [errors, setErrors] = useState<{[key: string]: string}>({});
  const [search, setSearch] = useState('');

  function normalize(str: string) {
    return str
      .toLocaleLowerCase('ca')
      .normalize('NFD')
      .replace(/\p{Diacritic}/gu, '')
      .replace(/\s+/g, ' ')
      .trim();
  }

  const [sortConfig, setSortConfig] = useState<{ key: keyof PersonGroup, direction: 'ascending' | 'descending' }>({ key: 'name', direction: 'ascending' });

  const filteredContacts = peopleGroups.filter(pg => {
    if (!search.trim()) return true;
    const s = normalize(search);
    return [pg.name, pg.role, pg.email, pg.tel1, pg.tel2]
      .filter(Boolean)
      .map(val => normalize(val!))
      .some(val => val.includes(s));
  });

  const sortedContacts = useMemo(() => {
    const sortableItems = [...filteredContacts];
    sortableItems.sort((a, b) => {
      const valA = a[sortConfig.key];
      const valB = b[sortConfig.key];
      let comparison = 0;

      if (valA === undefined || valA === null || valA === '') comparison = 1;
      else if (valB === undefined || valB === null || valB === '') comparison = -1;
      else comparison = String(valA).localeCompare(String(valB), 'ca', { sensitivity: 'base' });

      return sortConfig.direction === 'ascending' ? comparison : -comparison;
    });
    return sortableItems;
  }, [filteredContacts, sortConfig]);

  const requestSort = (key: keyof PersonGroup) => {
    let direction: 'ascending' | 'descending' = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };

  const commonInputClass = "mt-1 block w-full px-3 py-2 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm disabled:opacity-50";

  const resetForm = () => {
    setName('');
    setRole('');
    setTel1('');
    setTel2('');
    setEmail('');
    setWeb('');
    setNotes('');
    setEditingContact(null);
    setErrors({});
  };

  const handleEdit = (person: PersonGroup) => {
    setEditingContact(person);
    setName(person.name);
    setRole(person.role || '');
    setTel1(person.tel1 || '');
    setTel2(person.tel2 || '');
    setEmail(person.email || '');
    setWeb(person.web || '');
    setNotes(person.notes || '');
    setErrors({});
  };

  const validate = (): boolean => {
    const newErrors: {[key: string]: string} = {};
    if (!name.trim()) newErrors.name = "El nom és obligatori.";
    const isDuplicate = peopleGroups.some(pg =>
        pg.name.trim().toLowerCase() === name.trim().toLowerCase() &&
        (!editingContact || pg.id !== editingContact.id)
    );
    if (isDuplicate) newErrors.name = "Ja existeix un contacte amb aquest nom.";

    if (email && !email.includes('@')) {
      newErrors.email = "El format del correu electrònic no és vàlid.";
    }
    if (web && !/^(https?:\/\/)?([\w-]+\.)+[\w-]+(\/[\w-./?%&=]*)?$/.test(web) && !/^([\w-]+\.)+[\w-]+(\/[\w-./?%&=]*)?$/.test(web)) {
      newErrors.web = "El format de la pàgina web no és vàlid.";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if(!validate()) return;

    const personData: Omit<PersonGroup, 'id'> = {
        name: name.trim(),
        role: role.trim(),
        tel1: tel1.trim(),
        tel2: tel2.trim(),
        email: email.trim(),
        web: web.trim(),
        notes: notes.trim()
    };
    
    if (editingContact) {
      updatePersonGroup({ ...editingContact, ...personData });
      showToast("Contacte actualitzat.", 'success');
    } else {
      addPersonGroup(personData);
      showToast("Contacte afegit.", 'success');
    }
    resetForm();
  };

  const handleDeleteContact = (person: PersonGroup) => {
    openModal('confirmDelete', {
      itemType: 'Contacte',
      itemName: `Segur que vols eliminar a <strong>${person.name}</strong>? Aquesta acció no es pot desfer.`,
      onConfirm: () => {
        deletePersonGroupContext(person.id);
        if (editingContact?.id === person.id) {
          resetForm();
        }
      },
      confirmButtonText: 'Eliminar',
      intent: 'destructive',
    });
  };

  const exportPeopleToCSV = async () => {
    const header = ['Nom', 'Rol', 'Telèfon 1', 'Telèfon 2', 'Email', 'Web', 'Notes'];
    const rows = filteredContacts.map(p => [
      p.name,
      p.role,
      p.tel1,
      p.tel2,
      p.email,
      p.web,
      p.notes
    ]);

    const csvContent = [header, ...rows]
      .map(row => row.map(escapeCsvCell).join(','))
      .join('\n');

    const today = new Date().toISOString().slice(0, 10);
    const filename = `llista_contactes_${today}.csv`;

    if (window.electronAPI?.showSaveDialog) {
      const result = await window.electronAPI.showSaveDialog({
        title: 'Desar CSV',
        defaultPath: filename,
        filters: [{ name: 'CSV', extensions: ['csv'] }],
        data: "\uFEFF" + csvContent,
      });
      if (result.success) {
        showToast('CSV desat amb èxit!', 'success');
      } else if (!result.canceled) {
        showToast(`Error en desar el CSV: ${result.message}`, 'error');
      }
    } else {
      const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8' });
      saveAs(blob, filename);
    }
  };

  const exportToPdf = async () => {
    await exportPeopleToPdf(filteredContacts, showToast);
  };

  return (
    <CollapsibleSection
      title="Gestor de Contactes"
      defaultOpen={true}
    >
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
            {/* Columna del formulari (25%) */}
            <div className="lg:col-span-1">
              <CollapsibleSection
                title={editingContact ? 'Editar Contacte' : 'Afegir Nou Contacte'}
                defaultOpen={true}
              >
                  <form onSubmit={handleSubmit} className="space-y-3" aria-labelledby="people-group-form-title">
                      {editingContact && (
                          <div className="flex justify-end">
                              <Tooltip text="Eliminar aquest contacte">
                                  <button
                                  type="button"
                                  onClick={() => handleDeleteContact(editingContact)}
                                  aria-label="Eliminar aquest contacte"
                                  className="ml-2 p-2 rounded-full bg-destructive/10 hover:bg-destructive/20 text-destructive transition-colors"
                                  >
                                  <TrashIcon className="w-4 h-4" />
                                  </button>
                              </Tooltip>
                          </div>
                      )}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-x-2 gap-y-2">
                          <div>
                              <label htmlFor="pg-name" className="block text-sm font-medium text-muted-foreground">Nom</label>
                              <Tooltip text="Nom del contacte. Aquest camp és obligatori i ha de ser únic.">
                                <input type="text" id="pg-name" value={name} onChange={e => setName(e.target.value)} className={commonInputClass} required aria-required="true" />
                              </Tooltip>
                              {errors.name && <p className="text-destructive text-xs mt-1" role="alert">{errors.name}</p>}
                          </div>
                          <div>
                              <label htmlFor="pg-role" className="block text-sm font-medium text-muted-foreground">Rol/Tipus (Opcional)</label>
                              <Tooltip text="Rol o tipus de servei (p. ex. Tècnic de so, Proveïdor de llums)">
                                <input type="text" id="pg-role" value={role} onChange={e => setRole(e.target.value)} className={commonInputClass} />
                              </Tooltip>
                          </div>
                          <div>
                              <label htmlFor="pg-tel1" className="block text-sm font-medium text-muted-foreground">Telèfon 1 (Opcional)</label>
                              <Tooltip text="Primer telèfon de contacte">
                                <input type="tel" id="pg-tel1" value={tel1} onChange={e => setTel1(e.target.value)} className={commonInputClass} />
                              </Tooltip>
                          </div>
                          <div>
                              <label htmlFor="pg-tel2" className="block text-sm font-medium text-muted-foreground">Telèfon 2 (Opcional)</label>
                              <Tooltip text="Segon telèfon de contacte">
                                <input type="tel" id="pg-tel2" value={tel2} onChange={e => setTel2(e.target.value)} className={commonInputClass} />
                              </Tooltip>
                          </div>
                          <div>
                              <label htmlFor="pg-email" className="block text-sm font-medium text-muted-foreground">Correu Electrònic (Opcional)</label>
                              <Tooltip text="Adreça de correu electrònic">
                                <input type="email" id="pg-email" value={email} onChange={e => setEmail(e.target.value)} className={commonInputClass} />
                              </Tooltip>
                              {errors.email && <p className="text-destructive text-xs mt-1" role="alert">{errors.email}</p>}
                          </div>
                          <div>
                              <label htmlFor="pg-web" className="block text-sm font-medium text-muted-foreground">Pàgina Web (Opcional)</label>
                              <Tooltip text="Pàgina web del contacte">
                                <input type="url" id="pg-web" value={web} onChange={e => setWeb(e.target.value)} className={commonInputClass} placeholder="https://exemple.com"/>
                              </Tooltip>
                              {errors.web && <p className="text-destructive text-xs mt-1" role="alert">{errors.web}</p>}
                          </div>
                      </div>
                      <div className="col-span-1 md:col-span-2">
                          <label htmlFor="pg-notes" className="block text-sm font-medium text-muted-foreground">Notes (Opcional)</label>
                          <Tooltip text="Qualsevol informació addicional rellevant">
                            <AutosizeTextarea id="pg-notes" value={notes} onChange={e => setNotes(e.target.value)} rows={2} className={`${commonInputClass} resize-none overflow-hidden`} />
                          </Tooltip>
                      </div>
                      <div className="flex justify-end space-x-2 pt-2">
                          {editingContact && (
                              <Tooltip text="Cancel·lar els canvis i netejar el formulari">
                                  <button type="button" onClick={resetForm} className="px-2 py-1 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border">Cancel·lar Edició</button>
                              </Tooltip>
                          )}
                          <Tooltip text={editingContact ? 'Desar els canvis' : 'Afegir el nou contacte'}>
                              <button type="submit" className="px-2 py-1 text-sm font-medium bg-primary text-primary-foreground hover:bg-primary/90 rounded-md">{editingContact ? 'Actualitzar' : 'Afegir'}</button>
                          </Tooltip>
                      </div>
                  </form>
              </CollapsibleSection>
            </div>

            {/* Columna de la llista (75%) */}
            <div className="lg:col-span-2">
              <CollapsibleSection
                title="Llista de Contactes"
                defaultOpen={true}
              >
                  <div className="flex items-center justify-end mb-2 gap-2">
                      <Tooltip text="Exportar a CSV">
                        <button type="button" onClick={exportPeopleToCSV} className="p-1 rounded-md bg-success/10 text-success hover:bg-success/20">
                          <CsvIcon className="w-4 h-4" />
                        </button>
                      </Tooltip>
                      <Tooltip text="Exportar a PDF">
                        <button type="button" onClick={exportToPdf} className="p-1 rounded-md bg-primary/10 text-primary hover:bg-primary/20">
                          <PdfIcon className="w-4 h-4" />
                        </button>
                      </Tooltip>
                  </div>
                  <div className="mb-2 flex items-center gap-2">
                      <span className="text-muted-foreground">
                      <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" className="inline align-middle"><path d="M21 21l-4.35-4.35" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/><circle cx="11" cy="11" r="7" stroke="currentColor" strokeWidth="2"/></svg>
                      </span>
                      <Tooltip text="Cercar per nom, rol, email o telèfon">
                        <input
                        type="search"
                        className="block w-full px-2 py-1 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm"
                        placeholder="Cerca per nom, rol, email, tel..."
                        value={search}
                        onChange={e => setSearch(e.target.value)}
                        aria-label="Cercar contacte"
                        />
                      </Tooltip>
                  </div>
                  <div className="flex items-center gap-2 mb-2">
                      <span className="text-sm font-medium">Ordenar per:</span>
                      <Tooltip text="Ordenar per nom (A-Z / Z-A)">
                        <button onClick={() => requestSort('name')} className={`px-2 py-0.5 text-xs rounded-md ${sortConfig.key === 'name' ? 'bg-primary text-primary-foreground' : 'bg-secondary text-secondary-foreground'}`}>
                            Nom {sortConfig.key === 'name' && (sortConfig.direction === 'ascending' ? '↑' : '↓')}
                        </button>
                      </Tooltip>
                      <Tooltip text="Ordenar per rol (A-Z / Z-A)">
                        <button onClick={() => requestSort('role')} className={`px-2 py-0.5 text-xs rounded-md ${sortConfig.key === 'role' ? 'bg-primary text-primary-foreground' : 'bg-secondary text-secondary-foreground'}`}>
                            Rol {sortConfig.key === 'role' && (sortConfig.direction === 'ascending' ? '↑' : '↓')}
                        </button>
                      </Tooltip>
                  </div>
                  {sortedContacts.length === 0 ? (
                      <p className="text-muted-foreground">No hi ha contactes que coincideixin amb la cerca.</p>
                  ) : (
                      <ul className="space-y-1 max-h-[55vh] overflow-y-auto" aria-label="Llista de contactes existents">
                      {sortedContacts.map((p: PersonGroup) => (
                          <li key={p.id} className="p-2 border border-border rounded-md bg-muted/50 hover:bg-accent transition-colors">
                          <div className="flex justify-between items-start">
                              <div className="flex-grow">
                                  <span className="font-semibold text-foreground">{p.name}</span>
                                  {p.role && <p className="text-xs text-muted-foreground">Rol: {p.role}</p>}
                              </div>
                              <div className="space-x-2 flex-shrink-0">
                                  <Tooltip text={`Editar ${p.name}`}>
                                      <button onClick={() => handleEdit(p)} className="p-1 text-primary hover:text-primary/80 transition-colors" aria-label={`Editar ${p.name}`}><EditIcon className="w-4 h-4"/></button>
                                  </Tooltip>
                                  <Tooltip text={`Eliminar ${p.name}`}>
                                      <button onClick={() => handleDeleteContact(p)} className="p-1 text-destructive hover:text-destructive/80 transition-colors" aria-label={`Eliminar ${p.name}`}><TrashIcon className="w-4 h-4"/></button>
                                  </Tooltip>
                              </div>
                          </div>
                          <div className="mt-1 text-xs space-y-0.5 text-muted-foreground">
                              {(p.tel1 || p.tel2) && <p>Tel: {p.tel1}{p.tel1 && p.tel2 && " / "}{p.tel2}</p>}
                              {p.email && <p>Email: <a href={`mailto:${p.email}`} className="text-primary hover:underline">{p.email}</a></p>}
                              {p.web && <p>Web: <a href={p.web.startsWith('http') ? p.web : `https://${p.web}`} target="_blank" rel="noopener noreferrer" className="text-primary hover:underline">{p.web}</a></p>}
                              {p.notes && <p className="mt-1 italic">Notes: {p.notes}</p>}
                          </div>
                          </li>
                      ))}
                      </ul>
                  )}
              </CollapsibleSection>
            </div>
        </div>
    </CollapsibleSection>
  );
};

export default PeopleDisplay;

--- END: ../Gestor-Events_i_Personal/src/components/PeopleDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/SummaryReports.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useMemo } from 'react';
import { useEventDataStore } from '../stores/eventDataStore';
import { AssignmentStatus, SummaryRow, ShowToastFunction, EventFrame } from '../types';
import { CsvIcon, ChevronUpIcon, ChevronDownIcon, PdfIcon } from '../constants';
import { formatDateDMY, formatDateRangeDMY } from '../utils/dateFormat';
import { getStatusSummaryText } from '../utils/statusUtils';
import { exportSummariesToPdf } from '../utils/pdfGenerator';
import { escapeCsvCell } from '../utils/csvUtils';
import { generateFileName } from '../utils/fileNameUtils';
import Tooltip from './ui/Tooltip';

type ActiveFilters = {
  filterText?: string | null;
  filterStatus?: string | null;
  filterDate?: string | null;
  localFilterUIPerson?: string | null;
  filterPlace?: string | null;
  filterUIEventFrame?: string | null;
};

interface SummaryReportsProps {
  setToastMessage: ShowToastFunction;
  filteredEventFrames: EventFrame[];
  activeFilters: ActiveFilters;
}

const SummaryReports: React.FC<SummaryReportsProps> = ({ setToastMessage, filteredEventFrames, activeFilters }) => {
  const peopleGroups = useEventDataStore(state => state.peopleGroups);
  const peopleMap = useMemo(() => {
    const m = new Map<string, string>();
    peopleGroups.forEach(p => m.set(p.id, p.name));
    return m;
  }, [peopleGroups]);
  const showToast = (message: string, type: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    // This is a placeholder. The actual implementation will be in the component that uses the store.
    // A better approach would be to have a separate toast store or use a library.
    console.log(`[TOAST] ${type?.toUpperCase()}: ${message}`);
  };

  // --- LÒGICA DE DADES (ara basada en dades filtrades) ---
  const allAssignmentsSummary = useMemo((): SummaryRow[] => {
    const summary: SummaryRow[] = [];
    filteredEventFrames.forEach(ef => {
      ef.assignments.forEach(a => {
        const personName = peopleMap.get(a.personGroupId);
        summary.push({
          id: `${ef.id}-${a.id}`,
          primaryGrouping: ef.name,
          secondaryGrouping: personName || 'N/A',
          eventFrameName: ef.name,
          eventFramePlace: ef.place || '',
          eventFrameStartDate: ef.startDate,
          eventFrameEndDate: ef.endDate,
          assignmentPersonName: personName || 'N/A',
          assignmentStartDate: a.startDate,
          assignmentEndDate: a.endDate,
          assignmentStatus: a.status,
          assignmentNotes: a.notes || '',
          eventFrameGeneralNotes: ef.generalNotes || '',
          isMixedStatusAssignment: a.status === AssignmentStatus.Mixed,
          assignmentObject: a,
        });
      });
    });
    return summary;
  }, [filteredEventFrames, peopleMap]);

  // Estat d'ordre per als resums
  const [summarySortOrder, setSummarySortOrder] = React.useState<'asc' | 'desc'>('desc');

  const summaryByEventName = useMemo((): Map<string, SummaryRow[]> => {
    const map = new Map<string, SummaryRow[]>();
    allAssignmentsSummary.forEach(row => {
        if (!map.has(row.eventFrameName)) {
            map.set(row.eventFrameName, []);
        }
        map.get(row.eventFrameName)!.push(row);
    });
    return new Map([...map.entries()].sort((a, b) => {
        const dateA = new Date(a[1][0].eventFrameStartDate).getTime();
        const dateB = new Date(b[1][0].eventFrameStartDate).getTime();
        return summarySortOrder === 'asc'
          ? dateA - dateB || a[0].localeCompare(b[0])
          : dateB - dateA || a[0].localeCompare(b[0]);
    }));
  }, [allAssignmentsSummary, summarySortOrder]);

  const summaryByStartDate = useMemo((): Map<string, SummaryRow[]> => {
    const map = new Map<string, SummaryRow[]>();
    allAssignmentsSummary.forEach(row => {
        const dateStr = formatDateDMY(row.assignmentStartDate);
        if (!map.has(dateStr)) {
            map.set(dateStr, []);
        }
        map.get(dateStr)!.push(row);
    });
    return new Map([...map.entries()].sort((a, b) => {
      const dateA = new Date(a[0].split('/').reverse().join('-')).getTime();
      const dateB = new Date(b[0].split('/').reverse().join('-')).getTime();
      return summarySortOrder === 'asc' ? dateA - dateB : dateB - dateA;
    }));
  }, [allAssignmentsSummary, summarySortOrder]);

  const summaryByPerson = useMemo((): Map<string, SummaryRow[]> => {
    const map = new Map<string, SummaryRow[]>();
    allAssignmentsSummary.forEach(row => {
        if (!map.has(row.assignmentPersonName)) map.set(row.assignmentPersonName, []);
        map.get(row.assignmentPersonName)!.push(row);
    });
    return new Map([...map.entries()].sort((a, b) => a[0].localeCompare(b[0])));
  }, [allAssignmentsSummary]);

  const downloadCsv = async (csvContent: string, filename: string) => {
    if (!csvContent.trim() || csvContent.split('\n').length <= 1) {
        setToastMessage("No hi ha dades per exportar en aquest resum.", 'info');
        return;
    }

    if (window.electronAPI?.showSaveDialog) {
        const result = await window.electronAPI.showSaveDialog({
            title: 'Desar CSV',
            defaultPath: filename,
            filters: [{ name: 'CSV', extensions: ['csv'] }],
            data: "\uFEFF" + csvContent,
        });
        if (result.success) {
            setToastMessage(`Resum "${filename}" exportat a CSV.`, 'success');
        } else if (!result.canceled) {
            setToastMessage(`Error en desar el CSV: ${result.message}`, 'error');
        }
    } else {
        const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setToastMessage(`Resum "${filename}" exportat a CSV.`, 'success');
    }
  };

  const generateDetailedCsv = (dataType: 'event-name' | 'start-date' | 'person', groupKey: string | null = null): string => {
    let assignmentsToProcess: SummaryRow[] = allAssignmentsSummary;

    if (groupKey) {
        assignmentsToProcess = assignmentsToProcess.filter(a => {
            if (dataType === 'event-name') return a.eventFrameName === groupKey;
            if (dataType === 'start-date') return formatDateDMY(a.assignmentStartDate) === groupKey;
            if (dataType === 'person') return a.assignmentPersonName === groupKey;
            return false;
        });
    }

    const csvRows: string[][] = [];
    const headers = [
        'Agrupació Principal', 'Esdeveniment Marc', 'Dates Marc', 'Lloc Marc', 
        'Persona/Grup Assignat', 'Dates Assignació', 'Estat General', 'Detall Estats (si mixt)', 'Notes Assignació'
    ];
    csvRows.push(headers);

    assignmentsToProcess.forEach(a => {
        const statusDetail = a.isMixedStatusAssignment ? getStatusSummaryText(a.assignmentObject) : a.assignmentStatus;
        csvRows.push([
            a.primaryGrouping,
            a.eventFrameName,
            formatDateRangeDMY(a.eventFrameStartDate, a.eventFrameEndDate),
            a.eventFramePlace || '',
            a.assignmentPersonName,
            formatDateRangeDMY(a.assignmentStartDate, a.assignmentEndDate),
            a.assignmentStatus,
            statusDetail,
            a.assignmentNotes || ''
        ]);
    });
    
    return csvRows.map(row => row.map(escapeCsvCell).join(',')).join('\n');
  };

  const handleExportPdf = async (title: string, data: Map<string, SummaryRow[]>, dataType: 'event-name' | 'start-date' | 'person') => {
    // Nota: La generació del nom del fitxer es farà dins de exportSummariesToPdf
    await exportSummariesToPdf(title, data, dataType, showToast, activeFilters, filteredEventFrames);
  };

  const handleExportCsv = async (dataType: 'event-name' | 'start-date' | 'person', groupKey: string | null = null) => {
    const csvContent = generateDetailedCsv(dataType, groupKey);

    // Utilitza la nova lògica per generar el nom del fitxer
    const prefix = `Resum_Per_${dataType === 'event-name' ? 'Esdeveniment' : (dataType === 'start-date' ? 'Data' : 'Persona')}`;
    const filename = generateFileName(prefix, activeFilters, filteredEventFrames, 'csv');

    await downloadCsv(csvContent, filename);
  };
  
  // --- RENDERITZAT (amb la correcció) ---

  const renderSummaryCard = (title: string, data: Map<string, SummaryRow[]>, dataType: 'event-name' | 'start-date' | 'person', showSortButton: boolean) => (
    <div className="bg-card p-4 rounded-lg border border-border">
      <div className="flex justify-between items-center mb-3 pb-2 border-b border-border">
        <h3 className="text-lg font-semibold text-card-foreground">{title}</h3>
        <div className="flex items-center gap-3">
          {showSortButton && (
            <Tooltip text={`Ordena per data ${summarySortOrder === 'asc' ? 'descendent' : 'ascendent'}`}>
              <button
                onClick={() => setSummarySortOrder(summarySortOrder === 'asc' ? 'desc' : 'asc')}
                className="flex items-center gap-1 px-2 py-1 rounded border border-border bg-secondary text-secondary-foreground hover:bg-accent text-xs font-medium"
              >
                {summarySortOrder === 'asc' ? <ChevronUpIcon className="w-3 h-3" /> : <ChevronDownIcon className="w-3 h-3" />} Ordena
              </button>
            </Tooltip>
          )}
          <div className="flex items-center gap-2">
            <Tooltip text="Exportar a CSV">
              <button
                  onClick={() => handleExportCsv(dataType)}
                  className="p-1.5 rounded-full bg-success/10 text-success hover:bg-success/20"
                  aria-label={`Exportar tot el resum ${title} a CSV`}
              > <CsvIcon className="w-4 h-4" />
              </button>
            </Tooltip>
            <Tooltip text="Exportar a PDF">
              <button
                  onClick={() => handleExportPdf(title, data, dataType)}
                  className="p-1.5 rounded-full bg-primary/10 text-primary hover:bg-primary/20"
                  aria-label={`Exportar tot el resum ${title} a PDF`}
              > <PdfIcon className="w-4 h-4" />
              </button>
            </Tooltip>
          </div>
        </div>
      </div>
      {Array.from(data.entries()).length === 0 ? <p className="text-sm text-muted-foreground">No hi ha dades per aquest resum.</p> : null}
      <div className="space-y-4 max-h-96 overflow-y-auto pr-2"> 
        {Array.from(data.entries()).map(([groupKey, assignments]) => (
          <div key={groupKey}>
            <div className="flex justify-between items-center mb-1 sticky top-0 bg-card/80 backdrop-blur-sm py-1 z-10">
              <h4 className="font-medium text-md text-primary flex-grow">{groupKey}</h4>
              <div className="flex items-center">
                <Tooltip text={`Exportar només "${groupKey}" a CSV`}>
                  <button
                    onClick={() => handleExportCsv(dataType, groupKey)}
                    className="p-1 rounded-full hover:bg-accent flex-shrink-0 ml-2"
                  >
                    <CsvIcon className="w-4 h-4 text-success" />
                  </button>
                </Tooltip>
                <Tooltip text={`Exportar només "${groupKey}" a PDF`}>
                  <button
                    onClick={() => {
                      const singleGroupMap = new Map([[groupKey, assignments]]);
                      handleExportPdf(groupKey, singleGroupMap, dataType);
                    }}
                    className="p-1 rounded-full hover:bg-accent flex-shrink-0 ml-1"
                  >
                    <PdfIcon className="w-4 h-4 text-primary" />
                  </button>
                </Tooltip>
              </div>
            </div>
            <ul className="list-disc list-inside pl-4 space-y-1 text-sm">
              {assignments.map(a => {
                const statusColors: { [key in AssignmentStatus]: string } = {
                  [AssignmentStatus.Yes]: 'text-success',
                  [AssignmentStatus.Pending]: 'text-warning',
                  [AssignmentStatus.No]: 'text-destructive',
                  [AssignmentStatus.Mixed]: 'text-primary',
                };
                
                const getLabel = () => {
                  if (dataType === 'person') return `${a.eventFrameName} (${formatDateRangeDMY(a.assignmentStartDate, a.assignmentEndDate)})`;
                  if (dataType === 'start-date') return `${a.assignmentPersonName} - ${a.eventFrameName}`;
                  return `${a.assignmentPersonName} (${formatDateRangeDMY(a.assignmentStartDate, a.assignmentEndDate)})`;
                };

                return (
                <li key={a.id} className="text-muted-foreground">
                  {getLabel()}
                  {' - '}
                  
                  {a.assignmentStatus === AssignmentStatus.Mixed && a.assignmentObject.dailyStatuses ? (
                    <>
                      <span className={`font-semibold ${statusColors[AssignmentStatus.Mixed]}`}> (Mixt)</span>
                      <ul className="pl-5 mt-1 text-xs list-none">
                        {Object.entries(a.assignmentObject.dailyStatuses)
                          .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())
                          .map(([date, status]) => (
                          <li key={date} className={`font-semibold ${statusColors[status]}`}>
                            {formatDateDMY(date)} - {status}
                          </li>
                        ))}
                      </ul>
                    </>
                  ) : (
                    <span className={`font-semibold ${statusColors[a.assignmentStatus as AssignmentStatus]}`}>
                      ({a.assignmentStatus})
                    </span>
                  )}
                </li>
              )})}
            </ul>
          </div>
        ))}
      </div>
    </div>
  );

  return (
    <div className="grid md:grid-cols-1 lg:grid-cols-3 gap-6">
      {renderSummaryCard("Per Nom d'Esdeveniment", summaryByEventName, "event-name", true)}
      {renderSummaryCard("Per Data d'Inici d'Assignació", summaryByStartDate, "start-date", true)}
      {renderSummaryCard("Per Persona/Grup", summaryByPerson, "person", false)}
    </div>
  );
};

export default SummaryReports;
--- END: ../Gestor-Events_i_Personal/src/components/SummaryReports.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/TechSheetsDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useMemo, lazy, Suspense, useEffect } from 'react';
import { useEventDataStore, selectMaterialControlData } from '../stores/eventDataStore';
import { EventFrame, ShowToastFunction } from '../types';
import Tooltip from './ui/Tooltip';
import CollapsibleSection from './ui/CollapsibleSection';

const TechSheetForm = lazy(() => import('./tech_sheets/TechSheetForm'));

interface TechSheetsDisplayProps {
  showToast: ShowToastFunction;
}

const TechSheetsDisplay: React.FC<TechSheetsDisplayProps> = ({ showToast }) => {
  const eventFrames = useEventDataStore(state => state.eventFrames);
  const fullEventDataStore = useEventDataStore(state => state);
  const [selectedEventFrameId, setSelectedEventFrameId] = useState<string>('');

  useEffect(() => {
    const loadLastViewed = async () => {
      if (window.electronAPI?.getSessionData) {
        const sessionData = await window.electronAPI.getSessionData();
        const lastId = sessionData?.lastViewedTechSheetId;
        if (lastId && eventFrames.some(ef => ef.id === lastId && !ef.isArchived)) {
          setSelectedEventFrameId(lastId);
        }
      }
    };
    loadLastViewed();
  }, [eventFrames]);

  useEffect(() => {
    if (selectedEventFrameId && window.electronAPI?.saveSessionData) {
      window.electronAPI.saveSessionData('lastViewedTechSheetId', selectedEventFrameId);
    }
  }, [selectedEventFrameId]);

  const sortedEventFrames = useMemo(() => {
    return eventFrames
      .filter(ef => !ef.isArchived)
      .sort((a, b) => new Date(b.startDate).getTime() - new Date(a.startDate).getTime());
  }, [eventFrames]);

  const selectedEventFrame = useMemo((): EventFrame | undefined => {
    return eventFrames.find((ef: EventFrame) => ef.id === selectedEventFrameId);
  }, [eventFrames, selectedEventFrameId]);

  const availabilityMap = useMemo(() => {
    if (!selectedEventFrame) {
      return new Map<string, { available: number; total: number }>();
    }

    const controlData = selectMaterialControlData(fullEventDataStore, {
      dateRange: { start: selectedEventFrame.startDate, end: selectedEventFrame.endDate },
    });

    const newMap = new Map<string, { available: number; total: number }>();
    controlData.forEach(row => {
      newMap.set(row.item.id, {
        available: row.item.stock - row.totalDemand,
        total: row.item.stock,
      });
    });

    return newMap;
  }, [selectedEventFrame, fullEventDataStore]);

  useEffect(() => {
    if (selectedEventFrameId && !sortedEventFrames.some(ef => ef.id === selectedEventFrameId)) {
      setSelectedEventFrameId('');
    }
  }, [sortedEventFrames, selectedEventFrameId]);

  return (
    <CollapsibleSection
      title="Gestor de Fitxes de Bolo"
      defaultOpen={true}
    >
      <div className="space-y-4">
        <div className="max-w-md">
          <label htmlFor="event-selector" className="block text-sm font-medium text-muted-foreground">
            Selecciona un esdeveniment per veure o editar la seva fitxa:
          </label>
          <Tooltip text="Llista d'esdeveniments ordenats per data més recent">
            <select
              id="event-selector"
              value={selectedEventFrameId}
              onChange={(e) => setSelectedEventFrameId(e.target.value)}
              className="mt-1 block w-full pl-3 pr-10 py-2 text-base bg-background text-foreground border-border border focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm rounded-md"
            >
              <option value="" disabled>-- Tria un esdeveniment --</option>
              {sortedEventFrames.map((event) => (
                <option key={event.id} value={event.id}>
                  {new Date(event.startDate).toLocaleDateString('ca-ES')} - {event.name}
                </option>
              ))}
            </select>
          </Tooltip>
        </div>

        {selectedEventFrame && selectedEventFrame.techSheet ? (
          <Suspense fallback={<div className="text-center p-8">Carregant formulari...</div>}>
            <TechSheetForm
              key={selectedEventFrame.id}
              eventFrame={selectedEventFrame}
              showToast={showToast}
              availabilityMap={availabilityMap}
            />
          </Suspense>
        ) : (
          selectedEventFrameId && (
            <div className="p-4 text-center text-warning-foreground bg-warning/10 rounded-lg">
              <p>Aquest esdeveniment no té una fitxa tècnica associada. Pot ser de dades antigues. Desa l'esdeveniment per generar-ne una.</p>
            </div>
          )
        )}
      </div>
    </CollapsibleSection>
  );
};

export default TechSheetsDisplay;
--- END: ../Gestor-Events_i_Personal/src/components/TechSheetsDisplay.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/forms/MaterialForm.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useEffect, FormEvent } from 'react';
import { MaterialItem } from '../../types';
import Tooltip from '../ui/Tooltip';
import AutosizeTextarea from '../ui/AutosizeTextarea';

// Defineix les propietats que el component acceptarà
export interface MaterialFormProps {
  initialData?: Partial<MaterialItem>;
  onSubmit: (data: Omit<MaterialItem, 'id'>) => void;
  onCancel?: () => void;
  submitButtonText?: string;
  categories?: string[];
  locations?: string[];
  materialItems?: MaterialItem[]; // Llista completa per a la validació
}

const MaterialForm: React.FC<MaterialFormProps> = ({
  initialData,
  onSubmit,
  onCancel,
  submitButtonText = 'Desar',
  categories = [],
  locations = [],
  materialItems = [],
}) => {
  // Estats interns per als camps del formulari
  const [name, setName] = useState('');
  const [category, setCategory] = useState('');
  const [stock, setStock] = useState(1);
  const [location, setLocation] = useState('');
  const [notes, setNotes] = useState('');
  const [errors, setErrors] = useState<{ [key: string]: string }>({});

  const commonInputClass = "mt-1 block w-full px-3 py-2 bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm";

  // Efecte per omplir el formulari quan initialData canvia (mode edició)
  useEffect(() => {
    if (initialData) {
      setName(initialData.name || '');
      setCategory(initialData.category || '');
      setStock(initialData.stock || 1);
      setLocation(initialData.location || '');
      setNotes(initialData.notes || '');
    } else {
      // Reseteja el formulari si no hi ha dades inicials
      setName('');
      setCategory('');
      setStock(1);
      setLocation('');
      setNotes('');
    }
  }, [initialData]);

  // Funció de validació
  const validate = (): boolean => {
    const newErrors: { [key: string]: string } = {};
    if (!name.trim()) {
        newErrors.name = "El nom és obligatori.";
    } else {
        const isDuplicate = materialItems.some(item =>
            item.name.toLowerCase() === name.trim().toLowerCase() &&
            item.id !== initialData?.id
        );
        if (isDuplicate) {
            newErrors.name = "Ja existeix un material amb aquest nom.";
        }
    }
    if (!category.trim()) newErrors.category = "La categoria és obligatòria.";
    if (stock < 0) newErrors.stock = "L'estoc no pot ser negatiu.";
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Gestor de l'enviament del formulari
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (!validate()) return;

    const itemData = {
      name,
      category,
      stock: Number(stock),
      location,
      notes,
    };
    onSubmit(itemData);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="mat-name" className="block text-sm font-medium text-muted-foreground">Nom</label>
        <Tooltip text="Nom de l'ítem de material">
          <input
            type="text"
            id="mat-name"
            value={name}
            onChange={e => setName(e.target.value)}
            className={commonInputClass}
            required
          />
        </Tooltip>
        {errors.name && <p className="text-destructive text-xs mt-1">{errors.name}</p>}
      </div>

      <div>
        <label htmlFor="mat-category" className="block text-sm font-medium text-muted-foreground">Categoria</label>
        <Tooltip text="Categoria a la que pertany l'ítem">
          <input
            type="text"
            id="mat-category"
            value={category}
            onChange={e => setCategory(e.target.value)}
            className={commonInputClass}
            list="category-suggestions"
            required
          />
        </Tooltip>
        <datalist id="category-suggestions">
          {categories.map((cat: string) => <option key={cat} value={cat} />)}
        </datalist>
        {errors.category && <p className="text-destructive text-xs mt-1">{errors.category}</p>}
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label htmlFor="mat-stock" className="block text-sm font-medium text-muted-foreground">Estoc</label>
          <Tooltip text="Quantitat total d'aquest ítem en inventari">
            <input
              type="number"
              id="mat-stock"
              value={stock}
              onChange={e => setStock(Number(e.target.value))}
              className={commonInputClass}
              min="0"
              required
            />
          </Tooltip>
          {errors.stock && <p className="text-destructive text-xs mt-1">{errors.stock}</p>}
        </div>
        <div>
          <label htmlFor="mat-location" className="block text-sm font-medium text-muted-foreground">Ubicació</label>
          <Tooltip text="On es guarda aquest ítem (opcional)">
            <input
              type="text"
              id="mat-location"
              value={location}
              onChange={e => setLocation(e.target.value)}
              className={commonInputClass}
              list="location-suggestions"
            />
          </Tooltip>
          <datalist id="location-suggestions">
            {locations.map((loc: string) => <option key={loc} value={loc} />)}
          </datalist>
        </div>
      </div>

      <div>
        <label htmlFor="mat-notes" className="block text-sm font-medium text-muted-foreground">Notes</label>
        <Tooltip text="Anotacions addicionals sobre l'ítem (opcional)">
          <AutosizeTextarea
            id="mat-notes"
            value={notes}
            onChange={e => setNotes(e.target.value)}
            className={`${commonInputClass} resize-none overflow-hidden`}
            rows={3}
          />
        </Tooltip>
      </div>

      <div className="flex justify-end space-x-2 pt-2">
        {onCancel && (
          <Tooltip text="Descartar canvis i netejar el formulari">
            <button
              type="button"
              onClick={onCancel}
              className="px-3 py-1.5 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md"
            >
              Cancel·lar
            </button>
          </Tooltip>
        )}
        <Tooltip text={submitButtonText === 'Actualitzar' ? 'Desar els canvis fets a l\'ítem' : 'Afegir el nou ítem a l\'inventari'}>
          <button
            type="submit"
            className="px-3 py-1.5 text-sm font-medium bg-primary text-primary-foreground hover:bg-primary/90 rounded-md"
          >
            {submitButtonText}
          </button>
        </Tooltip>
      </div>
    </form>
  );
};

export default MaterialForm;

--- END: ../Gestor-Events_i_Personal/src/components/forms/MaterialForm.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/AboutModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { ExternalLink } from 'lucide-react';

interface AboutModalProps {
  name: string;
  version: string;
  description: string;
  onClose: () => void;
}

const AboutModal: React.FC<AboutModalProps> = ({ name, version, description, onClose }) => {
  const GITHUB_URL = 'https://github.com/Pepelocotango/Gestor-Events_i_Personal';

  const handleLinkClick = (url: string) => {
    // The main process will handle opening external links.
    // This is configured in main.cjs setWindowOpenHandler
    window.open(url, '_blank');
  };

  return (
    <div className="p-6 bg-card text-card-foreground rounded-lg shadow-lg max-w-md w-full">
      <div className="text-center mb-4">
        <h2 className="text-2xl font-bold text-primary">{name}</h2>
        <p className="text-sm text-muted-foreground">Versió {version}</p>
      </div>

      <div className="my-6 text-center">
        <p className="text-base">{description}</p>
      </div>

      <div className="my-6">
        <h3 className="text-lg font-semibold mb-2 text-center">Enllaços d'Interès</h3>
        <ul className="space-y-2">
          <li>
            <button
              onClick={() => handleLinkClick(GITHUB_URL)}
              className="w-full flex items-center justify-center px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
            >
              <ExternalLink className="w-4 h-4 mr-2" />
              Repositori a GitHub
            </button>
          </li>
          <li>
            <button
              onClick={() => handleLinkClick('https://paypal.me/RosePep')}
              className="w-full flex items-center justify-center px-4 py-2 text-sm font-medium text-primary-foreground bg-primary rounded-md hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
            >
              <ExternalLink className="w-4 h-4 mr-2" />
              Fes una donació a PayPal
            </button>
          </li>
        </ul>
      </div>

      <div className="mt-6 flex justify-end">
        <button
          onClick={onClose}
          className="px-4 py-2 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border"
        >
          Tancar
        </button>
      </div>
    </div>
  );
};

export default AboutModal;

--- END: ../Gestor-Events_i_Personal/src/components/modals/AboutModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/AddMaterialFromTechSheetModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useEffect, useMemo } from 'react';
import { useEventDataStore } from '../../stores/eventDataStore';
import { useModalStore } from '../../stores/modalStore';
import { MaterialItem } from '../../types';
import MaterialForm from '../forms/MaterialForm';

const AddMaterialFromTechSheetModal: React.FC = () => {
  const { addMaterialItem } = useEventDataStore.getState();
  const materialItems = useEventDataStore(state => state.materialItems);
  const { closeModal, data: modalData } = useModalStore();

  const name = modalData?.name;
  const onAdd = modalData?.onAdd;

  // Llista de categories existents per a l'autocompletat
  const categories = useMemo(() => Array.from(new Set(materialItems.map(item => item.category))), [materialItems]);

  // Si les dades necessàries no estan presents, tanca el modal.
  useEffect(() => {
    if (!name || typeof onAdd !== 'function') {
      console.warn('AddMaterialFromTechSheetModal opened with invalid data, closing.');
      closeModal();
    }
  }, [name, onAdd, closeModal]);

  const handleSubmit = (itemData: Omit<MaterialItem, 'id'>) => {
    if (typeof onAdd !== 'function') {
      console.error("Error: onAdd no és una funció. Tancant modal.");
      closeModal();
      return;
    }
    // Assegurem que el nom no es perdi
    const finalData = { ...itemData, name: name || itemData.name };
    const newItem = addMaterialItem(finalData);

    if (newItem) {
      onAdd(newItem);
    }

    closeModal();
  };

  // No renderitzar res si les dades no són vàlides (useEffect s'encarregarà de tancar)
  if (!name || typeof onAdd !== 'function') {
    return null;
  }

  return (
    <div className="p-6 rounded-lg shadow-lg w-full max-w-lg mx-auto">
      <MaterialForm
        initialData={{ name }}
        onSubmit={handleSubmit}
        onCancel={closeModal}
        submitButtonText="Afegir Material"
        categories={categories}
      />
    </div>
  );
};

export default AddMaterialFromTechSheetModal;

--- END: ../Gestor-Events_i_Personal/src/components/modals/AddMaterialFromTechSheetModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/AssignmentFormModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useEffect, FormEvent } from 'react';
import { useEventDataStore } from '../../stores/eventDataStore';
import { Assignment, AssignmentStatus, ShowToastFunction } from '../../types';
import { ASSIGNMENT_STATUS_OPTIONS } from '../../constants';
import { formatDateDMY } from '../../utils/dateFormat';
import Tooltip from '../ui/Tooltip';
import AutosizeTextarea from '../ui/AutosizeTextarea';
import { useModalStore } from '../../stores/modalStore';

interface AssignmentFormModalProps {
  onClose: () => void;
  showToast: ShowToastFunction;
  setExpandedEventFrameId?: (id: string) => void;
}

export const AssignmentFormModal: React.FC<AssignmentFormModalProps> = ({ onClose, showToast, setExpandedEventFrameId }) => {
  const { addAssignment, updateAssignment } = useEventDataStore.getState();
  const peopleGroups = useEventDataStore(state => state.peopleGroups);
  const { data, updateModalData, openModal } = useModalStore();

  const [errors, setErrors] = useState<{ [key: string]: string }>({});

  if (!data || !data.eventFrame) {
    console.error("AssignmentFormModal rendered without necessary eventFrame data from modal store.");
    return null;
  }

  const isEditing = !!data.assignmentToEdit;
  const formData = isEditing ? data.assignmentToEdit! : data;
  const eventFrame = data.eventFrame!;

  const [isEditingMixed, setIsEditingMixed] = useState(isEditing && formData.status === AssignmentStatus.Mixed);

  useEffect(() => {
    // This effect now only resets errors when the modal context changes.
    setErrors({});
  }, [isEditing, data.assignmentToEdit?.id, data.eventFrame?.id]);

  type EditableAssignmentFields = Omit<Assignment, 'id' | 'eventFrameId' | 'dailyStatuses'>;

  const handleFieldChange = (field: keyof EditableAssignmentFields, value: any) => {
    const newFormData = { ...formData, [field]: value };

    if (field === 'status' && isEditingMixed) {
        setIsEditingMixed(false);
    }

    if (isEditing) {
      updateModalData({ assignmentToEdit: newFormData as Assignment });
    } else {
      updateModalData({ [field]: value });
    }
  };

  const validate = (): boolean => {
    const newErrors: { [key: string]: string } = {};
    if (!formData.personGroupId) newErrors.personGroupId = "Cal seleccionar una persona o grup.";
    if (!formData.startDate) newErrors.startDate = "La data d'inici és obligatòria.";
    if (!formData.endDate) newErrors.endDate = "La data de fi és obligatòria.";

    if (formData.startDate && formData.endDate) {
      if (new Date(formData.startDate) > new Date(formData.endDate)) {
        newErrors.endDate = "La data de fi ha de ser posterior o igual a la data d'inici.";
      }
      if (new Date(formData.startDate) < new Date(eventFrame.startDate) || new Date(formData.endDate) > new Date(eventFrame.endDate)) {
        newErrors.datesRange = `Les dates han d'estar dins del rang del marc (${formatDateDMY(eventFrame.startDate)} - ${formatDateDMY(eventFrame.endDate)}).`;
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const performSubmit = (force = false) => {
    if (!validate()) return;

    const handleResult = (result: { success: boolean; message?: string; warningMessage?: string }) => {
      if (result.success) {
        if (result.warningMessage && result.warningMessage.startsWith('DUPLICATE_CONFLICT:')) {
          openModal('confirmDuplicate', {
            message: result.warningMessage.replace('DUPLICATE_CONFLICT:', ''),
            onConfirm: () => performSubmit(true),
          });
        } else {
          if (result.warningMessage) showToast(result.warningMessage, 'warning');
          showToast(isEditing ? "Assignació actualitzada." : "Assignació afegida.", 'success');
          if (!isEditing && setExpandedEventFrameId) setExpandedEventFrameId(eventFrame.id);
          onClose();
        }
      } else if (result.message) {
        showToast(`Error: ${result.message}`, 'error');
      }
    };

    if (isEditing) {
        let updatedData: Assignment = { ...formData } as Assignment;

        if (isEditingMixed && formData.status !== AssignmentStatus.Pending) {
          updatedData.status = formData.status!;
          updatedData.dailyStatuses = undefined;
        } else if (isEditingMixed) {
          updatedData.status = AssignmentStatus.Mixed;
        }

        const result = updateAssignment(updatedData, force);
        handleResult(result);
    } else {
      const assignmentData = {
          personGroupId: formData.personGroupId!,
          startDate: formData.startDate!,
          endDate: formData.endDate!,
          status: formData.status!,
          notes: formData.notes!
      };
      const result = addAssignment(eventFrame.id, assignmentData, force);
      handleResult(result);
    }
  };

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    performSubmit(false);
  };

  const commonInputClass = "mt-1 block w-full px-3 py-2 bg-input border border-border rounded-md focus:outline-none focus:ring-1 focus:ring-ring focus:border-primary sm:text-sm disabled:opacity-50";

  const statusValue = isEditingMixed ? AssignmentStatus.Pending : formData.status;

  return (
    <form onSubmit={handleSubmit} className="space-y-4" aria-labelledby="assignment-form-title">
      <h2 id="assignment-form-title" className="sr-only">{isEditing ? 'Formulari Edició Assignació' : 'Formulari Nova Assignació'} per {eventFrame.name}</h2>
      {isEditingMixed && (
        <div className="p-3 bg-info/10 border-l-4 border-info rounded">
          <p className="text-sm text-info-foreground">
            Aquesta assignació té estats diaris personalitzats. Canviar l'estat aquí sobreescriurà tots els estats diaris amb el nou valor seleccionat.
          </p>
        </div>
      )}
      <div>
        <label htmlFor="as-person" className="block text-sm font-medium text-muted-foreground">Persona/Grup</label>
        <Tooltip text="Seleccionar la persona o grup a assignar">
          <select
            id="as-person"
            value={formData.personGroupId || ''}
            onChange={e => handleFieldChange('personGroupId', e.target.value)}
            className={commonInputClass}
            required
            disabled={peopleGroups.length === 0}
          >
            {peopleGroups.length === 0 ? <option value="" disabled>No hi ha persones/grups</option> :
              <>
                <option value="" disabled>Selecciona una persona o grup</option>
                {peopleGroups.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}
              </>
            }
          </select>
        </Tooltip>
        {errors.personGroupId && <p className="text-destructive text-xs mt-1">{errors.personGroupId}</p>}
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label htmlFor="as-startDate" className="block text-sm font-medium text-muted-foreground">Data d'Inici</label>
          <Tooltip text="Data d'inici de l'assignació">
            <input
              type="date"
              id="as-startDate"
              value={formData.startDate || ''}
              onChange={e => handleFieldChange('startDate', e.target.value)}
              className={commonInputClass}
              required
            />
          </Tooltip>
          {formData.startDate && <p className="text-xs text-primary mt-1"><span className="font-semibold">Data seleccionada:</span> {formatDateDMY(formData.startDate)}</p>}
          {errors.startDate && <p className="text-destructive text-xs mt-1">{errors.startDate}</p>}
        </div>
        <div>
          <label htmlFor="as-endDate" className="block text-sm font-medium text-muted-foreground">Data de Fi</label>
          <Tooltip text="Data de fi de l'assignació">
            <input
              type="date"
              id="as-endDate"
              value={formData.endDate || ''}
              onChange={e => handleFieldChange('endDate', e.target.value)}
              className={commonInputClass}
              required
            />
          </Tooltip>
          {formData.endDate && <p className="text-xs text-primary mt-1"><span className="font-semibold">Data seleccionada:</span> {formatDateDMY(formData.endDate)}</p>}
          {errors.endDate && <p className="text-destructive text-xs mt-1">{errors.endDate}</p>}
        </div>
      </div>
      {errors.datesRange && <p className="text-destructive text-xs text-center -mt-2">{errors.datesRange}</p>}
      <div>
        <label htmlFor="as-status" className="block text-sm font-medium text-muted-foreground">Estat</label>
        <Tooltip text="Estat general de l'assignació">
          <select
            id="as-status"
            value={statusValue || ''}
            onChange={e => handleFieldChange('status', e.target.value as AssignmentStatus)}
            className={commonInputClass}
          >
            {ASSIGNMENT_STATUS_OPTIONS.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
          </select>
        </Tooltip>
      </div>
      <div>
        <label htmlFor="as-notes" className="block text-sm font-medium text-muted-foreground">Notes (Opcional)</label>
        <AutosizeTextarea
            id="as-notes"
            value={formData.notes || ''}
            onChange={e => handleFieldChange('notes', e.target.value)}
            rows={3}
            className={`${commonInputClass} resize-none overflow-hidden`}
        />
      </div>
      <div className="flex justify-end space-x-3 pt-4">
        <Tooltip text="Tancar el formulari sense desar canvis">
          <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium rounded-md border bg-secondary text-secondary-foreground hover:bg-secondary/80">Cancel·lar</button>
        </Tooltip>
        <Tooltip text={isEditing ? 'Desar els canvis de l\'assignació' : 'Crear la nova assignació'}>
          <button type="submit" className="px-4 py-2 text-sm font-medium rounded-md bg-primary text-primary-foreground hover:bg-primary/90 disabled:opacity-50" disabled={peopleGroups.length === 0 && !isEditing}>{isEditing ? 'Actualitzar' : 'Crear'}</button>
        </Tooltip>
      </div>
    </form>
  );
};

export default AssignmentFormModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/AssignmentFormModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/ConfirmDeleteModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState } from 'react';
import { ShowToastFunction } from '../../types';
import Tooltip from '../ui/Tooltip';

interface CommonFormProps {
  onClose: () => void;
  showToast: ShowToastFunction;
}

interface ConfirmDeleteProps extends CommonFormProps {
  itemType: string;
  itemName: string;
  onConfirm?: (inputValue?: string) => void;
  titleOverride?: string;
  confirmButtonText?: string;
  cancelButtonText?: string;
  onCloseModal?: () => void;
  requiresInput?: boolean;
  suppressSuccessToast?: boolean;
  intent?: 'destructive' | 'constructive';
}

export const ConfirmDeleteModal: React.FC<ConfirmDeleteProps> = ({
  onClose,
  itemType,
  itemName,
  onConfirm,
  showToast,
  confirmButtonText = "Eliminar",
  cancelButtonText = "Cancel·lar",
  onCloseModal,
  requiresInput = false,
  suppressSuccessToast = false,
  intent,
}) => {
  const [inputValue, setInputValue] = useState('');

  const handleConfirm = () => {
    if (requiresInput && !inputValue.trim()) {
      showToast('El camp no pot estar buit.', 'warning');
      return;
    }
    if (onConfirm) {
      onConfirm(inputValue);
    }

    if (!suppressSuccessToast) {
        showToast(`${itemType} eliminat/da correctament.`, 'success');
    }

    onClose();
  };

  const handleCancelClick = () => {
    if (onCloseModal) {
      onCloseModal();
    }
    onClose();
  };

  return (
    <div>
      <div className="text-foreground" dangerouslySetInnerHTML={{ __html: itemName }} />

      {requiresInput && (
        <div className="mt-4">
          <Tooltip text="Introdueix el text de confirmació requerit">
            <input
              type="text"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              className="mt-1 block w-full px-3 py-2 bg-background border border-border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-ring sm:text-sm"
              autoFocus
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  e.preventDefault();
                  handleConfirm();
                }
              }}
            />
          </Tooltip>
        </div>
      )}

      <div className="flex justify-end space-x-3 mt-6">
        <Tooltip text="Tancar aquest diàleg i cancel·lar l'acció">
          <button
            onClick={handleCancelClick}
            className="px-4 py-2 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border"
          >
            {cancelButtonText}
          </button>
        </Tooltip>
        <Tooltip text="Confirmar i executar l'acció">
          <button
            onClick={handleConfirm}
            className={`px-4 py-2 text-sm font-medium rounded-md ${
              intent === 'destructive'
                ? "bg-destructive text-destructive-foreground hover:bg-destructive/90"
                : "bg-primary text-primary-foreground hover:bg-primary/90"
            }`}
          >
            {confirmButtonText}
          </button>
        </Tooltip>
      </div>
    </div>
  );
};

export default ConfirmDeleteModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/ConfirmDeleteModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/ConfirmDuplicateModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import Tooltip from '../ui/Tooltip';

interface ConfirmDuplicateModalProps {
  onClose: () => void;
  onConfirm: () => void;
  message: string;
}

export const ConfirmDuplicateModal: React.FC<ConfirmDuplicateModalProps> = ({
  onClose,
  onConfirm,
  message,
}) => {
  const handleConfirm = () => {
    onConfirm();
    onClose();
  };

  return (
    <div>
      <p className="text-muted-foreground">{message}</p>
      <p className="text-muted-foreground mt-2">Vols crear l'assignació duplicada de totes maneres?</p>

      <div className="flex justify-end space-x-3 mt-6">
        <Tooltip text="Tancar aquest diàleg i cancel·lar l'acció">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border"
          >
            Cancel·lar
          </button>
        </Tooltip>
        <Tooltip text="Confirmar i crear l'assignació duplicada">
          <button
            onClick={handleConfirm}
            className="px-4 py-2 text-sm font-medium text-warning-foreground bg-warning hover:bg-warning/90 rounded-md"
          >
            Confirmar Duplicat
          </button>
        </Tooltip>
      </div>
    </div>
  );
};

export default ConfirmDuplicateModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/ConfirmDuplicateModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/ConfirmRepairModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import Modal from '../ui/Modal';

interface ConfirmRepairModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  fixes: string[];
}

const ConfirmRepairModal: React.FC<ConfirmRepairModalProps> = ({
  isOpen,
  onClose,
  onConfirm,
  fixes,
}) => {
  return (
    <Modal isOpen={isOpen} onClose={onClose} title="S'han detectat i reparat errors a les dades">
      <div className="p-4">
        <p className="text-sm text-muted-foreground mb-4">
          S'han trobat algunes inconsistències a l'arxiu de dades que s'han corregit automàticament. Si us plau, revisa els canvis. Vols carregar la versió reparada?
        </p>

        <div className="mb-4 p-3 bg-muted/50 rounded-md max-h-48 overflow-y-auto">
          <h4 className="font-semibold text-foreground mb-2">Correccions aplicades:</h4>
          <ul className="list-disc list-inside space-y-1 text-sm text-muted-foreground">
            {fixes.map((fix, index) => (
              <li key={index}>{fix}</li>
            ))}
          </ul>
        </div>

        <div className="flex justify-end gap-3 mt-6">
          <button
            type="button"
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium rounded-md border bg-secondary text-secondary-foreground hover:bg-secondary/80"
          >
            Cancel·lar
          </button>
          <button
            type="button"
            onClick={() => {
              onConfirm();
              onClose();
            }}
            className="px-4 py-2 text-sm font-medium rounded-md bg-primary text-primary-foreground hover:bg-primary/90"
          >
            Carregar Versió Reparada
          </button>
        </div>
      </div>
    </Modal>
  );
};

export default ConfirmRepairModal;

--- END: ../Gestor-Events_i_Personal/src/components/modals/ConfirmRepairModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/CreateCalendarModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState } from 'react';
import { ShowToastFunction } from '@/types';
import { createNewCalendar } from '@/stores/googleConfigStore';
import Tooltip from '../ui/Tooltip';

interface CreateCalendarModalProps {
  onClose: () => void;
  showToast: ShowToastFunction;
}

const CreateCalendarModal: React.FC<CreateCalendarModalProps> = ({ onClose, showToast }) => {
  const [suffix, setSuffix] = useState('');
  const [isCreating, setIsCreating] = useState(false);

  const handleCreate = async () => {
    if (!suffix.trim()) {
      showToast('El sufix no pot estar buit.', 'warning');
      return;
    }
    setIsCreating(true);
    try {
      const result = await createNewCalendar(suffix.trim());
      if (result) {
        showToast(result.message, result.type);
        if (result.success) {
          onClose();
        }
      }
    } catch (err) {
      showToast((err as Error).message, 'error');
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <div className="space-y-4">
      <div>
        <h3 className="text-lg font-medium text-foreground">Crear Nou Calendari de l'App</h3>
        <p className="mt-1 text-sm text-muted-foreground">
          Introdueix un sufix únic per al nou calendari (ex: Teatre Principal). Aquest sufix s'afegirà al nom base "Gestor d'Esdeveniments (App)".
        </p>
      </div>

      <div>
        <label htmlFor="calendar-suffix" className="block text-sm font-medium text-muted-foreground">
          Sufix del Calendari
        </label>
        <Tooltip text="Sufix que s'afegirà al nom del calendari. Ha de ser únic.">
          <input
            type="text"
            id="calendar-suffix"
            value={suffix}
            onChange={(e) => setSuffix(e.target.value)}
            className="mt-1 block w-full px-3 py-2 bg-input border border-border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-ring focus:border-primary sm:text-sm"
            placeholder="Ex: Teatre Principal"
            autoFocus
            onKeyDown={(e) => {
              if (e.key === 'Enter') {
                handleCreate();
              }
            }}
          />
        </Tooltip>
      </div>

      <div className="flex justify-end space-x-2 pt-4 border-t border-border">
        <Tooltip text="Tancar sense crear un nou calendari">
          <button
            onClick={onClose}
            disabled={isCreating}
            className="px-4 py-2 text-sm font-medium rounded-md border bg-secondary text-secondary-foreground hover:bg-secondary/80 disabled:opacity-50"
          >
            Cancel·lar
          </button>
        </Tooltip>
        <Tooltip text="Crear un nou calendari a Google Calendar amb el sufix especificat">
          <button
            onClick={handleCreate}
            disabled={isCreating}
            className="px-4 py-2 text-sm font-medium rounded-md bg-primary text-primary-foreground hover:bg-primary/90 disabled:opacity-50"
          >
            {isCreating ? 'Creant...' : 'Crear Calendari'}
          </button>
        </Tooltip>
      </div>
    </div>
  );
};

export default CreateCalendarModal;

--- END: ../Gestor-Events_i_Personal/src/components/modals/CreateCalendarModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/EventFrameDetailsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import logger from '../../utils/logger';
import { useEventDataStore } from '../../stores/eventDataStore';
import { useModalStore } from '../../stores/modalStore';
import { EventFrame, AssignmentStatus, ShowToastFunction } from '../../types';
import { formatDateDMY, formatDateRangeDMY } from '../../utils/dateFormat';
import { getStatusSummaryText } from '../../utils/statusUtils';
import Tooltip from '../ui/Tooltip';

interface CommonFormProps {
  onClose: () => void;
  showToast: ShowToastFunction;
}

interface EventFrameDetailsModalProps extends CommonFormProps {
  eventFrame: EventFrame;
}

export const EventFrameDetailsModal: React.FC<EventFrameDetailsModalProps> = ({ onClose, eventFrame }) => {
  const { peopleGroups } = useEventDataStore.getState();
  const { openModal } = useModalStore.getState();

  const handleDeleteClick = () => {
    openModal('confirmDeleteEventFrame', {
      itemType: "Marc d'Esdeveniment",
      itemName: eventFrame.name,
      itemId: eventFrame.id,
    });
  };

  return (
    <div className="space-y-4">
      <div>
        <h4 className="text-xl font-bold text-foreground">{eventFrame.name}</h4>
        {eventFrame.place && <p className="text-sm text-muted-foreground">{eventFrame.place}</p>}
        <p className="text-sm text-muted-foreground">
          {eventFrame.startDate === eventFrame.endDate
            ? formatDateDMY(eventFrame.startDate)
            : formatDateRangeDMY(eventFrame.startDate, eventFrame.endDate)}
        </p>
      </div>
      {eventFrame.generalNotes && (
        <div>
          <h5 className="font-semibold text-foreground">Notes Generals:</h5>
          <p className="text-sm text-foreground whitespace-pre-wrap p-2 bg-muted rounded">{eventFrame.generalNotes}</p>
        </div>
      )}

      <div>
        <h5 className="font-semibold text-foreground">Assignacions ({eventFrame.assignments.length}):</h5>
        {eventFrame.assignments.length > 0 ? (
          <ul className="list-disc list-inside space-y-1 pl-2 text-sm max-h-60 overflow-y-auto">
            {[...eventFrame.assignments]
              .sort((a, b) => (peopleGroups.find(p => p.id === a.personGroupId)?.name || '').localeCompare(peopleGroups.find(p => p.id === b.personGroupId)?.name || ''))
              .map(assign => {
              const person = peopleGroups.find(p => p.id === assign.personGroupId);
              let statusColor = 'text-warning';
              if (assign.status === AssignmentStatus.Yes) statusColor = 'text-success';
              if (assign.status === AssignmentStatus.No) statusColor = 'text-destructive';
              if (assign.status === AssignmentStatus.Mixed) statusColor = 'text-info';
              return (
                <li key={assign.id} className="text-muted-foreground py-1">
                  <strong className="text-foreground">{person?.name || 'N/A'}</strong>: {assign.startDate === assign.endDate ? formatDateDMY(assign.startDate) : formatDateRangeDMY(assign.startDate, assign.endDate)} <span className={`${statusColor} font-semibold`}>{getStatusSummaryText(assign)}</span>
                  {assign.notes && <span className="block text-xs italic pl-4 text-muted-foreground mt-0.5">Nota: {assign.notes}</span>}
                </li>
              );
            })}
          </ul>
        ) : (
          <p className="text-sm text-muted-foreground">No hi ha assignacions per aquest esdeveniment.</p>
        )}
      </div>
      
      <div className="flex justify-between items-center pt-4 mt-4 border-t border-border">
        <Tooltip text="Ressaltar aquest marc a la llista principal">
          <button
            onClick={() => {
              logger.info(`[EventFrameDetailsModal] "Mostrar a la Llista" clicked for EventFrame ID: ${eventFrame.id}. Calling showAndHighlightEvent...`);
              useEventDataStore.getState().showAndHighlightEvent(eventFrame.id);
            }}
            className="px-4 py-2 text-sm font-medium bg-primary text-primary-foreground hover:bg-primary/90 rounded-md focus:outline-none focus:ring-2 focus:ring-ring focus:ring-opacity-50"
          >
            Mostrar a la Llista
          </button>
        </Tooltip>
        <div className="space-x-2">
          <Tooltip text="Obrir el formulari per editar els detalls d'aquest marc">
            <button
                onClick={() => openModal('editEventFrame', { eventFrameToEdit: eventFrame })}
              className="px-4 py-2 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md focus:outline-none focus:ring-2 focus:ring-ring focus:ring-opacity-50"
            >
              Editar Marc
            </button>
          </Tooltip>
          <Tooltip text="Eliminar aquest marc d'esdeveniment i totes les seves assignacions">
            <button
              onClick={handleDeleteClick}
              className="px-4 py-2 text-sm font-medium bg-destructive text-destructive-foreground hover:bg-destructive/90 rounded-md focus:outline-none focus:ring-2 focus:ring-ring focus:ring-opacity-50"
            >
              Eliminar Marc
            </button>
          </Tooltip>
          <Tooltip text="Tancar aquesta finestra de detalls">
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border focus:outline-none focus:ring-2 focus:ring-ring focus:ring-opacity-50"
            >
              Tancar
            </button>
          </Tooltip>
        </div>
      </div>
    </div>
  );
};

export default EventFrameDetailsModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/EventFrameDetailsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/EventFrameFormModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useEffect, FormEvent } from 'react';
import { useEventDataStore } from '../../stores/eventDataStore';
import { EventFrame, ShowToastFunction, AssignmentStatus } from '../../types';
import { formatDateDMY } from '../../utils/dateFormat';
import Tooltip from '../ui/Tooltip';
import { useModalStore } from '../../stores/modalStore';
import AutosizeTextarea from '../ui/AutosizeTextarea';

interface EventFrameFormModalProps {
  onClose: () => void;
  showToast: ShowToastFunction;
}

export const EventFrameFormModal: React.FC<EventFrameFormModalProps> = ({ onClose, showToast }) => {
  const { addEventFrame, updateEventFrame, showAndHighlightEvent } = useEventDataStore.getState();
  const eventFrames = useEventDataStore(state => state.eventFrames);
  const { data, updateModalData, openModal } = useModalStore();

  const [errors, setErrors] = useState<{ [key: string]: string }>({});
  const [eventNameDatalistId] = useState(() => `event-name-datalist-${Math.random().toString(36).substring(2, 9)}`);
  const [locationDatalistId] = useState(() => `location-datalist-${Math.random().toString(36).substring(2, 9)}`);

  if (!data) {
    return null; // Should not happen if modal is open
  }

  const isEditing = !!data.eventFrameToEdit;
  const formData = isEditing ? data.eventFrameToEdit! : data;

  useEffect(() => {
    setErrors({});
  }, [isEditing, data.eventFrameToEdit?.id]);

  type EditableEventFrameFields = Omit<EventFrame, 'id' | 'assignments' | 'personnelComplete' | 'techSheet' | 'googleEventId' | 'googleCalendarId' | 'lastModified' | 'lastSync'>;

  const handleFieldChange = (field: keyof EditableEventFrameFields, value: any) => {
    const newFormData = { ...formData, [field]: value };
    if (isEditing) {
      updateModalData({ eventFrameToEdit: newFormData as EventFrame });
    } else {
      updateModalData({ [field]: value });
    }
  };

  const validate = (): boolean => {
    const newErrors: { [key: string]: string } = {};
    if (!formData.name?.trim()) newErrors.name = "El nom és obligatori.";
    if (!formData.startDate) newErrors.startDate = "La data d'inici és obligatòria.";
    if (!formData.endDate) newErrors.endDate = "La data de fi és obligatòria.";
    if (formData.startDate && formData.endDate && new Date(formData.startDate) > new Date(formData.endDate)) {
      newErrors.endDate = "La data de fi ha de ser posterior o igual a la data d'inici.";
    }
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (!validate()) return;

    const eventData = { name: formData.name!, place: formData.place || '', startDate: formData.startDate!, endDate: formData.endDate!, generalNotes: formData.generalNotes || '' };
    if (isEditing) {
      updateEventFrame({ ...data.eventFrameToEdit, ...eventData } as EventFrame);
      showToast("Marc d'esdeveniment actualitzat.", 'success');
    } else {
      addEventFrame(eventData);
      showToast("Marc d'esdeveniment afegit.", 'success');
    }
    onClose();
  };

   const handleCreateAndAssign = () => {
    if (!validate()) return;
    const peopleGroups = useEventDataStore.getState().peopleGroups;

    if (isEditing) {
      onClose();
      // Since it's already created, we can just open the assignment modal
      openModal('addAssignment', { eventFrame: data.eventFrameToEdit as EventFrame });
    } else {
      const eventData = { name: formData.name!, place: formData.place || '', startDate: formData.startDate!, endDate: formData.endDate!, generalNotes: formData.generalNotes || '' };
      const newEventFrame: EventFrame = addEventFrame(eventData); 
      showToast("Marc d'esdeveniment afegit.", 'success');
      onClose(); 
      openModal('addAssignment', {
        eventFrame: newEventFrame,
        // Pre-fill assignment form as well
        personGroupId: peopleGroups[0]?.id || '',
        startDate: newEventFrame.startDate,
        endDate: newEventFrame.endDate,
        status: AssignmentStatus.Pending,
        notes: '',
      });
    }
  };
  const commonInputClass = "mt-1 block w-full px-2 py-1 bg-input text-foreground border border-border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-ring focus:border-ring sm:text-sm disabled:opacity-50";
  
  const uniqueEventNames = Array.from(new Set(eventFrames.map(ef => ef.name).filter(Boolean)));
  const uniqueLocations = Array.from(new Set(eventFrames.map(ef => ef.place).filter(Boolean)));

  return (
    <form onSubmit={handleSubmit} className="space-y-3" aria-labelledby="event-frame-form-title" id="event-frame-form-modal-actual-form">
      <h2 id="event-frame-form-title" className="sr-only">{isEditing ? 'Formulari Edició Marc Esdeveniment' : 'Formulari Nou Marc Esdeveniment'}</h2>
      <div>
        <label htmlFor="ef-name" className="block text-sm font-medium text-foreground">Nom de l'Esdeveniment</label>
        <Tooltip text="Nom principal de l'esdeveniment">
          <input type="text" id="ef-name" value={formData.name || ''} onChange={e => handleFieldChange('name', e.target.value)} className={commonInputClass} required aria-required="true" list={eventNameDatalistId}/>
        </Tooltip>
        <datalist id={eventNameDatalistId}>
            {uniqueEventNames.map(n => <option key={n} value={n} />)}
        </datalist>
        {errors.name && <p className="text-destructive text-xs mt-1" role="alert">{errors.name}</p>}
      </div>
      <div>
        <label htmlFor="ef-place" className="block text-sm font-medium text-foreground">Lloc (Opcional)</label>
        <Tooltip text="Ubicació o lloc de l'esdeveniment">
          <input type="text" id="ef-place" value={formData.place || ''} onChange={e => handleFieldChange('place', e.target.value)} className={commonInputClass} list={locationDatalistId} />
        </Tooltip>
        <datalist id={locationDatalistId}>
            {uniqueLocations.map(loc => <option key={loc} value={loc} />)}
        </datalist>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
        <div>
          <label htmlFor="ef-startDate" className="block text-sm font-medium text-foreground">Data d'Inici</label>
          <Tooltip text="Data d'inici del marc d'esdeveniment">
            <input type="date" id="ef-startDate" value={formData.startDate || ''} onChange={e => handleFieldChange('startDate', e.target.value)} className={commonInputClass} required aria-required="true" placeholder="dd/mm/yyyy" />
          </Tooltip>
          {formData.startDate && <p className="text-xs text-muted-foreground mt-1"><span className="font-semibold">Data seleccionada:</span> {formatDateDMY(formData.startDate)}</p>}
          {errors.startDate && <p className="text-destructive text-xs mt-1" role="alert">{errors.startDate}</p>}
        </div>
        <div>
          <label htmlFor="ef-endDate" className="block text-sm font-medium text-foreground">Data de Fi</label>
          <Tooltip text="Data de fi del marc d'esdeveniment">
            <input type="date" id="ef-endDate" value={formData.endDate || ''} onChange={e => handleFieldChange('endDate', e.target.value)} className={commonInputClass} required aria-required="true" placeholder="dd/mm/yyyy" />
          </Tooltip>
          {formData.endDate && <p className="text-xs text-muted-foreground mt-1"><span className="font-semibold">Data seleccionada:</span> {formatDateDMY(formData.endDate)}</p>}
          {errors.endDate && <p className="text-destructive text-xs mt-1" role="alert">{errors.endDate}</p>}
        </div>
      </div>
      <div>
        <label htmlFor="ef-generalNotes" className="block text-sm font-medium text-foreground">Notes Generals (Opcional)</label>
        <Tooltip text="Anotacions generals sobre l'esdeveniment">
          <AutosizeTextarea id="ef-generalNotes" value={formData.generalNotes || ''} onChange={e => handleFieldChange('generalNotes', e.target.value)} rows={3} className={`${commonInputClass} resize-none overflow-hidden`} />
        </Tooltip>
      </div>
      <div className="flex justify-between items-center pt-2">
        <div>
          {isEditing && (
            <Tooltip text="Ressaltar aquest marc a la llista principal">
              <button
                type="button"
                onClick={() => {
                  if (data.eventFrameToEdit?.id) {
                    showAndHighlightEvent(data.eventFrameToEdit.id);
                  }
                  // No tanquem el modal per evitar condicions de cursa
                }}
                className="px-3 py-1 text-sm font-medium bg-primary text-primary-foreground hover:bg-primary/90 rounded-md"
              >
                Mostrar a la llista
              </button>
            </Tooltip>
          )}
        </div>
        <div className="flex justify-end space-x-2">
          <Tooltip text="Tancar el formulari sense desar">
            <button type="button" onClick={onClose} className="px-3 py-1 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border">Cancel·lar</button>
          </Tooltip>
          {!isEditing && (
            <Tooltip text="Crear el marc i obrir directament el formulari d'assignació">
              <button
                type="button"
                onClick={handleCreateAndAssign}
                className="px-3 py-1 text-sm font-medium bg-success text-success-foreground hover:bg-success/90 rounded-md"
              >
                Crear i Assignar
              </button>
            </Tooltip>
          )}
          <Tooltip text={isEditing ? 'Desar els canvis del marc' : 'Crear el nou marc d\'esdeveniment'}>
            <button type="submit" className="px-3 py-1 text-sm font-medium bg-primary text-primary-foreground hover:bg-primary/90 rounded-md">{isEditing ? 'Actualitzar' : 'Crear'}</button>
          </Tooltip>
        </div>
      </div>
    </form>
  );
};

export default EventFrameFormModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/EventFrameFormModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/GoogleEventDetailsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { useModalStore } from '../../stores/modalStore';
import { CalendarIcon, UsersIcon } from '../../constants';
import { MapPinIcon, VideoCameraIcon, ArrowTopRightOnSquareIcon } from '@heroicons/react/24/outline';

const GoogleEventDetailsModal: React.FC = () => {
  const data = useModalStore(state => state.data);
const closeModal = useModalStore(state => state.closeModal);


  const event = data?.eventData;

  if (!event) {
    return (
      <div className="p-4 text-center">
        <p className="text-destructive">No s'han pogut carregar les dades de l'esdeveniment.</p>
        <button onClick={closeModal} className="mt-4 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90">
          Tancar
        </button>
      </div>
    );
  }

  const formatDateTime = (dateTimeStr: string) => {
    return new Date(dateTimeStr).toLocaleString('ca-ES', {
      year: 'numeric', month: 'long', day: 'numeric',
      hour: '2-digit', minute: '2-digit', timeZone: 'Europe/Madrid'
    });
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    // Afegim un dia perquè els esdeveniments "all-day" de Google acaben el dia següent a les 00:00
    const correctedDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000);
    return correctedDate.toLocaleDateString('ca-ES', {
      year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC'
    });
  };

  const renderDescription = (description: string) => {
    if (!description) return <p className="text-muted-foreground">No hi ha descripció.</p>;
    // Substituïm els salts de línia \n per elements <br>
    return <p className="text-sm whitespace-pre-wrap" dangerouslySetInnerHTML={{ __html: description }} />;
  };

  const renderAttendees = (attendees: any[]) => {
    if (!attendees || attendees.length === 0) {
      return <p className="text-muted-foreground">No hi ha assistents.</p>;
    }
    return (
      <ul className="space-y-2">
        {attendees.map((attendee, index) => (
          <li key={index} className="flex items-center justify-between text-sm">
            <span className="truncate">{attendee.displayName || attendee.email}</span>
            <span className={`px-2 py-0.5 text-xs rounded-full ${
              attendee.responseStatus === 'accepted' ? 'bg-success text-success-foreground' :
              attendee.responseStatus === 'declined' ? 'bg-destructive text-destructive-foreground' :
              attendee.responseStatus === 'tentative' ? 'bg-yellow-500 text-white' :
              'bg-muted text-muted-foreground'
            }`}>
              {attendee.responseStatus}
            </span>
          </li>
        ))}
      </ul>
    );
  };

  const isAllDay = event.start.date;

  return (
    <div className="p-1 max-h-[80vh] overflow-y-auto">
      <div className="space-y-3">
        {/* Títol */}
        <h2 className="text-xl font-bold text-foreground">{event.summary || 'Esdeveniment sense títol'}</h2>

        {/* Data i Hora */}
        <div className="flex items-start space-x-3">
          <CalendarIcon className="h-5 w-5 text-muted-foreground mt-1" />
          <div>
            <h3 className="font-semibold text-foreground">Data i Hora</h3>
            {isAllDay ? (
              <p className="text-sm">{`${formatDate(event.start.date)} (Tot el dia)`}</p>
            ) : (
              <p className="text-sm">{`${formatDateTime(event.start.dateTime)} - ${formatDateTime(event.end.dateTime)}`}</p>
            )}
          </div>
        </div>

        {/* Ubicació */}
        {event.location && (
          <div className="flex items-start space-x-3">
            <MapPinIcon className="h-5 w-5 text-muted-foreground mt-1" />
            <div>
              <h3 className="font-semibold text-foreground">Ubicació</h3>
              <p className="text-sm">{event.location}</p>
            </div>
          </div>
        )}

        {/* Videoconferència */}
        {event.hangoutLink && (
          <div className="flex items-start space-x-3">
            <VideoCameraIcon className="h-5 w-5 text-muted-foreground mt-1" />
            <div>
              <h3 className="font-semibold text-foreground">Videoconferència</h3>
              <a href={event.hangoutLink} target="_blank" rel="noopener noreferrer" className="text-sm text-primary hover:underline break-all">
                {event.hangoutLink}
              </a>
            </div>
          </div>
        )}

        {/* Enllaç a Google Calendar */}
         <div className="flex items-start space-x-3">
            <ArrowTopRightOnSquareIcon className="h-5 w-5 text-muted-foreground mt-1" />
            <div>
              <h3 className="font-semibold text-foreground">Veure a Google Calendar</h3>
              <a href={event.htmlLink} target="_blank" rel="noopener noreferrer" className="text-sm text-primary hover:underline">
                Obrir en una nova pestanya
              </a>
            </div>
          </div>


        {/* Descripció */}
        <div>
          <h3 className="font-semibold text-foreground mb-1">Descripció</h3>
          <div className="p-2 bg-muted rounded-md max-h-48 overflow-y-auto">
            {renderDescription(event.description)}
          </div>
        </div>

        {/* Assistents */}
        <div className="flex items-start space-x-3">
            <UsersIcon className="h-5 w-5 text-muted-foreground mt-1" />
            <div className="w-full">
              <h3 className="font-semibold text-foreground">Assistents</h3>
              <div className="p-2 bg-muted rounded-md max-h-48 overflow-y-auto mt-1">
                {renderAttendees(event.attendees)}
              </div>
            </div>
        </div>
      </div>

      <div className="mt-4 flex justify-end">
        <button onClick={closeModal} className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90">
          Tancar
        </button>
      </div>
    </div>
  );
};

export default GoogleEventDetailsModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/GoogleEventDetailsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/GoogleSettingsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useEffect } from 'react';
import { ShowToastFunction, GoogleCalendar, ManagedAppCalendar } from '@/types';
import Tooltip from '../ui/Tooltip';
import { useEventDataStore } from '@/stores/eventDataStore';
import { useModalStore } from '@/stores/modalStore';
import {
  useGoogleConfigStore,
  fetchAndLoadConfig,
  saveConfig,
  deleteCalendar,
  disconnectGoogle,
} from '@/stores/googleConfigStore';
import logger from '@/utils/logger';

interface GoogleSettingsModalProps {
  onClose: () => void;
  showToast: ShowToastFunction;
}

const GoogleSettingsModal: React.FC<GoogleSettingsModalProps> = ({ onClose, showToast }) => {
  const executeSync = useEventDataStore(state => state.executeSync);
  const isEventDataSyncing = useEventDataStore(state => state.isSyncing);
  const openModal = useModalStore(state => state.openModal);

  const externalCalendars = useGoogleConfigStore(state => state.externalCalendars);
  const selectedIds = useGoogleConfigStore(state => state.selectedIds);
  const managedCalendars = useGoogleConfigStore(state => state.managedCalendars);
  const activeCalendarId = useGoogleConfigStore(state => state.activeCalendarId);
  const loading = useGoogleConfigStore(state => state.loading);
  const error = useGoogleConfigStore(state => state.error);

  useEffect(() => {
    logger.info('[GoogleSettingsModal] Muntat. Carregant la configuració de Google...');
    fetchAndLoadConfig();
  }, []);

  logger.info('[GoogleSettingsModal Render]', { loading, error });

  const handleCreateNewCalendar = () => {
    openModal('createAppCalendar');
  };

  const handleSaveAndClose = async () => {
    const result = await saveConfig();
    showToast(result.message, result.type);
    if (result.success) {
      onClose();
    }
  };

  const isSyncing = isEventDataSyncing || loading;

  return (
    <div className="space-y-4">
      <div>
        <h3 className="text-lg font-medium text-foreground">Configuració de Google Calendar</h3>
        <div className="mt-2 text-sm space-y-2 p-3 bg-warning/10 border-l-4 border-warning">
          <h4 className="font-semibold text-warning-foreground">AVÍS IMPORTANT: Com Funciona la Integració amb Google</h4>
          <p>Aquesta aplicació interactua amb Google Calendar de dues maneres diferents per protegir la teva privacitat:</p>
          <ul className="list-disc list-inside space-y-1 pl-2">
            <li><strong>Sincronització (Escriptura):</strong> L'aplicació <strong>NOMÉS</strong> pot escriure i sobreescriure les dades dels calendaris que ella mateixa ha creat (els de la llista "Calendaris de l'App Gestionats").</li>
            <li><strong>Visualització (Només Lectura):</strong> Els teus altres calendaris de Google es mostren només per a visualització. Aquesta aplicació <strong>MAI modificarà ni esborrarà res</strong> dels teus calendaris personals.</li>
          </ul>
          <p className="font-semibold pt-2">Requisit per a la Sincronització:</p>
          <p>Per poder utilitzar aquesta funcionalitat, has de contactar amb l'autor per a que el teu compte de Google sigui afegit a la llista d'usuaris permesos.</p>
        </div>
      </div>

      <div className="p-4 border border-border rounded-md space-y-4">
        <div className="flex justify-between items-center">
          <h4 className="font-semibold text-card-foreground">Calendaris de l'App Gestionats</h4>
          <Tooltip text="Obrir el diàleg per crear un nou calendari a Google gestionat per l'app">
            <button onClick={handleCreateNewCalendar} className="px-3 py-1 text-sm font-medium text-success-foreground bg-success hover:bg-success/90 rounded-md">
              + Crear Nou
            </button>
          </Tooltip>
        </div>

        {loading && <p className="text-center text-muted-foreground">Carregant...</p>}
        {!loading && managedCalendars.length > 0 && (
          <ul className="space-y-3 max-h-48 overflow-y-auto pr-2">
            {managedCalendars.map((cal: ManagedAppCalendar) => (
              <li key={cal.id} className="p-2 rounded-md border border-border">
                <div className="flex items-center justify-between">
                  <div className="flex items-center flex-grow">
                    <Tooltip text="Seleccionar com a calendari actiu per a la sincronització">
                      <input
                        type="radio"
                        id={`cal-${cal.id}`}
                        name="activeCalendar"
                        checked={cal.id === activeCalendarId}
                        onChange={() => useGoogleConfigStore.getState().setActiveCalendarId(cal.id)}
                        className="h-4 w-4 text-primary focus:ring-ring border-border"
                      />
                    </Tooltip>
                    <div className="ml-3">
                      <label htmlFor={`cal-${cal.id}`} className="block text-sm font-medium text-card-foreground cursor-pointer">
                        {cal.name}
                        {cal.id === activeCalendarId && <span className="ml-2 text-xs font-bold text-primary">(ACTIU)</span>}
                      </label>
                      <span className="text-xs text-muted-foreground">Sufix: {cal.suffix || '(cap)'}</span>
                    </div>
                  </div>
                  <Tooltip text={`Eliminar el calendari '${cal.name}' de Google i de l'app`}>
                    <button
                      onClick={() => deleteCalendar(cal)}
                      className="ml-4 px-2 py-1 text-xs font-medium text-destructive hover:bg-destructive/10 rounded"
                    >
                      Eliminar
                    </button>
                  </Tooltip>
                </div>
                <div className="mt-2 pl-7">
                    <div className="flex rounded-md shadow-sm">
                      <span className="inline-flex items-center px-3 rounded-l-md border border-r-0 border-border bg-muted text-muted-foreground text-xs">
                        ID
                      </span>
                      <input
                        type="text"
                        readOnly
                        value={cal.id}
                        className="flex-1 min-w-0 block w-full px-2 py-1 rounded-none bg-secondary border-border text-xs"
                      />
                      <Tooltip text="Copiar l'ID del calendari al porta-retalls">
                        <button
                          onClick={() => {
                            navigator.clipboard.writeText(cal.id);
                            showToast('ID del calendari copiat!', 'success');
                          }}
                          className="inline-flex items-center px-3 py-1 border border-l-0 border-border rounded-r-md bg-secondary text-xs hover:bg-accent"
                        >
                          Copiar
                        </button>
                      </Tooltip>
                    </div>
                </div>
              </li>
            ))}
          </ul>
        )}
        {!loading && managedCalendars.length === 0 && (
          <div className="text-center text-sm text-muted-foreground py-4">
            <p>No hi ha cap calendari gestionat per l'aplicació.</p>
            <p>Fes clic a "Crear Nou" per començar.</p>
          </div>
        )}
      </div>

      <div className="p-4 border border-border rounded-md min-h-[150px]">
        <h4 className="font-semibold mb-2 text-card-foreground">Altres Calendaris de Google (només lectura)</h4>
        {loading && <p className="text-center text-muted-foreground">Carregant calendaris...</p>}
        {error && <p className="text-center text-destructive">{typeof error === 'string' ? error : (error as Error)?.message || 'S\'ha produït un error desconegut'}</p>}
        {!loading && !error && externalCalendars.length > 0 && (
          <ul className="space-y-2 max-h-48 overflow-y-auto">
            {externalCalendars.map((cal: GoogleCalendar) => (
              <li key={cal.id} className="flex items-center">
                <Tooltip text={`Mostrar/ocultar el calendari '${cal.summary}' a la vista principal`}>
                  <input
                    type="checkbox"
                    id={cal.id}
                    checked={selectedIds.includes(cal.id)}
                    onChange={() => useGoogleConfigStore.getState().toggleExternalCalendar(cal.id)}
                    className="h-4 w-4 rounded border-border text-primary focus:ring-ring"
                    style={{ accentColor: cal.backgroundColor }}
                  />
                </Tooltip>
                <label htmlFor={cal.id} className="ml-3 block text-sm font-medium text-muted-foreground">
                  {cal.summary}
                  {cal.primary && ' (Principal)'}
                </label>
              </li>
            ))}
          </ul>
        )}
        {!loading && !error && externalCalendars.length === 0 && (
          <p className="text-center text-sm text-muted-foreground">No s'han trobat altres calendaris de Google per seleccionar.</p>
        )}
      </div>
      
      <div className="flex justify-between items-center pt-4 border-t border-border">
        <Tooltip text={managedCalendars.length === 0 ? "No hi ha cap compte de Google connectat" : "Desconnecta el teu compte de Google i elimina les dades relacionades"}>
          <button
            onClick={disconnectGoogle}
            className="px-4 py-2 text-sm font-medium text-destructive-foreground bg-destructive hover:bg-destructive/90 rounded-md disabled:opacity-50"
            disabled={managedCalendars.length === 0 || isSyncing}
          >
            Desconnectar Compte
          </button>
        </Tooltip>
        <div className="flex items-center space-x-2">
          <Tooltip text={!activeCalendarId ? "Selecciona un calendari actiu per poder sincronitzar" : "Forçar una sincronització manual ara"}>
            <button
              onClick={() => {
                if (activeCalendarId) {
                  executeSync(activeCalendarId);
                  onClose();
                } else {
                  showToast("Si us plau, selecciona un calendari actiu per sincronitzar.", 'warning');
                }
              }}
              disabled={!activeCalendarId || isSyncing}
              className="px-4 py-2 text-sm font-medium text-warning-foreground bg-warning hover:bg-warning/90 rounded-md disabled:opacity-50"
            >
              {isSyncing ? 'Sincronitzant...' : 'Sincronitzar Ara'}
            </button>
          </Tooltip>
          <Tooltip text="Desar la configuració actual i tancar la finestra">
            <button onClick={handleSaveAndClose} disabled={isSyncing} className="px-4 py-2 text-sm font-medium text-primary-foreground bg-primary hover:bg-primary/90 rounded-md disabled:opacity-50">
              Desar i Tancar
            </button>
          </Tooltip>
        </div>
      </div>
    </div>
  );
};

export default GoogleSettingsModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/GoogleSettingsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/HistoryModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { useTemporalStore, useEventDataStore } from '../../stores/eventDataStore';
import { useModalStore } from '../../stores/modalStore';
import { XMarkIcon, ArrowUturnLeftIcon, ArrowUturnRightIcon } from '@heroicons/react/24/solid';

const HistoryModal: React.FC = () => {
  const pastStates = useTemporalStore(state => state.pastStates);
  const futureStates = useTemporalStore(state => state.futureStates);
  const { undo, redo } = useEventDataStore.temporal.getState();
  const { closeModal } = useModalStore.getState();

  const handleUndo = (steps: number) => {
    undo(steps);
    closeModal();
  };

  const handleRedo = (steps: number) => {
    redo(steps);
    closeModal();
  };

  const reversedFutureStates = [...futureStates].reverse();
  const reversedPastStates = [...pastStates].reverse();

  // Obtenim la descripció de l'acció de l'estat actual directament des de l'store.
  const currentActionDescription = useEventDataStore.getState().lastActionDescription;

  return (
    <div className="bg-card text-card-foreground rounded-lg shadow-xl p-6 w-full max-w-md mx-auto">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-foreground">Historial de Canvis</h2>
        <button
          onClick={closeModal}
          className="p-1 rounded-full hover:bg-accent"
        >
          <XMarkIcon className="w-6 h-6 text-muted-foreground" />
        </button>
      </div>
      <div className="max-h-96 overflow-y-auto pr-2">
        <ul className="space-y-2">
          {reversedFutureStates.map((state, index) => (
            <li key={`future-${index}`}>
              <button
                onClick={() => handleRedo(index + 1)}
                className="w-full text-left p-2 rounded-md hover:bg-accent flex items-center gap-2"
              >
                <ArrowUturnRightIcon className="w-5 h-5 text-muted-foreground" />
                <span className="text-muted-foreground italic">
                  {state.lastActionDescription || 'Acció sense nom'}
                </span>
              </button>
            </li>
          ))}
          <li>
            <div className="w-full text-left p-2 rounded-md bg-primary/10 flex items-center gap-2">
              <span className="font-bold text-primary">Estat Actual</span>
            </div>
          </li>
          {reversedPastStates.map((_, index) => {
            const description = index === 0
              ? currentActionDescription
              : reversedPastStates[index - 1].lastActionDescription;

            return (
              <li key={`past-${index}`}>
                <button
                  onClick={() => handleUndo(index + 1)}
                  className="w-full text-left p-2 rounded-md hover:bg-accent flex items-center gap-2"
                >
                  <ArrowUturnLeftIcon className="w-5 h-5 text-muted-foreground" />
                  <span className="text-foreground">
                    {description || 'Acció inicial'}
                  </span>
                </button>
              </li>
            );
          })}
        </ul>
      </div>
    </div>
  );
};

export default HistoryModal;

--- END: ../Gestor-Events_i_Personal/src/components/modals/HistoryModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/MergeOrReplaceModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import Modal from '../ui/Modal';
import Tooltip from '../ui/Tooltip';

interface MergeOrReplaceModalProps {
  isOpen: boolean;
  onClose: () => void;
  onMerge: () => void;
  onReplace: () => void;
  itemType: string; // "persones" o "material"
}

const MergeOrReplaceModal: React.FC<MergeOrReplaceModalProps> = ({ isOpen, onClose, onMerge, onReplace, itemType }) => {
  return (
    <Modal isOpen={isOpen} onClose={onClose} title={`Carregar dades de ${itemType}`}>
      <div className="p-4">
        <p className="text-muted-foreground mb-6">
          Vols fusionar les noves dades de {itemType} amb les existents o vols reemplaçar totes les dades actuals?
        </p>
        <div className="flex justify-end gap-4">
          <Tooltip text="Afegir les noves dades mantenint les existents. Si hi ha conflictes (mateix ID), es mantenen les dades antigues.">
            <button
              onClick={onMerge}
              className="bg-primary hover:bg-primary/90 text-primary-foreground font-semibold py-2 px-4 rounded-md transition-colors"
            >
              Fusionar
            </button>
          </Tooltip>
          <Tooltip text="Esborrar totes les dades actuals d'aquest tipus i carregar només les noves.">
            <button
              onClick={onReplace}
              className="bg-warning hover:bg-warning/90 text-warning-foreground font-semibold py-2 px-4 rounded-md transition-colors"
            >
              Reemplaçar
            </button>
          </Tooltip>
          <Tooltip text="Cancel·lar la càrrega de dades.">
            <button
              onClick={onClose}
              className="bg-secondary hover:bg-accent text-secondary-foreground font-semibold py-2 px-4 rounded-md transition-colors border border-border"
            >
              Cancel·lar
            </button>
          </Tooltip>
        </div>
      </div>
    </Modal>
  );
};

export default MergeOrReplaceModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/MergeOrReplaceModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/SelectSyncCalendarModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useEffect } from 'react';
import { ManagedAppCalendar } from '@/types';
import Tooltip from '../ui/Tooltip';

interface SelectSyncCalendarModalProps {
  onClose: () => void;
  onConfirm: (targetCalendarId: string) => void;
  managedCalendars: ManagedAppCalendar[];
  activeCalendarId: string | null;
}

const SelectSyncCalendarModal: React.FC<SelectSyncCalendarModalProps> = ({
  onClose,
  onConfirm,
  managedCalendars,
  activeCalendarId,
}) => {
  const [selectedCalendarId, setSelectedCalendarId] = useState<string | null>(activeCalendarId);

  useEffect(() => {
    // Pre-select the active calendar, or the first one if no active one is set.
    if (activeCalendarId && managedCalendars.some(c => c.id === activeCalendarId)) {
      setSelectedCalendarId(activeCalendarId);
    } else if (managedCalendars.length > 0) {
      setSelectedCalendarId(managedCalendars[0].id);
    } else {
      setSelectedCalendarId(null);
    }
  }, [activeCalendarId, managedCalendars]);

  const handleSync = () => {
    if (selectedCalendarId) {
      onConfirm(selectedCalendarId);
    }
  };

  const selectedCalendar = managedCalendars.find(c => c.id === selectedCalendarId);

  return (
    <div className="space-y-4">
      <div>
        <h3 className="text-lg font-medium text-foreground">Selecciona el Calendari de Destinació</h3>
        <p className="mt-1 text-sm text-muted-foreground">
          Tria a quin calendari de l'aplicació vols pujar les dades actuals. Aquesta acció sobreescriurà tot el contingut del calendari de destinació.
        </p>
      </div>

      {managedCalendars.length > 0 ? (
        <div className="space-y-2 max-h-60 overflow-y-auto p-1">
          {managedCalendars.map(cal => (
            <div key={cal.id} className="flex items-center p-2 rounded-md border border-transparent has-[:checked]:border-primary has-[:checked]:bg-primary/10">
              <Tooltip text={`Seleccionar el calendari '${cal.name}' com a destinació per a la sincronització`}>
                <input
                  type="radio"
                  id={`sync-cal-${cal.id}`}
                  name="syncCalendar"
                  value={cal.id}
                  checked={cal.id === selectedCalendarId}
                  onChange={() => setSelectedCalendarId(cal.id)}
                  className="h-4 w-4 accent-primary focus:ring-ring border-border"
                />
              </Tooltip>
              <label htmlFor={`sync-cal-${cal.id}`} className="ml-3 block text-sm font-medium text-foreground">
                {cal.name}
              </label>
            </div>
          ))}
        </div>
      ) : (
        <div className="text-center text-sm text-muted-foreground py-6 bg-muted/50 rounded-md">
          <p>No s'ha trobat cap calendari gestionat per l'aplicació.</p>
          <p className="mt-1">Si us plau, ves a "Configuració Google Calendar" per crear-ne un primer.</p>
        </div>
      )}

      <div className="flex justify-end items-center pt-4 border-t border-border space-x-2">
        <Tooltip text="Tancar sense sincronitzar">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium rounded-md border bg-secondary text-secondary-foreground hover:bg-secondary/80"
          >
            Cancel·lar
          </button>
        </Tooltip>
        <Tooltip text={!selectedCalendarId ? 'Has de seleccionar un calendari per poder sincronitzar' : `Sobreescriurà les dades de '${selectedCalendar?.name}' amb les dades actuals de l'app`}>
          <button
            onClick={handleSync}
            disabled={!selectedCalendarId}
            className="px-4 py-2 text-sm font-medium rounded-md bg-primary text-primary-foreground hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {selectedCalendar ? `Sincronitzar amb "${selectedCalendar.name}"` : 'Selecciona un calendari'}
          </button>
        </Tooltip>
      </div>
    </div>
  );
};

export default SelectSyncCalendarModal;

--- END: ../Gestor-Events_i_Personal/src/components/modals/SelectSyncCalendarModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/modals/UpdateFromAssignmentsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useMemo } from 'react';
import { TechSheetRoleItem, Assignment, PersonGroup } from '../../types';
import Tooltip from '../ui/Tooltip';

interface ChangeItem {
  id: string;
  label: string;
  details: string;
  type: 'add' | 'remove' | 'update';
  data: any;
}

interface UpdateFromAssignmentsModalProps {
  onClose: () => void;
  onConfirm: (selectedChanges: ChangeItem[]) => void;
  toAdd: Assignment[];
  toRemove: TechSheetRoleItem[];
  toUpdate: { assignment: Assignment; currentRole: TechSheetRoleItem; newNotes: string }[];
  getPersonGroupById: (id: string) => PersonGroup | undefined;
}

export const UpdateFromAssignmentsModal: React.FC<UpdateFromAssignmentsModalProps> = ({
  onClose,
  onConfirm,
  toAdd,
  toRemove,
  toUpdate,
  getPersonGroupById,
}) => {
  const allChanges = useMemo(() => {
    const addItems: ChangeItem[] = toAdd.map(a => ({
      id: a.id,
      label: `Afegir: ${getPersonGroupById(a.personGroupId)?.name || 'Desconegut'}`,
      details: `(Nova assignació)`,
      type: 'add',
      data: a,
    }));
    const removeItems: ChangeItem[] = toRemove.map((r: any) => ({
      id: r.id,
      label: `Eliminar: Rol de ${getPersonGroupById(r.personGroupId)?.name || 'Desconegut'}`,
      details: `(Rol actual: ${r.role || 'Sense especificar'})`,
      type: 'remove',
      data: r,
    }));
    const updateItems: ChangeItem[] = toUpdate.map(u => ({
      id: u.assignment.id,
      label: `Actualitzar: ${getPersonGroupById(u.assignment.personGroupId)?.name || 'Desconegut'}`,
      details: `(Notes actualitzades)`,
      type: 'update',
      data: u,
    }));
    return [...addItems, ...updateItems, ...removeItems];
  }, [toAdd, toRemove, toUpdate, getPersonGroupById]);

  const [selectedIds, setSelectedIds] = useState<Set<string>>(() => new Set(allChanges.map(c => c.id)));

  const handleToggle = (id: string) => {
    setSelectedIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };

  const handleSelectAll = () => {
    setSelectedIds(new Set(allChanges.map(c => c.id)));
  };

  const handleDeselectAll = () => {
    setSelectedIds(new Set());
  };

  const handleConfirm = () => {
    const selectedChanges = allChanges.filter(c => selectedIds.has(c.id));
    onConfirm(selectedChanges);
    onClose();
  };

  return (
    <div className="space-y-4">
      <p className="text-muted-foreground">
        S'han detectat canvis entre les assignacions confirmades i la llista de personal tècnic.
        Selecciona els canvis que vols aplicar.
      </p>

      {allChanges.length > 0 ? (
        <>
          <div className="flex justify-end space-x-2">
            <button onClick={handleSelectAll} className="px-2 py-1 text-xs bg-primary text-primary-foreground rounded hover:bg-primary/90">Seleccionar Tot</button>
            <button onClick={handleDeselectAll} className="px-2 py-1 text-xs bg-secondary text-secondary-foreground rounded hover:bg-accent">Deseleccionar Tot</button>
          </div>
          <div className="max-h-60 overflow-y-auto space-y-2 p-2 border rounded-md bg-muted/50">
            {allChanges.map(change => {
              const bgColor = change.type === 'add'
                ? 'bg-success/10'
                : change.type === 'remove'
                ? 'bg-destructive/10'
                : 'bg-warning/10';

              return (
              <div key={change.id} className={`p-2 rounded flex items-center ${bgColor}`}>
                <input
                  type="checkbox"
                  checked={selectedIds.has(change.id)}
                  onChange={() => handleToggle(change.id)}
                  className="h-5 w-5 rounded border-border text-primary focus:ring-ring mr-3"
                />
                <div>
                  <span className="font-semibold text-foreground">{change.label}</span>
                  <span className="text-sm text-muted-foreground ml-2">{change.details}</span>
                </div>
              </div>
              )
            })}
          </div>
        </>
      ) : (
        <p className="text-center text-muted-foreground py-4">No hi ha canvis per aplicar.</p>
      )}

      <div className="flex justify-end space-x-3 mt-6">
        <Tooltip text="Tancar sense aplicar cap canvi">
          <button onClick={onClose} className="px-4 py-2 text-sm font-medium bg-secondary text-secondary-foreground hover:bg-accent rounded-md border border-border">
            Cancel·lar
          </button>
        </Tooltip>
        <Tooltip text="Aplicar els canvis seleccionats a la fitxa tècnica">
          <button onClick={handleConfirm} className="px-4 py-2 text-sm font-medium text-primary-foreground bg-primary hover:bg-primary/90 rounded-md">
            Confirmar Canvis ({selectedIds.size})
          </button>
        </Tooltip>
      </div>
    </div>
  );
};

export default UpdateFromAssignmentsModal;
--- END: ../Gestor-Events_i_Personal/src/components/modals/UpdateFromAssignmentsModal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/tech_sheets/ConditionalFormControl.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { ConditionalStatus } from '../../types';
import Tooltip from '../ui/Tooltip';

interface ConditionalFormControlProps {
  label: string;
  status: ConditionalStatus;
  onStatusChange: (newStatus: ConditionalStatus) => void;
  children: React.ReactNode;
  className?: string;
  tooltipText?: string;
}

const ConditionalFormControl: React.FC<ConditionalFormControlProps> = ({
  label,
  status,
  onStatusChange,
  children,
  className = '',
  tooltipText,
}) => {
  const valueMap = {
    'unset': '--',
    'yes': 'SI',
    'no': 'NO',
  };

  const statusToDisplay = (s: ConditionalStatus): string => valueMap[s] || '--';
  const displayToStatus = (d: string): ConditionalStatus => {
    return (Object.keys(valueMap) as ConditionalStatus[]).find(key => valueMap[key] === d) || 'unset';
  }

  const selectElement = (
    <select
      value={statusToDisplay(status)}
      onChange={(e) => onStatusChange(displayToStatus(e.target.value))}
      className="block w-28 pl-3 pr-10 py-1 text-base bg-input border-border focus:outline-none focus:ring-1 focus:ring-ring focus:border-primary sm:text-sm rounded-md"
    >
      <option>--</option>
      <option>SI</option>
      <option>NO</option>
    </select>
  );

  return (
    <div className={`mb-3 col-span-full border-t border-border pt-4 ${className}`}>
      <div className="flex items-center gap-4">
        <label className="block text-md font-semibold text-foreground">{label}</label>
        {tooltipText ? (
          <Tooltip text={tooltipText}>
            {selectElement}
          </Tooltip>
        ) : (
          selectElement
        )}
      </div>
      {status === 'yes' && (
        <div className="mt-3 ml-1 space-y-3 p-4 rounded-lg bg-muted/50 border border-border dark:bg-transparent dark:border-0 dark:p-0 dark:pl-4 dark:border-l-2 dark:border-primary/50">
          {children}
        </div>
      )}
    </div>
  );
};

export default ConditionalFormControl;

--- END: ../Gestor-Events_i_Personal/src/components/tech_sheets/ConditionalFormControl.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/tech_sheets/NeedsList.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { memo } from 'react';
import TechSheetField from './TechSheetField';
import { MaterialItem } from '../../types';
import Tooltip from '../ui/Tooltip';
import { useModalStore } from '../../stores/modalStore';

interface NeedsListProps {
  needs: any[];
  title: string;
  listName: string;
  materialItems: MaterialItem[];
  eventFrame: any;
  onListChange: (listName: string, index: number, field: string, value: any) => void;
  onRemoveListItem: (listName: string, index: number) => void;
  onAddListItem: (listName: string) => void;
  getMaterialAvailability: (materialId: string, startDate: string, endDate: string, eventFrameId: string, currentItemId?: string) => { available: number; total: number };
  onMoveItemUp: (listName: string, index: number) => void;
  onMoveItemDown: (listName: string, index: number) => void;
  onSortByOrigin: (listName: string) => void;
  originSuggestions: string[];
  availabilityMap: Map<string, { available: number; total: number }>;
}

const NeedsList: React.FC<NeedsListProps> = ({
  needs,
  title,
  listName,
  materialItems,
  eventFrame,
  onListChange,
  onRemoveListItem,
  onAddListItem,
  getMaterialAvailability,
  onMoveItemUp,
  onMoveItemDown,
  onSortByOrigin,
  originSuggestions,
  availabilityMap,
}) => {
  const { openModal } = useModalStore();
  const materialSuggestions = React.useMemo(() => {
    return materialItems.map(item => {
      const availability = availabilityMap.get(item.id);
      if (availability) {
        return `${item.name} [Disp: ${availability.available} / Estoc: ${availability.total}]`;
      }
      return `${item.name} [Estoc: ${item.stock}]`;
    });
  }, [materialItems, availabilityMap]);

  return (
    <>
      <div className="col-span-full flex justify-between items-center mt-3 -mb-2">
        <h4 className="text-md font-semibold text-foreground">{title}:</h4>
        {needs.length > 1 && (
          <Tooltip text="Ordena la llista de necessitats alfabèticament per origen.">
            <button
              onClick={() => onSortByOrigin(listName)}
              className="text-xs px-2 py-1 rounded-md no-print bg-secondary text-secondary-foreground hover:bg-secondary/80"
            >
              Ordenar per Origen
            </button>
          </Tooltip>
        )}
      </div>
      {needs.length > 0 && (
        <div className="col-span-full flex items-center gap-4 w-full text-xs font-semibold text-muted-foreground mt-2 -mb-2">
          <div className="w-1/6">Quant.</div>
          <div className="flex-grow">Descripció</div>
          <div className="w-1/4">Origen</div>
          <div className="w-24 flex-shrink-0 text-center">Accions</div>
        </div>
      )}
      {needs.map((need, index) => {
        const selectedMaterial = materialItems.find(item => item.name === need.description);
        let availabilityInfo = '';
        let quantityError = false;
        if (selectedMaterial) {
          const availability = getMaterialAvailability(selectedMaterial.id, eventFrame.startDate, eventFrame.endDate, eventFrame.id, need.id);
          availabilityInfo = `(Disp: ${availability.available} / ${availability.total})`;
          if (Number(need.quantity) > availability.available) {
            quantityError = true;
          }
        }
        return (
          <div key={need.id || `${listName}-need-${index}`} className="col-span-full flex items-start gap-4 w-full">
            <div className="w-1/6">
              <TechSheetField
                id={`${listName}-qty-${index}`}
                label=""
                type="number"
                value={need.quantity}
                onChange={e => onListChange(listName, index, 'quantity', e.target.value)}
                placeholder="XX"
                className={quantityError ? 'border-destructive ring-2 ring-destructive/30' : ''}
              />
            </div>
            <div className="flex-grow flex items-start gap-1">
              <div className='flex-grow'>
                <TechSheetField
                  id={`${listName}-desc-${index}`}
                  label=""
                  value={selectedMaterial ? selectedMaterial.name : need.description}
                  onChange={e => onListChange(listName, index, 'description', e.target.value)}
                  suggestions={materialSuggestions}
                  infoText={availabilityInfo}
                  readOnly={!!selectedMaterial}
                />
                {selectedMaterial && selectedMaterial.notes && (
                  <p className="no-print text-xs italic text-muted-foreground mt-1">
                    <strong>Nota:</strong> {selectedMaterial.notes}
                  </p>
                )}
              </div>
              {need.description && !selectedMaterial && (
                <div className="pt-2">
                  <Tooltip text="Crear nou ítem a l'inventari amb aquest nom">
                    <button
                      type="button"
                      onClick={() => openModal('addMaterialFromTechSheet', {
                        name: need.description,
                        onAdd: (newItem: MaterialItem) => {
                          onListChange(listName, index, 'description', newItem.name);
                          onListChange(listName, index, 'materialItemId', newItem.id);
                          onListChange(listName, index, 'origin', newItem.location);
                        }
                      })}
                      className="text-primary hover:bg-primary/10 rounded-full w-7 h-7 flex items-center justify-center text-2xl font-bold no-print"
                    >
                      +
                    </button>
                  </Tooltip>
                </div>
              )}
            </div>
            <div className="w-1/4">
              <TechSheetField
                id={`${listName}-origin-${index}`}
                label=""
                value={need.origin}
                onChange={e => onListChange(listName, index, 'origin', e.target.value)}
                placeholder="Propi/Teatre/CIA/lloguer...."
                readOnly={!!selectedMaterial}
                suggestions={originSuggestions}
              />
            </div>
            <div className="w-24 flex-shrink-0 pt-2 flex items-center justify-center">
              <Tooltip text="Moure amunt">
                <button
                  type="button"
                  onClick={() => onMoveItemUp(listName, index)}
                  disabled={index === 0}
                  className="text-muted-foreground hover:bg-accent rounded-full w-7 h-7 flex items-center justify-center text-xl font-bold no-print disabled:opacity-30 disabled:cursor-not-allowed"
                >
                  &#x25B2;
                </button>
              </Tooltip>
              <Tooltip text="Moure avall">
                <button
                  type="button"
                  onClick={() => onMoveItemDown(listName, index)}
                  disabled={index === needs.length - 1}
                  className="text-muted-foreground hover:bg-accent rounded-full w-7 h-7 flex items-center justify-center text-xl font-bold no-print disabled:opacity-30 disabled:cursor-not-allowed"
                >
                  &#x25BC;
                </button>
              </Tooltip>
              <Tooltip text="Eliminar aquesta necessitat">
                <button
                  type="button"
                  onClick={() => onRemoveListItem(listName, index)}
                  className="text-destructive hover:bg-destructive/10 rounded-full w-7 h-7 flex items-center justify-center text-xl font-bold no-print"
                >
                  &times;
                </button>
              </Tooltip>
            </div>
          </div>
        )
      })}
      <div className="col-span-full mt-2 no-print">
        <Tooltip text={`Afegir una nova línia de necessitat de ${title.toLowerCase()}`}>
          <button
            type="button"
            onClick={() => onAddListItem(listName)}
            className="add-item-button px-4 py-2 rounded-md text-sm bg-success text-success-foreground hover:bg-success/90"
          >
            + Afegir Necessitat {title}
          </button>
        </Tooltip>
      </div>
    </>
  );
};

export default memo(NeedsList);

--- END: ../Gestor-Events_i_Personal/src/components/tech_sheets/NeedsList.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/tech_sheets/SortableProvider.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { GripVertical } from 'lucide-react';

interface SortableProviderProps {
  id: string;
  children: React.ReactNode;
}

const SortableProvider: React.FC<SortableProviderProps> = ({ id, children }) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id });

  const style: React.CSSProperties = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 10 : 'auto',
    position: 'relative', // Ensure the parent is a positioning context for the handle
  };

  return (
    <div ref={setNodeRef} style={style}>
      {/* The children are the draggable cards themselves */}
      {React.cloneElement(children as React.ReactElement, {
        // Pass down a drag handle
        dragHandle: (
          <button
            {...attributes}
            {...listeners}
            className="absolute top-1/2 -left-6 -translate-y-1/2 p-1 text-muted-foreground hover:text-foreground hover:bg-accent rounded-md cursor-grab focus:outline-none focus:ring-2 focus:ring-ring"
            aria-label="Reordenar proveïdor"
          >
            <GripVertical size={24} />
          </button>
        ),
      })}
    </div>
  );
};

export default SortableProvider;
--- END: ../Gestor-Events_i_Personal/src/components/tech_sheets/SortableProvider.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechSheetField.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { memo, useRef } from 'react';
import Tooltip from '../ui/Tooltip';
import AutosizeTextarea from '../ui/AutosizeTextarea';

interface TechSheetFieldProps {
  id: string;
  label: string;
  value: string | number;
  onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  type?: string;
  placeholder?: string;
  as?: 'input' | 'textarea';
  rows?: number;
  required?: boolean;
  suggestions?: string[];
  disabled?: boolean;
  readOnly?: boolean;
  infoText?: string;
  className?: string;
  tooltipText?: string;
}

const TechSheetField: React.FC<TechSheetFieldProps> = ({
  id,
  label,
  value,
  onChange,
  onBlur,
  type = 'text',
  placeholder = '',
  as = 'input',
  rows = 1, // Default to 1 row for autosize to work correctly from a minimal height
  required = false,
  suggestions,
  disabled = false,
  readOnly = false,
  infoText,
  className = '',
  tooltipText,
}) => {
  const baseClasses = "mt-1 block w-full px-3 py-2 bg-input border border-border rounded-md focus:outline-none focus:ring-1 focus:ring-ring focus:border-primary sm:text-sm resize-none overflow-hidden disabled:opacity-50 disabled:cursor-not-allowed read-only:bg-muted/50";

  const finalClassName = `${baseClasses} ${className}`.trim();

  const datalistId = suggestions ? `${id}-suggestions` : undefined;
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const fieldContent = (
    <div className="flex-grow">
      {as === 'textarea' ? (
        <AutosizeTextarea
          ref={textareaRef}
          id={id}
          name={id}
          value={value}
          onChange={onChange}
          onBlur={onBlur}
          placeholder={placeholder}
          rows={rows}
          className={finalClassName}
          required={required}
          disabled={disabled}
          readOnly={readOnly}
        />
      ) : (
        <input
          type={type}
          id={id}
          name={id}
          value={value}
          onChange={onChange}
          onBlur={onBlur}
          placeholder={placeholder}
          className={finalClassName}
          required={required}
          list={datalistId}
          disabled={disabled}
          readOnly={readOnly}
        />
      )}
    </div>
  );

  return (
    <div className="w-full">
      <label htmlFor={id} className="block text-sm font-medium text-muted-foreground">
        {label}
        {required && <span className="text-destructive">*</span>}
      </label>
      <div className="flex items-center gap-2">
        {tooltipText ? (
          <Tooltip text={tooltipText}>
            {fieldContent}
          </Tooltip>
        ) : (
          fieldContent
        )}
        {infoText && <span className="text-xs text-muted-foreground mt-1 whitespace-nowrap">{infoText}</span>}
      </div>
      
      {suggestions && (
        <datalist id={datalistId}>
          {suggestions.map((suggestion, index) => (
            <option key={index} value={suggestion} />
          ))}
        </datalist>
      )}
    </div>
  );
};

export default memo(TechSheetField);
--- END: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechSheetField.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechSheetForm.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useEventDataStore } from '../../stores/eventDataStore';
import { EventFrame, TechSheetData, TechSheetProvider, TechSheetRoleItem, ContactPerson, ConditionalSection, AssemblyScheduleItem, NeedItem, ConditionalStatus, AssignmentStatus, ShowToastFunction } from '../../types';
import { DragEndEvent } from '@dnd-kit/core';
import { arrayMove } from '@dnd-kit/sortable';
import TechSheetSection from './TechSheetSection';
import TechSheetField from './TechSheetField';
import { formatDateDMY } from '../../utils/dateFormat';
import { exportTechSheetToPdf } from '../../utils/pdfGenerator';
import TechnicalPersonnelSection from './TechnicalPersonnelSection';
import NeedsList from './NeedsList';
import Tooltip from '../ui/Tooltip';
import ConditionalFormControl from './ConditionalFormControl';

interface TechSheetFormProps {
  eventFrame: EventFrame;
  showToast: ShowToastFunction;
  availabilityMap: Map<string, { available: number; total: number }>;
}

const TechSheetForm: React.FC<TechSheetFormProps> = ({ eventFrame, showToast, availabilityMap }) => {
  const { peopleGroups, materialItems, addOrUpdateTechSheet, getMaterialAvailability } = useEventDataStore.getState();
  const peopleMap = useMemo(() => {
    const m = new Map<string, string>();
    peopleGroups.forEach(p => m.set(p.id, p.name));
    return m;
  }, [peopleGroups]);

  const getInitialFormData = (): TechSheetData => {
    return eventFrame.techSheet!;
  };

  const [formData, setFormData] = useState<TechSheetData>(getInitialFormData());

  const originSuggestions = useMemo(() => {
    const suggestions = new Set<string>();
    materialItems.forEach(item => {
      if (item.location) suggestions.add(item.location);
    });
    const needsSections: TechSheetNeedsKey[] = ['lighting', 'sound', 'video', 'machinery', 'rentals', 'otherEquipment', 'electrical', 'structures', 'platforms', 'consumables', 'curtains', 'transport'];
    needsSections.forEach(sectionName => {
      const section = formData[sectionName] as ConditionalSection<{ needs: NeedItem[] }>;
      section?.data?.needs?.forEach(need => {
        if (need.origin) suggestions.add(need.origin);
      });
    });
    return Array.from(suggestions).sort();
  }, [materialItems, formData]);
  const formDataRef = useRef(formData);
  const isDirtyRef = useRef(false);
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const sectionKeys = useMemo(() => [
    'general', 'personnel', 'preAssembly', 'schedule', 'logistics',
    'technicalNeeds', 'otherDetails', 'contactsObservations'
  ], []);

  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>(() => {
    const initialState: Record<string, boolean> = {};
    sectionKeys.forEach(key => { initialState[key] = true; });
    return initialState;
  });

  const [scheduleSortOrder, setScheduleSortOrder] = useState<'asc' | 'desc'>('asc');

  const handleToggleSection = (sectionKey: string) => {
    setExpandedSections(prev => ({ ...prev, [sectionKey]: !prev[sectionKey] }));
  };

  const expandAll = () => {
    const allExpanded: Record<string, boolean> = {};
    sectionKeys.forEach(key => { allExpanded[key] = true; });
    setExpandedSections(allExpanded);
  };

  const collapseAll = () => {
    const allCollapsed: Record<string, boolean> = {};
    sectionKeys.forEach(key => { allCollapsed[key] = false; });
    setExpandedSections(allCollapsed);
  };

  const handleToggleAllSections = () => {
    const areAllExpanded = sectionKeys.every(key => expandedSections[key]);
    if (areAllExpanded) {
      collapseAll();
    } else {
      expandAll();
    }
  };

  useEffect(() => {
    formDataRef.current = formData;
  }, [formData]);

  useEffect(() => {
    const newEventName = eventFrame.name;
    const newLocation = eventFrame.place || '';
    const newDate = eventFrame.startDate === eventFrame.endDate ? formatDateDMY(eventFrame.startDate) : `${formatDateDMY(eventFrame.startDate)} - ${formatDateDMY(eventFrame.endDate)}`;

    setFormData(currentData => {
      if (
        currentData.eventName !== newEventName ||
        currentData.location !== newLocation ||
        currentData.date !== newDate
      ) {
        isDirtyRef.current = true;
        return { ...currentData, eventName: newEventName, location: newLocation, date: newDate };
      }
      return currentData;
    });
  }, [eventFrame.name, eventFrame.place, eventFrame.startDate, eventFrame.endDate]);

  const saveData = useCallback((isManualSave = false) => {
    if (isDirtyRef.current) {
      addOrUpdateTechSheet(eventFrame.id, formDataRef.current);
      if (isManualSave) {
        showToast('Canvis desats manualment.', 'success');
      }
      isDirtyRef.current = false;
    }
  }, [addOrUpdateTechSheet, eventFrame.id, showToast]);

  useEffect(() => {
    if (isDirtyRef.current) {
      if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
      saveTimeoutRef.current = setTimeout(() => saveData(), 2000);
    }
    return () => {
      if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
    };
  }, [formData, saveData]);

  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
      if (isDirtyRef.current) saveData();
    };
  }, [saveData]);

  // Aquest useEffect és clau per sincronitzar l'estat local amb el global
  useEffect(() => {
    const newProviders = eventFrame.techSheet?.technicalProviders || [];
    // Comprovem si l'array de proveïdors a l'estat local és diferent del de l'estat global.
    // Això passa després que l'acció de reordenació actualitzi la store.
    if (JSON.stringify(formData.technicalProviders) !== JSON.stringify(newProviders)) {
      setFormData(prev => ({ ...prev, technicalProviders: newProviders }));
    }
  }, [eventFrame.techSheet?.technicalProviders]); // S'executa cada cop que els proveïdors a la store canvien

  if (!formData) {
    return <div>Carregant dades de la fitxa tècnica...</div>;
  }

  const markAsDirty = () => {
    isDirtyRef.current = true;
  };

  const generateLocalId = () => `local_${Date.now().toString(36) + Math.random().toString(36).substring(2)}`;

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target;

    if (type === 'checkbox') {
        const { checked } = e.target as HTMLInputElement;
        setFormData(prev => ({ ...prev, [name]: checked }));
    } else {
        setFormData(prev => ({ ...prev, [name]: value }));
    }
    markAsDirty();
  };

  const handleFieldChange = (field: keyof TechSheetData, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    markAsDirty();
  };

  const handleSortNeedsByOrigin = (listName: TechSheetNeedsKey) => {
    setFormData(prev => {
      const section = prev[listName] as ConditionalSection<{ needs: NeedItem[] }>;
      if (!section || !section.data || !section.data.needs) return prev;

      const sortedNeeds = [...section.data.needs].sort((a, b) =>
        a.origin.localeCompare(b.origin, undefined, { sensitivity: 'base' })
      );

      const updatedSection = { ...section, data: { ...section.data, needs: sortedNeeds } };
      return { ...prev, [listName]: updatedSection };
    });
    markAsDirty();
  };

  const handleSortScheduleByDate = () => {
    setFormData(prev => {
      const scheduleData = prev.schedule?.data || [];
      const groupedByDate = scheduleData.reduce((acc, item) => {
        const date = item.date || 'Sense data';
        if (!acc[date]) {
          acc[date] = [];
        }
        acc[date].push(item);
        return acc;
      }, {} as Record<string, AssemblyScheduleItem[]>);

      const sortedDates = Object.keys(groupedByDate)
        .filter(date => date !== 'Sense data')
        .sort((a, b) => {
          if (scheduleSortOrder === 'asc') {
            return a.localeCompare(b);
          } else {
            return b.localeCompare(a);
          }
        });

      const newSchedule = sortedDates.flatMap(date => groupedByDate[date]);

      // Keep 'Sense data' items at the end
      if (groupedByDate['Sense data']) {
        newSchedule.push(...groupedByDate['Sense data']);
      }

      return { ...prev, schedule: { ...(prev.schedule || { status: 'unset', details: '' }), data: newSchedule }};
    });
    setScheduleSortOrder(prev => prev === 'asc' ? 'desc' : 'asc');
    markAsDirty();
  };

  const handleSortScheduleByTime = (date: string) => {
    setFormData(prev => {
      const scheduleData = prev.schedule?.data || [];
      const newSchedule = [...scheduleData];

      // Find the indices of the items for the given date
      const startIndex = newSchedule.findIndex(item => item.date === date);
      if (startIndex === -1) return prev; // No items for this date

      let endIndex = startIndex;
      for (let i = startIndex + 1; i < newSchedule.length; i++) {
        if (newSchedule[i].date === date) {
          endIndex = i;
        } else {
          break;
        }
      }

      // Extract the day's items, sort them by time, and splice them back in
      const dayItems = newSchedule.slice(startIndex, endIndex + 1);
      dayItems.sort((a, b) => (a.time || '').localeCompare(b.time || ''));
      newSchedule.splice(startIndex, dayItems.length, ...dayItems);

      return { ...prev, schedule: { ...(prev.schedule || { status: 'unset', details: '' }), data: newSchedule }};
    });
    markAsDirty();
  };

  const handleMoveAssemblyScheduleItemUp = (id: string) => {
    setFormData(prev => {
      const scheduleData = prev.schedule?.data;
      if (!scheduleData) return prev;

      const index = scheduleData.findIndex(item => item.id === id);
      if (index === 0) return prev;

      const currentItem = scheduleData[index];
      const previousItem = scheduleData[index - 1];

      if (previousItem && previousItem.date === currentItem.date) {
        const newSchedule = [...scheduleData];
        [newSchedule[index - 1], newSchedule[index]] = [newSchedule[index], newSchedule[index - 1]];
        return { ...prev, schedule: { ...(prev.schedule || { status: 'unset', details: '' }), data: newSchedule } };
      }
      return prev;
    });
    markAsDirty();
  };

  const handleMoveAssemblyScheduleItemDown = (id: string) => {
    setFormData(prev => {
      const scheduleData = prev.schedule?.data;
      if (!scheduleData) return prev;

      const index = scheduleData.findIndex(item => item.id === id);
      if (index === -1 || index === scheduleData.length - 1) return prev;

      const currentItem = scheduleData[index];
      // Since the array is sorted, the next item's date determines if we can move down.
      const nextItem = scheduleData[index + 1];

      if (nextItem && nextItem.date === currentItem.date) {
        const newSchedule = [...scheduleData];
        [newSchedule[index + 1], newSchedule[index]] = [newSchedule[index], newSchedule[index + 1]];
        return { ...prev, schedule: { ...(prev.schedule || { status: 'unset', details: '' }), data: newSchedule } };
      }

      return prev;
    });
    markAsDirty();
  };

  const handleConditionalChange = (
    fieldName: keyof TechSheetData,
    fieldValue: Partial<ConditionalSection<any> | { status: ConditionalStatus }>
  ) => {
    setFormData(prev => {
      const currentField = prev[fieldName] as ConditionalSection<any> || { status: 'unset', details: ''};
      const updatedField = { ...currentField, ...fieldValue };

        // INICI DE LA CORRECCIÓ
        if ('status' in fieldValue && (fieldValue.status === 'no' || fieldValue.status === 'unset')) {
          if (updatedField.data) {
            // CORRECCIÓ: Creem un nou objecte 'data' en lloc de mutar l'existent.
            // Això soluciona l'error amb la propietat 'needs'.
            updatedField.data = { ...updatedField.data, needs: [] };
          }
          // La lògica per a 'schedule' ja era correcta, però la mantenim per consistència.
          if (fieldName === 'schedule' && updatedField.data) {
            updatedField.data = [];
          }
        }
        // FI DE LA CORRECCIÓ

      return { ...prev, [fieldName]: updatedField };
    });
    markAsDirty();
  };

  type TechSheetNeedsKey = 'lighting' | 'sound' | 'video' | 'machinery' | 'rentals' | 'otherEquipment' | 'electrical' | 'structures' | 'platforms' | 'consumables' | 'curtains' | 'transport';

  const handleNeedsListChange = useCallback((sectionName: TechSheetNeedsKey, index: number, field: string, value: any) => {
    setFormData(prev => {
        const section = prev[sectionName] as ConditionalSection<{ needs: NeedItem[] }>;
        const newNeeds = [...(section?.data?.needs || [])];
        const currentItem = { ...newNeeds[index] };
        (currentItem as any)[field] = value;

        if (field === 'description') {
            const cleanValue = value.split(' [')[0];
            (currentItem as any)[field] = cleanValue;
            const matchedItem = materialItems.find(item => item.name === cleanValue);
            currentItem.materialItemId = matchedItem ? matchedItem.id : null;
            currentItem.origin = matchedItem ? matchedItem.location : '';
        }

        newNeeds[index] = currentItem;
        const updatedSection = { ...section, data: { ...section.data, needs: newNeeds } };

        return { ...prev, [sectionName]: updatedSection };
    });
    markAsDirty();
  }, [materialItems]);

  const handleRemoveNeedsListItem = useCallback((sectionName: TechSheetNeedsKey, index: number) => {
    setFormData(prev => {
        const section = prev[sectionName] as ConditionalSection<{ needs: NeedItem[] }>;
        const newNeeds = (section?.data?.needs || []).filter((_, i) => i !== index);
        const updatedSection = { ...section, data: { ...section.data, needs: newNeeds } };
        return { ...prev, [sectionName]: updatedSection };
    });
    markAsDirty();
  }, []);

  const handleMoveNeedItemUp = (listName: TechSheetNeedsKey, index: number) => {
    if (index === 0) return;
    setFormData(prev => {
      const section = prev[listName] as ConditionalSection<{ needs: NeedItem[] }>;
      if (!section || !section.data || !section.data.needs) return prev;

      const newNeeds = [...section.data.needs];
      [newNeeds[index - 1], newNeeds[index]] = [newNeeds[index], newNeeds[index - 1]];

      const updatedSection = { ...section, data: { ...section.data, needs: newNeeds } };
      return { ...prev, [listName]: updatedSection };
    });
    markAsDirty();
  };

  const handleMoveNeedItemDown = (listName: TechSheetNeedsKey, index: number) => {
    setFormData(prev => {
      const section = prev[listName] as ConditionalSection<{ needs: NeedItem[] }>;
      if (!section || !section.data || !section.data.needs) return prev;

      const newNeeds = [...section.data.needs];
      if (index >= newNeeds.length - 1) return prev;

      [newNeeds[index + 1], newNeeds[index]] = [newNeeds[index], newNeeds[index + 1]];

      const updatedSection = { ...section, data: { ...section.data, needs: newNeeds } };
      return { ...prev, [listName]: updatedSection };
    });
    markAsDirty();
  };

  const handleAddNeedsListItem = useCallback((sectionName: TechSheetNeedsKey) => {
    const newItem: NeedItem = { id: generateLocalId(), quantity: 1, description: '', origin: '' };
    setFormData(prev => {
        const section = prev[sectionName] as ConditionalSection<{ needs: NeedItem[] }>;
        const newNeeds = [...(section?.data?.needs || []), newItem];
        const updatedSection = { ...section, data: { ...section.data, needs: newNeeds } };
        return { ...prev, [sectionName]: updatedSection };
    });
    markAsDirty();
  }, []);

  const handleAssemblyScheduleChange = (id: string, field: keyof AssemblyScheduleItem, value: string) => {
    setFormData(prev => {
      const newSchedule = [...(prev.schedule?.data || [])];
      const index = newSchedule.findIndex(item => item.id === id);
      if (index === -1) return prev;

      const updatedItem = { ...newSchedule[index], [field]: value };
      newSchedule[index] = updatedItem;

      return { ...prev, schedule: { ...(prev.schedule || { status: 'unset', details: '' }), data: newSchedule }};
    });
    markAsDirty();
  };

  const handleAddAssemblyScheduleItem = (date?: string) => {
    const newDate = date !== undefined ? date : eventFrame.startDate;
    const newItem: AssemblyScheduleItem = { id: generateLocalId(), date: newDate, time: '', timeEnd: '', description: '' };

    setFormData(prev => {
      const scheduleData = prev.schedule?.data || [];
      let newSchedule = [...scheduleData];

      if (date) {
        // If a date is provided, add the new item to the end of that day's group
        let lastIndexForDate = -1;
        for (let i = newSchedule.length - 1; i >= 0; i--) {
          if (newSchedule[i].date === date) {
            lastIndexForDate = i;
            break;
          }
        }

        if (lastIndexForDate !== -1) {
          newSchedule.splice(lastIndexForDate + 1, 0, newItem);
        } else {
          // This case should not happen if the button is only shown for existing dates, but as a fallback:
          newSchedule.push(newItem);
        }
      } else {
        // If no date is provided, add it to the end (it will be in the "Sense data" group)
        newSchedule.push(newItem);
      }

      return { ...prev, schedule: { ...(prev.schedule || { status: 'unset', details: '' }), data: newSchedule }};
    });
    markAsDirty();
  };

  const handleRemoveAssemblyScheduleItem = (id: string) => {
    setFormData(prev => {
        const newSchedule = (prev.schedule?.data || []).filter(item => item.id !== id);
        return { ...prev, schedule: { ...(prev.schedule || { status: 'unset', details: '' }), data: newSchedule }};
    });
    markAsDirty();
  };

  const handleContactChange = (index: number, field: keyof ContactPerson, value: string) => {
    setFormData(prev => {
        const newContacts = [...(prev.contacts || [])];
        newContacts[index] = { ...newContacts[index], [field]: value };
        return { ...prev, contacts: newContacts };
    });
    markAsDirty();
  };

  const handleAddContact = () => {
    const newContact: ContactPerson = { id: generateLocalId(), name: '', role: '', email: '', phone: '' };
    setFormData(prev => ({ ...prev, contacts: [...(prev.contacts || []), newContact] }));
    markAsDirty();
  };

  const handleRemoveContact = (index: number) => {
    setFormData(prev => ({ ...prev, contacts: (prev.contacts || []).filter((_, i) => i !== index) }));
    markAsDirty();
  };

  const handleShowTimeChange = (index: number, value: string) => {
    setFormData(prev => {
      const newShowTimes = [...(prev.showTimes || [])];
      // Si l'array és buit i l'usuari escriu, es crea el primer element.
      if (newShowTimes.length === 0 && index === 0) {
        newShowTimes.push({ id: generateLocalId(), time: value });
      } else if (newShowTimes[index]) {
        newShowTimes[index] = { ...newShowTimes[index], time: value };
      }
      return { ...prev, showTimes: newShowTimes };
    });
    markAsDirty();
  };

  const addShowTime = () => {
    const newItem = { id: generateLocalId(), time: '' };
    setFormData(prev => ({
      ...prev,
      showTimes: [...(prev.showTimes || []), newItem],
    }));
    markAsDirty();
  };

  const removeShowTime = (id: string) => {
    setFormData(prev => ({
      ...prev,
      showTimes: (prev.showTimes || []).filter(item => item.id !== id),
    }));
    markAsDirty();
  };

  const handleProviderChange = useCallback((providerIndex: number, personGroupId: string) => {
    setFormData(prev => {
      const newProviders = (prev.technicalProviders || []).map((provider, index) => {
        if (index === providerIndex) {
          return { ...provider, personGroupId: personGroupId };
        }
        return provider;
      });
      return { ...prev, technicalProviders: newProviders };
    });
    markAsDirty();
  }, []);

  const handleRoleChange = useCallback((providerIndex: number, roleIndex: number, field: keyof TechSheetRoleItem, value: any) => {
    const finalValue = (field === 'role' && typeof value === 'string' && value.includes(': '))
      ? value.split(': ')[1]
      : value;
    setFormData(prev => {
      const newProviders = (prev.technicalProviders || []).map((provider, pIndex) => {
        if (pIndex === providerIndex) {
          const newRoles = provider.roles.map((role, rIndex) => {
            if (rIndex === roleIndex) {
              return { ...role, [field]: finalValue };
            }
            return role;
          });
          return { ...provider, roles: newRoles };
        }
        return provider;
      });
      return { ...prev, technicalProviders: newProviders };
    });
    markAsDirty();
  }, []);

  const handleAddProvider = useCallback(() => {
    const newProvider: TechSheetProvider = { id: generateLocalId(), personGroupId: '', roles: [], isManual: true };
    setFormData(prev => ({ ...prev, technicalProviders: [...(prev.technicalProviders || []), newProvider] }));
    markAsDirty();
  }, []);

  const handleRemoveProvider = useCallback((providerIndex: number) => {
    setFormData(prev => ({ ...prev, technicalProviders: (prev.technicalProviders || []).filter((_, i) => i !== providerIndex) }));
    markAsDirty();
  }, []);

  const handleAddRole = useCallback((providerIndex: number) => {
    const newRole: TechSheetRoleItem = { id: generateLocalId(), role: '', quantity: 1, notes: '', printNotes: true };
    setFormData(prev => {
      const newProviders = (prev.technicalProviders || []).map((provider, index) => {
        if (index === providerIndex) {
          return {
            ...provider,
            roles: [...provider.roles, newRole]
          };
        }
        return provider;
      });
      return { ...prev, technicalProviders: newProviders };
    });
    markAsDirty();
  }, []);

  const handleRemoveRole = useCallback((providerIndex: number, roleIndex: number) => {
    setFormData(prev => {
      const newProviders = (prev.technicalProviders || []).map((provider, index) => {
        if (index === providerIndex) {
          return {
            ...provider,
            roles: provider.roles.filter((_, i) => i !== roleIndex)
          };
        }
        return provider;
      });
      return { ...prev, technicalProviders: newProviders };
    });
    markAsDirty();
  }, []);

  const handleManualSave = () => {
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
      saveTimeoutRef.current = null;
    }
    if (isDirtyRef.current) {
      saveData(true);
    } else {
      showToast('No hi ha canvis per desar.', 'info');
    }
  };

  const handleExportToPdf = () => {
    if (isDirtyRef.current) {
        showToast('Desant canvis pendents abans d\'exportar...', 'info');
        saveData(true);
    }
  exportTechSheetToPdf(formData, eventFrame.name, (id: string) => ({ id, name: peopleMap.get(id) || 'Desconegut' }), showToast);
  };

  const handleConfirmUpdateFromAssignments = (selectedChanges?: any[]) => {
    if (!selectedChanges || selectedChanges.length === 0) {
      showToast('No s\'ha seleccionat cap canvi per aplicar.', 'info');
      return;
    }

    const toAdd = selectedChanges.filter(c => c.type === 'add').map(c => c.data);
    const toUpdate = selectedChanges.filter(c => c.type === 'update').map(c => c.data);
    const toRemoveIds = new Set(selectedChanges.filter(c => c.type === 'remove').map(c => c.data.id));

    setFormData(prev => {
      const initialProviders = prev.technicalProviders || [];

      // 1. Process removals immutably
      const providersAfterRemoval = initialProviders
        .map(p => ({
          ...p,
          roles: p.roles.filter(r => !toRemoveIds.has(r.id)),
        }))
        .filter(p => p.roles.length > 0 || p.isManual);

      // 2. Process updates immutably
      const providersAfterUpdate = providersAfterRemoval.map(p => {
        const updatesForProvider = toUpdate.filter(update => p.roles.some(r => r.id === update.currentRole.id));
        if (updatesForProvider.length === 0) {
          return p;
        }
        return {
          ...p,
          roles: p.roles.map(r => {
            const relevantUpdate = toUpdate.find(u => u.currentRole.id === r.id);
            return relevantUpdate ? { ...r, notes: relevantUpdate.newNotes } : r;
          }),
        };
      });

      // 3. Process additions immutably
      let providersAfterAddition = [...providersAfterUpdate];
      const newProvidersToAdd: TechSheetProvider[] = [];

      toAdd.forEach(assignment => {
        const personGroupId = assignment.personGroupId;

        let notes = assignment.notes || '';
        if (assignment.status === AssignmentStatus.Mixed && assignment.dailyStatuses) {
          const confirmedDays = Object.entries(assignment.dailyStatuses)
            .filter(([, status]) => status === AssignmentStatus.Yes)
            .map(([date]) => formatDateDMY(date));
          if (confirmedDays.length > 0) {
            const daysString = `Dies: ${confirmedDays.join(', ')}`;
            notes = notes ? `${notes}\n${daysString}` : daysString;
          }
        }

        const newRole: TechSheetRoleItem = {
          id: generateLocalId(),
          assignmentId: assignment.id,
          role: '',
          quantity: 1,
          notes: notes,
          printNotes: true,
        };

        const existingProviderIndex = providersAfterAddition.findIndex(p => p.personGroupId === personGroupId);

        if (existingProviderIndex !== -1) {
          // Update existing provider immutably
          providersAfterAddition = providersAfterAddition.map((p, index) => {
            if (index === existingProviderIndex) {
              return { ...p, roles: [...p.roles, newRole] };
            }
            return p;
          });
        } else {
          // Check if it's already staged to be added
          const stagedProviderIndex = newProvidersToAdd.findIndex(p => p.personGroupId === personGroupId);
          if (stagedProviderIndex !== -1) {
            newProvidersToAdd[stagedProviderIndex] = {
              ...newProvidersToAdd[stagedProviderIndex],
              roles: [...newProvidersToAdd[stagedProviderIndex].roles, newRole],
            };
          } else {
            newProvidersToAdd.push({
              id: generateLocalId(),
              personGroupId,
              roles: [newRole],
              isManual: false,
            });
          }
        }
      });

      const finalProviders = [...providersAfterAddition, ...newProvidersToAdd];

      return { ...prev, technicalProviders: finalProviders };
    });

    markAsDirty();
    showToast(`${selectedChanges.length} canvi(s) aplicat(s) des de les assignacions.`, 'success');
  };

  const { reorderTechnicalProviders } = useEventDataStore.getState();

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      const oldIndex = formData.technicalProviders.findIndex(p => p.id === active.id);
      const newIndex = formData.technicalProviders.findIndex(p => p.id === over.id);
      const reorderedProviders = arrayMove(formData.technicalProviders, oldIndex, newIndex);

      // Actualitzem l'estat local per a una resposta visual immediata
      setFormData(prev => ({ ...prev, technicalProviders: reorderedProviders }));

      // Cridem l'acció de la store per persistir el canvi a l'estat global
      reorderTechnicalProviders(eventFrame.id, reorderedProviders);
    }
  };

  const renderNeedsSection = (title: string, fieldName: TechSheetNeedsKey) => (
    <ConditionalFormControl
      label={`${title}:`}
      status={formData[fieldName]?.status || 'unset'}
      onStatusChange={(status) => handleConditionalChange(fieldName, { status })}
    >
      <TechSheetField
        id={`${fieldName}Details`}
        label={`Detalls generals de ${title.toLowerCase()}:`}
        value={formData[fieldName]?.details || ''}
        onChange={(e) => handleConditionalChange(fieldName, { details: e.target.value })}
        as="textarea"
        rows={2}
      />
      <NeedsList
        needs={formData[fieldName]?.data?.needs || []}
        title={`Material de ${title.toLowerCase()}`}
        listName={fieldName}
        onListChange={handleNeedsListChange as any}
        onRemoveListItem={handleRemoveNeedsListItem as any}
        onAddListItem={handleAddNeedsListItem as any}
        onMoveItemUp={handleMoveNeedItemUp as any}
        onMoveItemDown={handleMoveNeedItemDown as any}
        onSortByOrigin={handleSortNeedsByOrigin as any}
        originSuggestions={originSuggestions}
        materialItems={materialItems}
        eventFrame={eventFrame}
        getMaterialAvailability={getMaterialAvailability}
        availabilityMap={availabilityMap}
      />
    </ConditionalFormControl>
  );

  return (
    <div className="p-2 bg-background rounded-lg shadow space-y-4 tech-sheet-form-container">
      {/* Header */}
      <div className="flex justify-between items-center">
        <Tooltip text="Fes doble clic per expandir/replegar totes les seccions.">
          <h2
            className="text-xl font-bold text-foreground"
            onDoubleClick={handleToggleAllSections}
            style={{ cursor: 'pointer' }}
          >
            Fitxa de Bolo: <span className="text-primary">{eventFrame.name}</span>
          </h2>
        </Tooltip>
        <div className="flex items-center gap-2">
            <Tooltip text="Expandir totes les seccions del formulari">
                <button onClick={expandAll} className="px-2 py-1 bg-secondary text-secondary-foreground text-xs rounded-md hover:bg-accent no-print">Expandir Totes</button>
            </Tooltip>
            <Tooltip text="Col·lapsar totes les seccions del formulari">
                <button onClick={collapseAll} className="px-2 py-1 bg-secondary text-secondary-foreground text-xs rounded-md hover:bg-accent no-print">Col·lapsar Totes</button>
            </Tooltip>
            <Tooltip text="Forçar el desat immediat de tots els canvis pendents">
              <button onClick={handleManualSave} className="save-changes-button px-3 py-1 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 font-semibold no-print">Desar Canvis</button>
            </Tooltip>
            <Tooltip text="Generar i descarregar un PDF amb la fitxa tècnica actual">
              <button onClick={handleExportToPdf} className="export-pdf-button px-3 py-1 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 font-semibold no-print">Exportar a PDF</button>
            </Tooltip>
        </div>
      </div>
      <div className="mt-1">
        <p className="text-sm text-muted-foreground">Edita els detalls tècnics de l'esdeveniment. Els canvis es desen automàticament.</p>
      </div>

      {/* General Info */}
      <TechSheetSection
        title="Informació General"
        layout="grid-2"
        isOpen={expandedSections.general}
        onToggle={() => handleToggleSection('general')}
      >
        <TechSheetField id="eventName" label="NOM DEL ESDEVENIMENT:" value={formData.eventName} onChange={handleChange} required tooltipText="El nom de l'esdeveniment es sincronitza automàticament amb el nom del 'Event Frame'."/>
        <TechSheetField id="location" label="LLOC:" value={formData.location} onChange={handleChange} tooltipText="El lloc de l'esdeveniment. També es sincronitza des del 'Event Frame'."/>
        <TechSheetField id="date" label="DATA:" value={formData.date} onChange={handleChange} tooltipText="La data o rang de dates de l'esdeveniment. Sincronitzat des del 'Event Frame'."/>

        {/* HORA / GESTIÓ DE SESSIONS */}
        <div className="col-span-1">
          <label className="block text-sm font-medium text-muted-foreground mb-1">HORA:</label>
          {(formData.showTimes?.length || 0) <= 1 ? (
            <div className="flex items-center gap-2">
              <TechSheetField
                id="showTime-0"
                label=""
                value={formData.showTimes?.[0]?.time || ''}
                onChange={(e) => handleShowTimeChange(0, e.target.value)}
                type="time"
                tooltipText="Hora d'inici de la funció o acte principal."
              />
              <Tooltip text="Afegeix una nova sessió horària">
                <button type="button" onClick={addShowTime} className="add-item-button px-2 py-1 bg-primary text-primary-foreground rounded hover:bg-primary/90 text-xs">+ Afegir Sessió</button>
              </Tooltip>
            </div>
          ) : (
            <div className="space-y-2">
              {formData.showTimes?.map((item, index) => (
                <div key={item.id} className="flex items-center gap-2">
                  <TechSheetField
                    id={`showTime-${index}`}
                    label=""
                    value={item.time}
                    onChange={(e) => handleShowTimeChange(index, e.target.value)}
                    type="time"
                  />
                  <Tooltip text="Eliminar aquesta sessió">
                    <button type="button" onClick={() => removeShowTime(item.id)} className="remove-item-button text-destructive hover:bg-destructive/10 rounded-full w-7 h-7 flex items-center justify-center text-xl font-bold no-print">×</button>
                  </Tooltip>
                </div>
              ))}
              <Tooltip text="Afegeix una nova sessió horària">
                <button type="button" onClick={addShowTime} className="add-item-button px-2 py-1 bg-primary text-primary-foreground rounded hover:bg-primary/90 text-xs">+ Afegir Sessió</button>
              </Tooltip>
            </div>
          )}
        </div>

        <TechSheetField id="showDuration" label="DURADA ESPECTACLE:" value={formData.showDuration} onChange={handleChange} placeholder="XX min" tooltipText="Durada aproximada de l'espectacle en minuts."/>

        {eventFrame.generalNotes && (
            <div className="col-span-full">
                <label className="block text-sm font-medium text-muted-foreground">Notes Generals de l'Esdeveniment (No editable)</label>
                <div className="mt-1 p-2 w-full bg-muted border border-border rounded-md shadow-sm text-sm text-muted-foreground whitespace-pre-wrap">
                    {eventFrame.generalNotes}
                </div>
            </div>
        )}

        <div className="col-span-full">
            <div className="flex items-center justify-between mb-1">
                <label htmlFor="generalNotes" className="block text-sm font-medium text-muted-foreground">Notes Generals de la Fitxa Tècnica</label>
                <Tooltip text="Marca aquesta casella per incloure les notes generals en exportar la fitxa a PDF.">
                    <div className="flex items-center gap-2">
                        <input type="checkbox" id="showGeneralNotesInPdf" name="showGeneralNotesInPdf" checked={formData.showGeneralNotesInPdf || false} onChange={handleChange} className="h-4 w-4 rounded border-border accent-primary focus:ring-ring"/>
                        <label htmlFor="showGeneralNotesInPdf" className="text-sm font-medium text-foreground">Imprimir al PDF</label>
                    </div>
                </Tooltip>
            </div>
            <TechSheetField
                id="generalNotes"
                label=""
                value={formData.generalNotes || ''}
                onChange={handleChange}
                as="textarea"
                rows={3}
                placeholder=".... Aquí les notes generals de la fitxa tècnica, ( amb selector de impresió si/no)"
                tooltipText="Afegeix aquí qualsevol nota general o comentari rellevant per a tota la fitxa."
            />
        </div>
        <div className="col-span-full -mb-3">
            <ConditionalFormControl
                label="ZONA RESERVADA PARKING:"
                status={formData.parking?.status || 'unset'}
                onStatusChange={(status) => handleConditionalChange('parking', { status })}
                tooltipText="Indica si es necessita o no una zona de pàrquing reservada."
            >
                <TechSheetField
                    id="parkingDetails"
                    label="Detalls de la zona de parking:"
                    value={formData.parking?.details || ''}
                    onChange={(e) => handleConditionalChange('parking', { details: e.target.value })}
                    as="textarea"
                    rows={2}
                    placeholder="On, quantes places, metres lineals , contacte..."
                    tooltipText="Especifica la ubicació, el nombre de places necessàries, i a qui contactar per a la gestió del pàrquing."
                />
            </ConditionalFormControl>
        </div>
      </TechSheetSection>

      {/* Personnel */}
      <TechSheetSection
        title="Personal Tècnic"
        layout="single-column"
        isOpen={expandedSections.personnel}
        onToggle={() => handleToggleSection('personnel')}
      >
        <TechnicalPersonnelSection
          formData={formData}
          technicalProviders={formData.technicalProviders || []}
          peopleGroups={peopleGroups}
          eventFrame={eventFrame}
          onProviderChange={handleProviderChange}
          onRoleChange={handleRoleChange}
          onFieldChange={handleFieldChange}
          onAddProvider={handleAddProvider}
          onRemoveProvider={handleRemoveProvider}
          onAddRole={handleAddRole}
          onRemoveRole={handleRemoveRole}
          getPersonGroupById={(id: string) => ({ id, name: peopleMap.get(id) || 'Desconegut' })}
          showToast={showToast}
          onConfirmUpdate={handleConfirmUpdateFromAssignments}
          onDragEnd={handleDragEnd}
        />
      </TechSheetSection>

      {/* Pre-assembly */}
      <TechSheetSection
        title="Premuntatge"
        isOpen={expandedSections.preAssembly}
        onToggle={() => handleToggleSection('preAssembly')}
      >
        <ConditionalFormControl
          label="PREMUNTATGE:"
          status={formData.preAssembly?.status || 'unset'}
          onStatusChange={(status) => handleConditionalChange('preAssembly', { status })}
          tooltipText="Indica si es realitzarà un premuntatge previ a l'esdeveniment."
        >
          <TechSheetField
            id="preAssemblyDetails"
            label="Detalls premuntatge, personal, etc:"
            value={formData.preAssembly?.details || ''}
            onChange={(e) => handleConditionalChange('preAssembly', { details: e.target.value })}
            as="textarea"
            rows={2}
            placeholder="Descripció general del premuntatge..."
            tooltipText="Descriu les tasques de premuntatge, el personal necessari, i qualsevol altre detall logístic rellevant."
          />
        </ConditionalFormControl>
      </TechSheetSection>

      {/* Schedule */}
      <TechSheetSection
        title="Horaris"
        isOpen={expandedSections.schedule}
        onToggle={() => handleToggleSection('schedule')}
      >
        <ConditionalFormControl
          label="HORARIS:"
          status={formData.schedule?.status || 'unset'}
          onStatusChange={(status) => handleConditionalChange('schedule', { status })}
          tooltipText="Activa aquesta secció per detallar la planificació horària de l'esdeveniment."
        >
          <div className="flex justify-between items-start mb-2">
            <div className="flex-grow pr-4">
                <div className="flex items-center justify-between mb-1">
                    <label className="block text-sm font-medium text-muted-foreground">Notes generals dels horaris:</label>
                    <Tooltip text="Marca aquesta casella per incloure aquestes notes en exportar la fitxa a PDF.">
                        <div className="flex items-center gap-2">
                            <input
                                type="checkbox"
                                id="showScheduleNotesInPdf"
                                name="showScheduleNotesInPdf"
                                checked={formData.showScheduleNotesInPdf ?? true}
                                onChange={handleChange}
                                className="h-4 w-4 rounded border-border accent-primary focus:ring-ring"
                            />
                            <label htmlFor="showScheduleNotesInPdf" className="text-sm font-medium text-foreground">Imprimir al PDF</label>
                        </div>
                    </Tooltip>
                </div>
              <TechSheetField
                id="scheduleDetails"
                label=""
                value={formData.schedule?.details || ''}
                onChange={(e) => handleConditionalChange('schedule', { details: e.target.value })}
                as="textarea"
                rows={2}
                placeholder="Afegeix aquí notes generals sobre la planificació, com ara pauses, hores de menjars, etc."
                tooltipText="Aquestes notes s'apliquen a tota la secció d'horaris."
              />
            </div>
            <div className="flex-shrink-0 pt-7">
              <Tooltip text={`Ordena els blocs de dies per data ${scheduleSortOrder === 'asc' ? 'descendent' : 'ascendent'}`}>
                <button
                  type="button"
                  onClick={handleSortScheduleByDate}
                  className="px-2 py-1 bg-primary text-primary-foreground text-xs rounded-md hover:bg-primary/90 no-print"
                >
                  Ordenar Dies ({scheduleSortOrder === 'asc' ? 'ASC' : 'DESC'})
                </button>
              </Tooltip>
            </div>
          </div>

          <div className="col-span-full space-y-4 mt-2">
            {Object.entries(
              (formData.schedule?.data || []).reduce((acc, item) => {
                const date = item.date || 'Sense data';
                if (!acc[date]) {
                  acc[date] = [];
                }
                acc[date].push(item);
                return acc;
              }, {} as Record<string, AssemblyScheduleItem[]>)
            ).map(([date, items]) => (
              <div key={date} className="p-3 border rounded-md bg-muted/50 border-border">
                <div className="flex justify-between items-center mb-2">
                  <h4 className="font-semibold text-foreground">
                    {date === 'Sense data' ? 'Elements nous - Assignar data' : `Data: ${formatDateDMY(date)}`}
                  </h4>
                  {date !== 'Sense data' && (
                    <div className="flex items-center gap-2">
                      {items.length > 1 && (
                        <Tooltip text="Ordenar les entrades d'aquest dia per hora">
                          <button type="button" onClick={() => handleSortScheduleByTime(date)} className="px-2 py-1 bg-secondary text-secondary-foreground text-xs rounded-md hover:bg-accent no-print">Ordenar per Hora</button>
                        </Tooltip>
                      )}
                      <Tooltip text={`Afegir una nova línia d'horari per al ${formatDateDMY(date)}`}>
                        <button type="button" onClick={() => handleAddAssemblyScheduleItem(date)} className="add-item-button px-2 py-1 bg-primary text-primary-foreground rounded hover:bg-primary/90 text-xs">+ Afegir Horari</button>
                      </Tooltip>
                    </div>
                  )}
                </div>

                <div className="space-y-2">
                  {items.map((item, index) => {
                    return (
                      <div key={item.id} className="grid grid-cols-12 gap-2 items-start">
                        <div className="col-span-3">
                          <TechSheetField id={`schedule-date-${item.id}`} label={index === 0 ? "Data" : ""} value={item.date} onChange={(e) => handleAssemblyScheduleChange(item.id, 'date', e.target.value)} type="date" tooltipText="Modifica la data de la tasca. Si canvies la data, la tasca es mourà al bloc del dia corresponent."/>
                        </div>
                        <div className="col-span-2">
                          <TechSheetField id={`schedule-time-${item.id}`} label={index === 0 ? "Hora Inici" : ""} value={item.time} onChange={(e) => handleAssemblyScheduleChange(item.id, 'time', e.target.value)} type="time" tooltipText="Hora d'inici de l'activitat."/>
                        </div>
                        <div className="col-span-2">
                          <TechSheetField id={`schedule-time-end-${item.id}`} label={index === 0 ? "Hora Fi" : ""} value={item.timeEnd || ''} onChange={(e) => handleAssemblyScheduleChange(item.id, 'timeEnd', e.target.value)} type="time" tooltipText="Hora de finalització de l'activitat (opcional)."/>
                        </div>
                        <div className="col-span-4">
                          <TechSheetField id={`schedule-desc-${item.id}`} label={index === 0 ? "Descripció" : ""} value={item.description} onChange={(e) => handleAssemblyScheduleChange(item.id, 'description', e.target.value)} as="textarea" rows={1} tooltipText="Descripció de l'activitat (p. ex., 'Muntatge llums', 'Prova de so')."/>
                        </div>
                        <div className="col-span-1 flex-shrink-0 self-center pt-5 flex items-center justify-center space-x-1">
                          <Tooltip text="Moure amunt">
                            <button
                              type="button"
                              onClick={() => handleMoveAssemblyScheduleItemUp(item.id)}
                              disabled={index === 0}
                              className="text-muted-foreground hover:bg-accent rounded-full w-7 h-7 flex items-center justify-center text-xl font-bold no-print disabled:opacity-30 disabled:cursor-not-allowed"
                            >
                              &#x25B2;
                            </button>
                          </Tooltip>
                          <Tooltip text="Moure avall">
                            <button
                              type="button"
                              onClick={() => handleMoveAssemblyScheduleItemDown(item.id)}
                              disabled={index === items.length - 1}
                              className="text-muted-foreground hover:bg-accent rounded-full w-7 h-7 flex items-center justify-center text-xl font-bold no-print disabled:opacity-30 disabled:cursor-not-allowed"
                            >
                              &#x25BC;
                            </button>
                          </Tooltip>
                          <Tooltip text="Eliminar aquesta línia d'horari">
                            <button type="button" onClick={() => handleRemoveAssemblyScheduleItem(item.id)} className="remove-item-button text-destructive hover:bg-destructive/10 rounded-full w-8 h-8 flex items-center justify-center text-xl font-bold no-print">×</button>
                          </Tooltip>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            ))}
            <div className="mt-4 no-print">
              <Tooltip text="Afegeix una nova entrada a l'horari amb la data d'inici de l'esdeveniment. Podràs modificar la data posteriorment.">
                <button type="button" onClick={() => handleAddAssemblyScheduleItem()} className="add-item-button px-3 py-1 bg-success text-success-foreground rounded-md hover:bg-success/90 text-sm">+ Afegir Nova Data</button>
              </Tooltip>
            </div>
          </div>
        </ConditionalFormControl>
      </TechSheetSection>

      {/* Logistics */}
      <TechSheetSection
        title="Logística"
        layout="single-column"
        isOpen={expandedSections.logistics}
        onToggle={() => handleToggleSection('logistics')}
      >
        <ConditionalFormControl
          label="CAMERINOS / SALES DE PREPARACIÓ:"
          status={formData.dressingRooms?.status || 'unset'}
          onStatusChange={(status) => handleConditionalChange('dressingRooms', { status, details: formData.dressingRooms?.details || '' })}
          tooltipText="Indica si es necessiten camerinos."
        >
          <TechSheetField
            id="dressingRoomsDetails"
            label="Detalls dels camerinos / sales:"
            value={formData.dressingRooms?.details || ''}
            onChange={(e) => handleConditionalChange('dressingRooms', { details: e.target.value })}
            as="textarea"
            rows={2}
            placeholder="Especifica les necessitats de camerinos: quantitat, tipus (individuals, col·lectius), i qualsevol requeriment especial."
            tooltipText="Descriu les necessitats específiques dels camerinos."
          />
        </ConditionalFormControl>

        <ConditionalFormControl
          label="INTÈRPRETS / PONENTS:"
          status={formData.actorsInfo?.status || 'unset'}
          onStatusChange={(status) => handleConditionalChange('actorsInfo', { status, data: formData.actorsInfo?.data || { number: 0, names: '' } })}
          tooltipText="Indica si hi ha actors o artistes."
        >
          <div className="grid grid-cols-4 gap-4">
            <div className="col-span-1">
                <TechSheetField
                    id="actorsInfo-number"
                    label="Nº:"
                    type="number"
                    value={formData.actorsInfo?.data?.number || ''}
                    onChange={(e) => handleConditionalChange('actorsInfo', { data: { ...(formData.actorsInfo?.data || { number: 0, names: '' }), number: parseInt(e.target.value, 10) || 0 } })}
                    className="w-24"
                    tooltipText="Nombre total d'actors o artistes que participen."
                />
            </div>
            <div className="col-span-3">
                <TechSheetField
                    id="actorsInfo-names"
                    label="Noms / Notes:"
                    value={formData.actorsInfo?.data?.names || ''}
                    onChange={(e) => handleConditionalChange('actorsInfo', { data: { ...(formData.actorsInfo?.data || { number: 0, names: '' }), names: e.target.value } })}
                    as="textarea"
                    rows={2}
                    placeholder="Detalls, notes, noms..."
                    tooltipText="Llista els noms dels actors o artistes i qualsevol nota rellevant."
                />
            </div>
          </div>
        </ConditionalFormControl>

        <ConditionalFormControl
          label="PERSONAL TÈCNIC/PRODUCCIÓ (CLIENT / ARTISTA / GRUP):"
          status={formData.techniciansInfo?.status || 'unset'}
          onStatusChange={(status) => handleConditionalChange('techniciansInfo', { status, data: formData.techniciansInfo?.data || { number: 0, names: '' } })}
          tooltipText="Indica si hi ha personal tècnic o de producció de la companyia."
        >
          <div className="grid grid-cols-4 gap-4">
              <div className="col-span-1">
                  <TechSheetField
                      id="techniciansInfo-number"
                      label="Nº:"
                      type="number"
                      value={formData.techniciansInfo?.data?.number || ''}
                      onChange={(e) => handleConditionalChange('techniciansInfo', { data: { ...(formData.techniciansInfo?.data || { number: 0, names: '' }), number: parseInt(e.target.value, 10) || 0 } })}
                      className="w-24"
                      tooltipText="Nombre total de personal tècnic o de producció de la companyia."
                  />
              </div>
              <div className="col-span-3">
                  <TechSheetField
                      id="techniciansInfo-names"
                      label="Noms / Notes:"
                      value={formData.techniciansInfo?.data?.names || ''}
                      onChange={(e) => handleConditionalChange('techniciansInfo', { data: { ...(formData.techniciansInfo?.data || { number: 0, names: '' }), names: e.target.value } })}
                      as="textarea"
                      rows={2}
                      placeholder="Detalls, notes, noms..."
                      tooltipText="Llista els noms del personal i qualsevol nota rellevant."
                  />
              </div>
          </div>
        </ConditionalFormControl>
      </TechSheetSection>

      {/* Technical Needs */}
      <TechSheetSection
        title="Necessitats Tècniques"
        isOpen={expandedSections.technicalNeeds}
        onToggle={() => handleToggleSection('technicalNeeds')}
      >
        <div className="col-span-full">
            <div className="flex items-center justify-between mb-1">
                <label className="block text-sm font-medium text-muted-foreground">Notes Generals de Necessitats Tècniques</label>
                <Tooltip text="Marca aquesta casella per incloure aquestes notes en exportar la fitxa a PDF.">
                    <div className="flex items-center gap-2">
                        <input
                            type="checkbox"
                            id="showTechnicalNeedsNotesInPdf"
                            name="showTechnicalNeedsNotesInPdf"
                            checked={formData.showTechnicalNeedsNotesInPdf ?? true}
                            onChange={handleChange}
                            className="h-4 w-4 rounded border-border accent-primary focus:ring-ring"
                        />
                        <label htmlFor="showTechnicalNeedsNotesInPdf" className="text-sm font-medium text-foreground">Imprimir al PDF</label>
                    </div>
                </Tooltip>
            </div>
            <TechSheetField
                id="technicalNeedsNotes"
                label=""
                value={formData.technicalNeedsNotes || ''}
                onChange={(e) => handleFieldChange('technicalNeedsNotes', e.target.value)}
                as="textarea"
                rows={3}
                placeholder="Afegeix notes addicionals sobre les necessitats tècniques en general..."
                tooltipText="Afegeix aquí qualsevol nota general o comentari rellevant per a totes les necessitats tècniques."
            />
        </div>
        {renderNeedsSection('Il·luminació', 'lighting')}
        {renderNeedsSection('So', 'sound')}
        {renderNeedsSection('Vídeo', 'video')}
        {renderNeedsSection('Maquinària', 'machinery')}
        {renderNeedsSection('Lloguers', 'rentals')}
        {renderNeedsSection('Material d\'Altres Equipaments', 'otherEquipment')}
        {renderNeedsSection('Infraestructures Elèctriques', 'electrical')}
        {renderNeedsSection('Estructures', 'structures')}
        {renderNeedsSection('Tarimes', 'platforms')}
        {renderNeedsSection('Consumibles', 'consumables')}
        {renderNeedsSection('Cortinatges', 'curtains')}
        {renderNeedsSection('Transport', 'transport')}
      </TechSheetSection>

      {/* Other Details */}
      <TechSheetSection
        title="Altres Detalls"
        isOpen={expandedSections.otherDetails}
        onToggle={() => handleToggleSection('otherDetails')}
      >
        <TechSheetField id="controlLocation" label="CONTROL A:" value={formData.controlLocation || ''} onChange={handleChange} placeholder="Cabina, Platea, a 20 metres del escenari, sota el garrofer..." tooltipText="Ubicació del control tècnic (so, llums, etc.). Per exemple: 'Cabina fons platea'."/>
        <TechSheetField id="blueprints" label="PLÀNOLS:" value={formData.blueprints || ''} onChange={handleChange} as="textarea" rows={3} placeholder="Adjunts, link dels plànols, in situ...." tooltipText="Enllaços o referències als plànols tècnics de l'esdeveniment (escenari, llums, etc.)."/>
      </TechSheetSection>

      {/* Contacts & Observations */}
      <TechSheetSection
        title="Contacte i Observacions"
        isOpen={expandedSections.contactsObservations}
        onToggle={() => handleToggleSection('contactsObservations')}
      >
        <div className="col-span-full space-y-3">
          <h4 className="text-md font-semibold text-foreground">CONTACTES (CLIENT / ARTISTA / GRUP):</h4>
          {(formData.contacts || []).map((contact, index) => (
            <div key={contact.id} className="grid grid-cols-12 gap-x-4 gap-y-2 items-center p-2 border rounded-md border-border">
              <div className="col-span-3"><TechSheetField id={`contact-name-${index}`} label="Nom" value={contact.name} onChange={(e) => handleContactChange(index, 'name', e.target.value)} placeholder="Nom del contacte" tooltipText="Nom i cognoms del contacte."/></div>
              <div className="col-span-3"><TechSheetField id={`contact-role-${index}`} label="Càrrec" value={contact.role} onChange={(e) => handleContactChange(index, 'role', e.target.value)} placeholder="Regidor, tècnic@ de llums/so, Producció, conserge del poble...." tooltipText="Càrrec o rol del contacte dins la companyia (p. ex., 'Director Tècnic', 'Producció')."/></div>
              <div className="col-span-3"><TechSheetField id={`contact-email-${index}`} label="Email" type="email" value={contact.email} onChange={(e) => handleContactChange(index, 'email', e.target.value)} placeholder="email@exemple.com" tooltipText="Correu electrònic del contacte."/></div>
              <div className="col-span-2"><TechSheetField id={`contact-phone-${index}`} label="Telèfon" type="tel" value={contact.phone} onChange={(e) => handleContactChange(index, 'phone', e.target.value)} placeholder="600123456" tooltipText="Número de telèfon del contacte."/></div>
              <div className="col-span-1 flex items-end justify-center pb-1">
                <Tooltip text="Eliminar contacte">
                  <button type="button" onClick={() => handleRemoveContact(index)} className="remove-item-button text-destructive hover:bg-destructive/10 rounded-full w-8 h-8 flex items-center justify-center text-xl font-bold no-print">×</button>
                </Tooltip>
              </div>
            </div>
          ))}
          <div className="mt-2 no-print">
            <Tooltip text="Afegir un nou contacte">
              <button type="button" onClick={handleAddContact} className="add-item-button px-3 py-1 bg-success text-success-foreground rounded-md hover:bg-success/90 text-sm">+ Afegir Contacte</button>
            </Tooltip>
          </div>
        </div>
        <div className="col-span-full pt-4">
          <TechSheetField id="observations" label="ALTRES / OBSERVACIONS:" value={formData.observations || ''} onChange={handleChange} as="textarea" rows={4} tooltipText="Espai per a qualsevol altra informació, observació o requeriment no cobert en les altres seccions."/>
        </div>
      </TechSheetSection>

    </div>
  );
};

export default TechSheetForm;

--- END: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechSheetForm.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechSheetSection.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState } from 'react';
import { ChevronDownIcon, ChevronUpIcon } from '../../constants';
import Tooltip from '../ui/Tooltip';


interface TechSheetSectionProps {
  title: string;
  children: React.ReactNode;
  defaultOpen?: boolean;
  headerActions?: React.ReactNode;
  layout?: 'single-column' | 'grid-2' | 'grid-3' | 'grid-4';
  isPrintHidden?: boolean;
  isOpen?: boolean;
  onToggle?: () => void;
}

const TechSheetSection: React.FC<TechSheetSectionProps> = ({
  title,
  children,
  defaultOpen = true,
  headerActions,
  layout = 'grid-3',
  isPrintHidden = false,
  isOpen: controlledIsOpen,
  onToggle
}) => {
  const [internalIsOpen, setInternalIsOpen] = useState(defaultOpen);

  const isControlled = controlledIsOpen !== undefined;
  const isOpen = isControlled ? controlledIsOpen : internalIsOpen;

  const handleToggle = () => {
    if (onToggle) {
      onToggle();
    } else {
      setInternalIsOpen(prev => !prev);
    }
  };

  let gridClasses = 'p-2 grid gap-4 ';
  switch (layout) {
    case 'single-column':
      gridClasses += 'grid-cols-1';
      break;
    case 'grid-2':
      gridClasses += 'grid-cols-1 md:grid-cols-2';
      break;
    case 'grid-3':
      gridClasses += 'grid-cols-1 md:grid-cols-3';
      break;
    case 'grid-4':
      gridClasses += 'grid-cols-1 md:grid-cols-2 lg:grid-cols-4';
      break;
    default:
      gridClasses += 'grid-cols-1 md:grid-cols-3';
  }

  const containerClasses = `mb-2 border border-border rounded-lg ${isPrintHidden ? 'no-print' : ''}`;

  return (
    <div className={containerClasses}>
      <div className="flex items-center justify-between bg-muted/50 rounded-t-lg">
        <Tooltip text={isOpen ? `Replegar secció ${title}` : `Expandir secció ${title}`}>
          <button
            type="button"
            onClick={handleToggle}
            className="flex-1 flex justify-between items-center p-2 rounded-t-lg focus:outline-none focus:ring-2 focus:ring-ring"
            aria-expanded={isOpen}
          >
            <h3 className="text-base font-semibold text-foreground">{title}</h3>
            {isOpen ? <ChevronUpIcon className="w-5 h-5 text-muted-foreground" /> : <ChevronDownIcon className="w-5 h-5 text-muted-foreground" />}
          </button>
        </Tooltip>
        {headerActions && <div className="pr-3">{headerActions}</div>}
      </div>
      {isOpen && (
        <div className={gridClasses}>
          {children}
        </div>
      )}
    </div>
  );
};

export default TechSheetSection;
--- END: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechSheetSection.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechnicalPersonnelSection.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useMemo } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import { TechSheetProvider, TechSheetRoleItem, PersonGroup, AssignmentStatus, Assignment, TechSheetData } from '../../types';
import TechSheetSection from './TechSheetSection';
import TechSheetField from './TechSheetField';
import { TECH_SHEET_ROLE_SUGGESTIONS } from '../../constants';
import Tooltip from '../ui/Tooltip';
import { useModalStore } from '../../stores/modalStore';
import { formatDateDMY } from '../../utils/dateFormat';
import SortableProvider from './SortableProvider';

interface TechnicalPersonnelSectionProps {
  formData: TechSheetData;
  technicalProviders: TechSheetProvider[];
  peopleGroups: PersonGroup[];
  eventFrame: any;
  onProviderChange: (providerIndex: number, personGroupId: string) => void;
  onRoleChange: (providerIndex: number, roleIndex: number, field: keyof TechSheetRoleItem, value: any) => void;
  onFieldChange: (field: keyof TechSheetData, value: any) => void;
  onAddProvider: () => void;
  onRemoveProvider: (providerIndex: number) => void;
  onAddRole: (providerIndex: number) => void;
  onRemoveRole: (providerIndex: number, roleIndex: number) => void;
  getPersonGroupById: (id: string) => PersonGroup | undefined;
  showToast: (message: string, type: 'success' | 'error' | 'info') => void;
  onConfirmUpdate: (selectedChanges?: any[]) => void;
  onDragEnd: (event: DragEndEvent) => void;
  dragHandle?: React.ReactNode;
}

const TechnicalPersonnelSection: React.FC<TechnicalPersonnelSectionProps> = ({
  formData,
  technicalProviders,
  peopleGroups,
  eventFrame,
  onProviderChange,
  onRoleChange,
  onFieldChange,
  onAddProvider,
  onRemoveProvider,
  onAddRole,
  onRemoveRole,
  showToast,
  onConfirmUpdate,
  onDragEnd,
}) => {
  const openModal = useModalStore(state => state.openModal);
  const peopleMap = useMemo(() => {
    const m = new Map<string, string>();
    peopleGroups.forEach(p => m.set(p.id, p.name));
    return m;
  }, [peopleGroups]);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <TechSheetSection title="Personal Tècnic"
      layout="single-column"
      headerActions={
        <Tooltip text="Afegeix personal confirmat de les assignacions a aquesta llista">
          <button
            type="button"
            onClick={() => {
              const getAssignmentNotes = (assignment: Assignment) => {
                let notes = assignment.notes || '';
                if (assignment.status === AssignmentStatus.Mixed && assignment.dailyStatuses) {
                  const confirmedDays = Object.entries(assignment.dailyStatuses)
                    .filter(([, status]) => status === AssignmentStatus.Yes)
                    .map(([date]) => formatDateDMY(date));
                  if (confirmedDays.length > 0) {
                    const daysString = `Dies: ${confirmedDays.join(', ')}`;
                    notes = notes ? `${notes}\n${daysString}` : daysString;
                  }
                }
                return notes;
              };

              const confirmedAssignments = eventFrame.assignments.filter((a: Assignment) =>
                a.status === AssignmentStatus.Yes || (a.status === AssignmentStatus.Mixed && Object.values(a.dailyStatuses || {}).includes(AssignmentStatus.Yes))
              );

              const confirmedAssignmentsMap = new Map(confirmedAssignments.map((a: Assignment) => [a.id, a]));
              const currentRolesMap = new Map(technicalProviders.flatMap(p => p.roles).filter(r => r.assignmentId).map(r => [r.assignmentId!, r]));

              const toAdd = confirmedAssignments.filter((a: Assignment) => !currentRolesMap.has(a.id));

              const toRemove = technicalProviders.flatMap(p =>
                p.roles
                  .filter(r => !r.assignmentId || !confirmedAssignmentsMap.has(r.assignmentId!))
                  .map(r => ({ ...r, personGroupId: p.personGroupId }))
              );

              const toUpdate = confirmedAssignments
                .filter((a: Assignment) => currentRolesMap.has(a.id))
                .map((a: Assignment) => ({
                  assignment: a,
                  currentRole: currentRolesMap.get(a.id)!,
                  newNotes: getAssignmentNotes(a),
                }))
                .filter((item: { newNotes: string; currentRole: { notes?: string } }) => item.newNotes !== item.currentRole.notes);

              if (toAdd.length === 0 && toRemove.length === 0 && toUpdate.length === 0) {
                showToast('No hi ha canvis per aplicar des de les assignacions.', 'info');
                return;
              }

              openModal('updateFromAssignments', {
                toAdd,
                toRemove,
                toUpdate,
                getPersonGroupById: (id: string) => ({ id, name: peopleMap.get(id) || 'Desconegut' }),
                onConfirm: onConfirmUpdate,
              });
            }}
            className="ml-2 px-2 py-1 rounded text-xs font-medium shadow no-print bg-primary text-primary-foreground hover:bg-primary/90"
          >
            <span className="font-bold">⟳</span> <span className="hidden sm:inline">Actualitza des d'assignacions</span>
          </button>
        </Tooltip>
      }
    >
        <div className="col-span-full">
            <div className="flex items-center justify-between mb-1">
                <label className="block text-sm font-medium text-muted-foreground">Notes Generals del Personal Tècnic</label>
                <Tooltip text="Marca aquesta casella per incloure aquestes notes en exportar la fitxa a PDF.">
                    <div className="flex items-center gap-2">
                        <input
                            type="checkbox"
                            id="showTechnicalPersonnelNotesInPdf"
                            name="showTechnicalPersonnelNotesInPdf"
                            checked={formData.showTechnicalPersonnelNotesInPdf ?? true}
                            onChange={(e) => onFieldChange('showTechnicalPersonnelNotesInPdf', e.target.checked)}
                            className="h-4 w-4 rounded border-border accent-primary focus:ring-ring"
                        />
                        <label htmlFor="showTechnicalPersonnelNotesInPdf" className="text-sm font-medium text-muted-foreground">Imprimir al PDF</label>
                    </div>
                </Tooltip>
            </div>
            <TechSheetField
                id="technicalPersonnelNotes"
                label=""
                value={formData.technicalPersonnelNotes || ''}
                onChange={(e) => onFieldChange('technicalPersonnelNotes', e.target.value)}
                as="textarea"
                rows={3}
                placeholder="Afegeix notes addicionals sobre el personal tècnic..."
                tooltipText="Afegeix aquí qualsevol nota general o comentari rellevant per a tot el personal tècnic."
            />
        </div>

      <div className="col-span-full space-y-6 mt-6">
        <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onDragEnd}>
          <SortableContext items={technicalProviders.map(p => p.id)} strategy={verticalListSortingStrategy}>
            {technicalProviders.map((provider, providerIndex) => {
              return (
                <SortableProvider key={provider.id} id={provider.id}>
                  <ProviderCard
                    provider={provider}
                    providerIndex={providerIndex}
                    peopleGroups={peopleGroups}
                    onProviderChange={onProviderChange}
                    onRoleChange={onRoleChange}
                    onAddRole={onAddRole}
                    onRemoveRole={onRemoveRole}
                    onRemoveProvider={onRemoveProvider}
                  />
                </SortableProvider>
              );
            })}
          </SortableContext>
        </DndContext>
      </div>
      <div className="col-span-full mt-4 no-print">
        <Tooltip text="Afegir un nou proveïdor de personal manualment">
          <button type="button" onClick={onAddProvider} className="px-4 py-2 rounded-md text-sm font-semibold bg-success text-success-foreground hover:bg-success/90">+ Afegir Proveïdor de Personal</button>
        </Tooltip>
      </div>
    </TechSheetSection>
  );
};

interface ProviderCardProps {
    provider: TechSheetProvider;
    providerIndex: number;
    peopleGroups: PersonGroup[];
    onProviderChange: (providerIndex: number, personGroupId: string) => void;
    onRoleChange: (providerIndex: number, roleIndex: number, field: keyof TechSheetRoleItem, value: any) => void;
    onAddRole: (providerIndex: number) => void;
    onRemoveRole: (providerIndex: number, roleIndex: number) => void;
    onRemoveProvider: (providerIndex: number) => void;
    dragHandle?: React.ReactNode;
}

const ProviderCard: React.FC<ProviderCardProps> = ({
    provider,
    providerIndex,
    peopleGroups,
    onProviderChange,
    onRoleChange,
    onAddRole,
    onRemoveRole,
    onRemoveProvider,
    dragHandle,
}) => {
    const selectedPerson = peopleGroups.find(pg => pg.id === provider.personGroupId);

    return (
        <div className="p-4 border border-border rounded-lg bg-muted/50 relative pl-8">
            {dragHandle}
            <div className="flex justify-between items-start mb-4">
                <div className="flex-1 flex items-start gap-4">
                    <div className="w-2/3">
                        <label className="block text-sm font-medium text-muted-foreground">Proveïdor de Personal {providerIndex + 1}</label>
                        <select
                            value={provider.personGroupId}
                            onChange={(e) => onProviderChange(providerIndex, e.target.value)}
                            className="mt-1 block w-full px-3 py-2 bg-input border border-border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-ring"
                        >
                            <option value="" disabled>-- Selecciona un proveïdor --</option>
                            {peopleGroups.map(pg => <option key={pg.id} value={pg.id}>{pg.name}</option>)}
                        </select>
                    </div>
                    <div className="w-1/3">
                        <TechSheetField
                            id={`provider-role-${providerIndex}`}
                            label="Rol Base (Agenda)"
                            value={selectedPerson?.role || '--'}
                            onChange={() => {}}
                            disabled
                        />
                    </div>
                </div>
                <Tooltip text="Eliminar aquest proveïdor i tots els seus rols associats">
                    <button type="button" onClick={() => onRemoveProvider(providerIndex)} className="ml-4 text-destructive hover:text-destructive/80 font-bold">Eliminar Proveïdor</button>
                </Tooltip>
            </div>

            <div className="space-y-3 pl-4 border-l-2 border-primary">
                {provider.roles.length > 0 && (
                    <div className="flex items-center gap-4 w-full text-xs font-semibold text-muted-foreground -mb-2">
                        <div className="w-1/12">Quant.</div>
                        <div className="w-4/12">Rol</div>
                        <div className="w-5/12">Notes assignació</div>
                        <div className="w-1/12 text-center">PDF</div>
                        <div className="w-1/12 flex-shrink-0"></div>
                    </div>
                )}

                {provider.roles.map((roleItem, roleIndex) => (
                    <div key={roleItem.id} className="flex items-start gap-4 w-full">
                        <div className="w-1/12">
                            <TechSheetField id={`quantity-${providerIndex}-${roleIndex}`} label="" type="number" value={roleItem.quantity} onChange={(e) => onRoleChange(providerIndex, roleIndex, 'quantity', e.target.value)} />
                        </div>
                        <div className="w-4/12">
                            <TechSheetField id={`role-${providerIndex}-${roleIndex}`} label="" value={roleItem.role} onChange={(e) => onRoleChange(providerIndex, roleIndex, 'role', e.target.value)} suggestions={TECH_SHEET_ROLE_SUGGESTIONS} />
                        </div>
                        <div className="w-5/12">
                            <TechSheetField id={`notes-${providerIndex}-${roleIndex}`} label="" value={roleItem.notes || ''} onChange={(e) => onRoleChange(providerIndex, roleIndex, 'notes', e.target.value)} as="textarea" rows={1} />
                        </div>
                        <div className="w-1/12 flex flex-col items-center pt-2">
                            <Tooltip text="Incloure aquestes notes al PDF">
                                <input
                                    type="checkbox"
                                    checked={roleItem.printNotes ?? true}
                                    onChange={(e) => onRoleChange(providerIndex, roleIndex, 'printNotes', e.target.checked)}
                                    className="h-5 w-5 rounded border-border accent-primary focus:ring-ring"
                                />
                            </Tooltip>
                        </div>
                        <div className="w-1/12 flex-shrink-0 pt-2">
                            <Tooltip text="Eliminar aquest rol">
                                <button type="button" onClick={() => onRemoveRole(providerIndex, roleIndex)} className="text-destructive hover:bg-destructive/10 rounded-full w-8 h-8 flex items-center justify-center text-xl font-bold no-print">×</button>
                            </Tooltip>
                        </div>
                    </div>
                ))}
                <Tooltip text="Afegir un nou rol per a aquest proveïdor">
                    <button type="button" onClick={() => onAddRole(providerIndex)} className="px-3 py-1 rounded-md text-sm bg-primary text-primary-foreground hover:bg-primary/90">+ Afegir Rol</button>
                </Tooltip>
            </div>
        </div>
    );
};

export default TechnicalPersonnelSection;

--- END: ../Gestor-Events_i_Personal/src/components/tech_sheets/TechnicalPersonnelSection.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/AutosizeTextarea.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useLayoutEffect, forwardRef } from 'react';

type AutosizeTextAreaProps = React.DetailedHTMLProps<
  React.TextareaHTMLAttributes<HTMLTextAreaElement>,
  HTMLTextAreaElement
>;

const AutosizeTextarea = forwardRef<HTMLTextAreaElement, AutosizeTextAreaProps>(
  (props, ref) => {
    useLayoutEffect(() => {
      // Aquesta implementació assumeix que `ref` és un objecte ref mutable.
      // Això no està garantit per React, però és la interpretació més
      // directa de les instruccions.
      if (ref && typeof ref !== 'function' && ref.current) {
        const textarea = ref.current;
        // Reset height to recalculate scrollHeight
        textarea.style.height = 'auto';
        // Set height to scrollHeight to fit content
        textarea.style.height = `${textarea.scrollHeight}px`;
      }
    }, [props.value, ref]); // La dependència de value i ref garanteix que s'executi en cada canvi

    return <textarea ref={ref} {...props} />;
  }
);

AutosizeTextarea.displayName = 'AutosizeTextarea';

export default AutosizeTextarea;

--- END: ../Gestor-Events_i_Personal/src/components/ui/AutosizeTextarea.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/CollapsibleSection.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useEffect } from 'react';
import { ChevronUpIcon, ChevronDownIcon } from '../../constants';
import Tooltip from './Tooltip';

interface CollapsibleSectionProps {
  title: string;
  icon?: React.ReactNode;
  children: React.ReactNode;
  defaultOpen?: boolean;
  isExpanded?: boolean;
  onToggle?: () => void;
  id?: string;
  headerClassName?: string;
  contentClassName?: string;
}

const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  icon,
  children,
  defaultOpen = false,
  isExpanded,
  onToggle,
  id,
  headerClassName = '',
  contentClassName = ''
}) => {
  const [internalIsOpen, setInternalIsOpen] = useState(defaultOpen);

  // Determina si el component està obert. Prioritza el prop extern si existeix.
  const isOpen = isExpanded !== undefined ? isExpanded : internalIsOpen;

  const handleToggle = () => {
    if (onToggle) {
      onToggle();
    } else {
      setInternalIsOpen(prev => !prev);
    }
  };

  const buttonId = id ? `${id}-button` : undefined;
  const contentId = id ? `${id}-content` : undefined;

  // Sincronitza l'estat intern si el prop extern canvia (només per al cas no controlat)
  useEffect(() => {
    if (isExpanded === undefined) {
      setInternalIsOpen(defaultOpen);
    }
  }, [defaultOpen, isExpanded]);

  return (
    <div className="mb-2 bg-card rounded-lg border border-border">
      <Tooltip text={`Replegar/Expandir secció ${title}`}>
        <div
          id={buttonId}
          onClick={handleToggle}
          className={`w-full flex justify-between items-center p-3 text-left font-semibold text-foreground focus:outline-none focus:ring-2 focus:ring-ring rounded-t-lg cursor-pointer ${headerClassName}`}
          aria-expanded={isOpen}
          aria-controls={contentId}
          role="button"
          tabIndex={0}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleToggle();
            }
          }}
        >
          <div className="flex items-center gap-2">
            {icon && <React.Fragment>{icon}</React.Fragment>}
            <span>{title}</span>
          </div>
          {isOpen ? <ChevronUpIcon /> : <ChevronDownIcon />}
        </div>
      </Tooltip>
      {isOpen && <div id={contentId} className={`p-4 border-t border-border ${contentClassName}`}>{children}</div>}
    </div>
  );
};

export default CollapsibleSection;
--- END: ../Gestor-Events_i_Personal/src/components/ui/CollapsibleSection.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/CustomMenuBar.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useEffect, useRef } from 'react';
import { SunIcon, MoonIcon, ArrowUturnLeftIcon, ArrowUturnRightIcon, ClockIcon } from '../../constants';

// Define the structure of menu items
interface MenuItem {
  label?: string;
  action?: string;
  separator?: boolean;
  submenu?: MenuItem[];
  role?: string;
  accelerator?: string;
  disabled?: boolean;
  checked?: boolean;
}

interface CustomMenuBarProps {
  canUndo: boolean;
  canRedo: boolean;
  splashScreenEnabled: boolean;
  onToggleSplashScreen: () => void;
  isDocumentOpen: boolean;
  hasUnsavedChanges: boolean;
  recentFiles: string[];
  theme: string;
  onToggleTheme: () => void;
  onUndo: () => void;
  onRedo: () => void;
  onOpenHistory: () => void;
  modifierKey: string;
}

const CustomMenuBar: React.FC<CustomMenuBarProps> = ({
  canUndo,
  canRedo,
  splashScreenEnabled,
  onToggleSplashScreen,
  isDocumentOpen,
  hasUnsavedChanges,
  recentFiles,
  theme,
  onToggleTheme,
  onUndo,
  onRedo,
  onOpenHistory,
  modifierKey,
}) => {
  const [openMenu, setOpenMenu] = useState<string | null>(null);
  const menuRef = useRef<HTMLDivElement>(null);

  const handleAction = (action?: string, role?: string) => {
    if (window.electronAPI) {
      const actionToSend = action || role;
      if (actionToSend) {
        window.electronAPI.triggerMenuAction(actionToSend);
      }
    } else {
      console.warn(`Menu action "${action || role}" clicked, but Electron API is not available.`);
    }
    setOpenMenu(null);
  };

  useEffect(() => {
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setOpenMenu(null);
      }
    };
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setOpenMenu(null);
      }
    };

    document.addEventListener('keydown', handleEscape);
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const formatAccelerator = (acc?: string) => {
    if (!acc) return '';
    // If it already contains symbol characters, return as-is to avoid double-translating
    if (/[⌘⌥⌃]/.test(acc)) return acc;

    let s = acc;
    // Replace the generic token with the platform modifier (Cmd or Ctrl)
    s = s.replace(/CmdOrCtrl/g, modifierKey);

    // Normalize some token names to display-friendly symbols on mac
    if (modifierKey === '⌘') {
      s = s.replace(/\bAlt\b/g, '⌥');
      s = s.replace(/\bOption\b/g, '⌥');
      s = s.replace(/\bCtrl\b/g, '⌃');
      s = s.replace(/\bPlus\b/g, '+');
      s = s.replace(/\bMinus\b/g, '-');
    } else {
      // Non-mac: make small token normalizations
      s = s.replace(/\bPlus\b/g, '+');
      s = s.replace(/\bMinus\b/g, '-');
    }

    return s;
  };

  const menuData: { label: string; items: MenuItem[] }[] = [
    {
      label: 'Arxiu',
      items: [
        { label: 'Nou Document', action: 'new-document' },
        { label: 'Obrir...', action: 'open-document' },
        {
            label: 'Obrir Recents',
            submenu: recentFiles.length > 0
                ? recentFiles.map(f => ({ label: f, action: `open-recent:${f}` }))
                : [{ label: 'No hi ha fitxers recents', disabled: true }],
        },
        { separator: true },
        { label: 'Guardar', action: 'save-document', disabled: !isDocumentOpen || !hasUnsavedChanges },
        { label: 'Guardar com...', action: 'save-as-document', disabled: !isDocumentOpen },
        { separator: true },
        {
          label: 'Importar / Exportar',
          submenu: [
            { label: 'Importar Persones...', action: 'import-people' },
            { label: 'Exportar Persones...', action: 'export-people' },
            { separator: true },
            { label: 'Importar Material...', action: 'import-material' },
            { label: 'Exportar Material...', action: 'export-material' },
          ]
        },
        { separator: true },
        {
          label: 'Configuració Google Calendar',
          submenu: [
            { label: 'Sincronitzar', action: 'sync-google' },
            { label: 'Configurar', action: 'config-google' },
            { label: 'Connectar amb Google', action: 'connect-google' },
          ],
        },
        { separator: true },
        {
          label: 'Avançat',
          submenu: [
            { label: 'Restaurar Configuració de Fàbrica...', action: 'factory-reset' },
          ]
        },
        {separator: true},
        {label: 'Sortir', action: 'quit', accelerator: 'CmdOrCtrl+Q'},
      ],
    },
    {
      label: 'Edita',
      items: [
        { label: 'Desfer', action: 'undo', accelerator: 'CmdOrCtrl+Z', disabled: !canUndo },
        { label: 'Refer', action: 'redo', accelerator: 'CmdOrCtrl+Y', disabled: !canRedo },
        { separator: true },
        { label: 'Tallar', role: 'cut', accelerator: 'CmdOrCtrl+X' },
        { label: 'Copiar', role: 'copy', accelerator: 'CmdOrCtrl+C' },
        { label: 'Enganxar', role: 'paste', accelerator: 'CmdOrCtrl+V' },
        { separator: true },
        { label: 'Seleccionar tot', role: 'selectAll', accelerator: 'CmdOrCtrl+A' },
      ],
    },
    {
      label: 'Veure',
      items: [
        { label: 'Recarregar', role: 'reload', accelerator: 'CmdOrCtrl+R' },
        { label: 'Forçar Recàrrega', role: 'forceReload', accelerator: 'CmdOrCtrl+Shift+R' },
  // Use tokenized accelerator so we can format it consistently for each platform
  { label: 'Eines de Desenvolupament', role: 'toggleDevTools', accelerator: 'CmdOrCtrl+Alt+I' },
        { separator: true },
        { label: 'Restablir Zoom', role: 'resetZoom', accelerator: 'CmdOrCtrl+0' },
        { label: 'Apropar Zoom', role: 'zoomIn', accelerator: 'CmdOrCtrl+Plus' },
        { label: 'Allunyar Zoom', role: 'zoomOut', accelerator: 'CmdOrCtrl+-' },
        { separator: true },
  { label: 'Pantalla Completa', role: 'togglefullscreen', accelerator: modifierKey === '⌘' ? 'Ctrl+CmdOrCtrl+F' : 'F11' },
        { separator: true },
        {
          label: "Mostrar Animació d'Inici",
          action: 'toggle-splash',
          checked: splashScreenEnabled,
        },
      ],
    },
    {
      label: 'Ajuda',
      items: [
        { label: "Sobre l'aplicació...", action: 'open-about-modal' },
        { separator: true },
        { label: 'Obrir Carpeta de Còpies de Seguretat', action: 'open-backups-folder' },
        { label: 'Obrir Carpeta de Logs', action: 'open-logs-folder' },
      ],
    },
  ];

  const DropdownMenu: React.FC<{ items: MenuItem[] }> = ({ items }) => (
    <div className="absolute top-full left-0 mt-1 py-1 bg-popover text-popover-foreground border border-border rounded-md z-50 min-w-[240px]">
      {items.map((item, index) => {
        if (item.separator) {
          return <div key={`separator-${index}`} className="h-px bg-border my-1" />;
        }
        if (item.submenu) {
          return (
            <div key={item.label} className="relative group">
              <div className="w-full text-left px-4 py-2 text-sm hover:bg-accent flex justify-between items-center cursor-default">
                <span>{item.label}</span>
                <svg className="w-4 h-4 -mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path></svg>
              </div>
              <div className="absolute left-full -top-1 mt-0 py-1 bg-popover border border-border rounded-md hidden group-hover:block min-w-max">
                {item.submenu.map(subItem => (
                   <button
                      key={subItem.label}
                      onClick={() => handleAction(subItem.action, subItem.role)}
                      disabled={subItem.disabled}
                      className="block w-full text-left px-4 py-2 text-sm hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed flex justify-between items-center"
                    >
                      <span>{subItem.label}</span>
                      {subItem.accelerator && <span className="text-xs text-muted-foreground">{subItem.accelerator}</span>}
                    </button>
                ))}
              </div>
            </div>
          )
        }
        return (
          <button
            key={item.label}
            onClick={() => {
              if (item.action === 'toggle-splash') {
                onToggleSplashScreen();
                setOpenMenu(null);
              } else {
                handleAction(item.action, item.role);
              }
            }}
            disabled={item.disabled}
            className="block w-full text-left px-4 py-2 text-sm hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed flex justify-between items-center"
          >
            <span className="flex items-center">
              <span className="w-4 mr-2 text-center">{item.checked ? '✓' : ''}</span>
              <span>{item.label}</span>
            </span>
            {item.accelerator && <span className="text-xs text-muted-foreground">
              {formatAccelerator(item.accelerator)}
            </span>}
          </button>
        );
      })}
    </div>
  );

  return (
    <div ref={menuRef} className="relative flex h-8 bg-secondary text-secondary-foreground w-full justify-between" style={{ userSelect: 'none' }}>
      <div className="flex">
        {menuData.map(menu => (
          <div key={menu.label} className="relative">
            <button
              onClick={() => setOpenMenu(openMenu === menu.label ? null : menu.label)}
              onMouseEnter={() => { if (openMenu) setOpenMenu(menu.label) }}
              className={`px-3 py-1 text-sm h-full ${openMenu === menu.label ? 'bg-accent' : ''} hover:bg-accent focus:outline-none`}
            >
              {menu.label}
            </button>
            {openMenu === menu.label && <DropdownMenu items={menu.items} />}
          </div>
        ))}
      </div>
      
      {/* Icones de desfer/refer/historial i tema a la dreta */}
      <div className="flex items-center gap-1 px-2">
        <button
          onClick={onUndo}
          disabled={!canUndo}
          className="p-1 rounded hover:bg-accent focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
          title="Desfer (Ctrl+Z)"
        >
          <ArrowUturnLeftIcon className="w-5 h-5" />
        </button>
        <button
          onClick={onRedo}
          disabled={!canRedo}
          className="p-1 rounded hover:bg-accent focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
          title="Refer (Ctrl+Y)"
        >
          <ArrowUturnRightIcon className="w-5 h-5" />
        </button>
        <button
          onClick={onOpenHistory}
          disabled={!canUndo && !canRedo}
          className="p-1 rounded hover:bg-accent focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
          title="Historial de canvis"
        >
          <ClockIcon className="w-5 h-5" />
        </button>
        <button
          onClick={onToggleTheme}
          className="p-1 rounded hover:bg-accent focus:outline-none"
          title={theme === 'dark' ? 'Canviar a tema clar' : 'Canviar a tema fosc'}
        >
          {theme === 'dark' ? <SunIcon className="w-5 h-5 text-warning" /> : <MoonIcon className="w-5 h-5" />}
        </button>
      </div>
    </div>
  );
};

export default CustomMenuBar;

--- END: ../Gestor-Events_i_Personal/src/components/ui/CustomMenuBar.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/Modal.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { XMarkIcon } from '../../constants';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl' | '4xl' | '5xl' | '6xl' | '7xl';
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children, size = 'xl' }) => {
  if (!isOpen) {
    return null;
  }

  const sizeClasses = {
    sm: 'max-w-sm',
    md: 'max-w-md',
    lg: 'max-w-lg',
    xl: 'max-w-xl',
    '2xl': 'max-w-2xl',
    '3xl': 'max-w-3xl',
    '4xl': 'max-w-4xl',
    '5xl': 'max-w-5xl',
    '6xl': 'max-w-6xl',
    '7xl': 'max-w-7xl',
  };

  // No hi ha handleOverlayClick aquí, ja que hem eliminat la funcionalitat de tancar en clicar l'overlay.

  return (
    <div
      className="fixed inset-0 bg-background/80 overflow-y-auto h-full w-full flex justify-center items-center z-50"
      // L'onClick de l'overlay s'ha eliminat per evitar tancaments accidentals.
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <div
        className={`relative p-5 border border-border rounded-md bg-popover text-popover-foreground w-full ${sizeClasses[size]} mx-4`}
        // Aquest onClick evita que un clic dins del contingut es propagui a elements externs,
        // tot i que amb l'eliminació de l'onClick de l'overlay, el seu efecte principal aquí és menys crític.
        onClick={e => {
          e.stopPropagation();
        }}
      >
        <div className="flex justify-between items-center pb-3 border-b border-border">
          <h3 id="modal-title" className="text-xl font-semibold">{title}</h3>
          <button
            onClick={onClose} // Aquest onClose és per al botó X
            className="text-muted-foreground hover:text-foreground transition-colors"
            aria-label="Tancar modal"
          >
            <XMarkIcon className="w-6 h-6" />
          </button>
        </div>
        <div className="mt-4 max-h-[70vh] overflow-y-auto">
          {children}
        </div>
      </div>
    </div>
  );
};

export default Modal;

--- END: ../Gestor-Events_i_Personal/src/components/ui/Modal.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/SplashScreen.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import { useState, useEffect } from 'react';

import frame1 from '../../assets/splash/frame_1.png';
import frame2 from '../../assets/splash/frame_2.png';
import frame3 from '../../assets/splash/frame_3.png';
import frame4 from '../../assets/splash/frame_4.png';
import frame5 from '../../assets/splash/frame_5.png';
import frame6 from '../../assets/splash/frame_6.png';
import frame7 from '../../assets/splash/frame_7.png';
import frame8 from '../../assets/splash/frame_8.png';
import frame9 from '../../assets/splash/frame_9.png';

const frames = [frame1, frame2, frame3, frame4, frame5, frame6, frame7, frame8, frame9];

const SplashScreen = () => {
  const [currentFrame, setCurrentFrame] = useState(0);
  const [isFadingOut, setIsFadingOut] = useState(false);

  useEffect(() => {
    const animationInterval = setInterval(() => {
      setCurrentFrame((prevFrame) => (prevFrame + 1) % 9);
    }, 200);

    const fadeOutTimer = setTimeout(() => {
      setIsFadingOut(true);
    }, 1500);

    return () => {
      clearInterval(animationInterval);
      clearTimeout(fadeOutTimer);
    };
  }, []);

  return (
    <div
      className={`fixed inset-0 z-[9999] flex items-center justify-center transition-opacity duration-[2000ms] ${
        isFadingOut ? 'opacity-0' : 'opacity-100'
      }`}
    >
      <img src={frames[currentFrame]} alt="Splash Screen Animation" className="w-full h-full object-contain" />
    </div>
  );
};

export default SplashScreen;

--- END: ../Gestor-Events_i_Personal/src/components/ui/SplashScreen.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/SyncProgressOverlay.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';
import { SyncProgressState } from '../../types';

interface SyncProgressOverlayProps {
  progress: SyncProgressState;
}

const SyncProgressOverlay: React.FC<SyncProgressOverlayProps> = ({ progress }) => {
  if (!progress.visible) {
    return null;
  }

  const percentage = progress.total > 0 ? Math.round((progress.current / progress.total) * 100) : 0;

  return (
    <div className="fixed inset-0 bg-background/80 flex flex-col justify-center items-center z-[9999]" aria-live="assertive" role="alert">
      <div className="bg-popover text-popover-foreground p-8 rounded-lg shadow-2xl w-full max-w-md mx-4">
        <h2 className="text-xl font-semibold mb-4 text-center">Sincronitzant amb Google Calendar...</h2>

        <div className="relative pt-1">
          <div className="flex mb-2 items-center justify-between">
            <div>
              <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full bg-secondary text-secondary-foreground">
                Pas {progress.current} de {progress.total}
              </span>
            </div>
            <div className="text-right">
              <span className="text-xs font-semibold inline-block text-info">
                {percentage}%
              </span>
            </div>
          </div>
          <div className="overflow-hidden h-4 mb-4 text-xs flex rounded bg-secondary">
            <div style={{ width: `${percentage}%` }} className="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-info transition-all duration-500"></div>
          </div>
        </div>

        <p className="text-center mt-4 truncate" title={progress.message}>
          {progress.message}
        </p>
      </div>
    </div>
  );
};

export default SyncProgressOverlay;

--- END: ../Gestor-Events_i_Personal/src/components/ui/SyncProgressOverlay.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/Tooltip.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React, { useState, useRef, ReactElement, useLayoutEffect, useEffect } from 'react';
import ReactDOM from 'react-dom';

interface TooltipProps {
  text: string;
  children: ReactElement;
  /** Milliseconds to wait before showing the tooltip */
  delay?: number;
}

const Tooltip: React.FC<TooltipProps> = ({ text, children, delay = 500 }) => {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const childRef = useRef<HTMLElement>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);
  const timeoutRef = useRef<number | null>(null);

  useEffect(() => {
    // Cleanup function to clear the timeout when the component unmounts
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  const handleMouseEnter = (e: React.MouseEvent) => {
    const target = e.currentTarget as HTMLElement;
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = window.setTimeout(() => {
      const rect = target.getBoundingClientRect();
      // Set initial position - this will be adjusted by useLayoutEffect
      setPosition({
        top: rect.top + window.scrollY,
        left: rect.left + window.scrollX + rect.width / 2,
      });
      setIsVisible(true);
    }, delay);
  };

  const handleMouseLeave = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    setIsVisible(false);
  };

  useLayoutEffect(() => {
    if (isVisible && tooltipRef.current) {
      const tooltipElement = tooltipRef.current;
      const tooltipRect = tooltipElement.getBoundingClientRect();

      const PADDING = 10; // 10px padding from the window edges

      let newLeft = position.left;

      // The tooltip's left edge is at `position.left - tooltipRect.width / 2` because of the CSS transform
      const tooltipVisualLeft = position.left - tooltipRect.width / 2;
      if (tooltipVisualLeft < PADDING) {
        // It's overflowing the left edge.
        // We adjust `position.left` so that the visual left edge is at PADDING.
        newLeft = PADDING + tooltipRect.width / 2;
      }

      // The tooltip's right edge is at `position.left + tooltipRect.width / 2`
      const tooltipVisualRight = position.left + tooltipRect.width / 2;
      if (tooltipVisualRight > window.innerWidth - PADDING) {
        // It's overflowing the right edge.
        // We adjust `position.left` so that the visual right edge is at `window.innerWidth - PADDING`.
        newLeft = window.innerWidth - PADDING - tooltipRect.width / 2;
      }

      if (newLeft !== position.left) {
        setPosition(prev => ({ ...prev, left: newLeft }));
      }
    }
  }, [isVisible, position.left]); // Rerun effect if visibility or horizontal position changes

  const triggerElement = React.cloneElement(children, {
    ...children.props,
    ref: childRef,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
  });

  const tooltipContent = isVisible && (
    <div
      ref={tooltipRef}
      className="tooltip-portal"
      style={{
        top: `${position.top}px`,
        left: `${position.left}px`,
      }}
    >
      {text}
    </div>
  );

  return (
    <>
      {triggerElement}
      {typeof window !== 'undefined' && ReactDOM.createPortal(tooltipContent, document.body)}
    </>
  );
};

export default Tooltip;

--- END: ../Gestor-Events_i_Personal/src/components/ui/Tooltip.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/components/ui/WelcomeScreen.tsx -- branca DEV_pre-monorepoV1.3.0 ---
import React from 'react';

interface WelcomeScreenProps {
  recentFiles: string[];
  onNewDocument: () => void;
  onOpenDocument: () => void;
  onOpenRecent: (filePath: string) => void;
}

const WelcomeScreen: React.FC<WelcomeScreenProps> = ({
  recentFiles,
  onNewDocument,
  onOpenDocument,
  onOpenRecent,
}) => {
  return (
    <div className="flex flex-col items-center justify-center h-full bg-background text-foreground">
      <div className="text-center p-8 max-w-2xl">
        <h1 className="text-4xl font-bold mb-4">Gestor d'Esdeveniments</h1>
        <p className="text-lg mb-8 text-muted-foreground">
          Benvingut/da. Si us plau, obre un document existent o crea'n un de nou per començar.
        </p>
        <div className="flex justify-center space-x-4 mb-12">
          <button
            onClick={onNewDocument}
            className="px-6 py-3 bg-primary text-primary-foreground font-semibold rounded-lg shadow-md hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-opacity-75"
          >
            Nou Document
          </button>
          <button
            onClick={onOpenDocument}
            className="px-6 py-3 bg-secondary text-secondary-foreground font-semibold rounded-lg shadow-md hover:bg-secondary/80 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-opacity-75"
          >
            Obrir...
          </button>
        </div>

        {recentFiles.length > 0 && (
          <div>
            <h2 className="text-2xl font-semibold mb-4">Documents Recents</h2>
            <ul className="space-y-2 text-left">
              {recentFiles.map((filePath, index) => (
                <li key={index} className="bg-card p-3 rounded-lg shadow-sm hover:bg-accent transition-colors">
                  <button
                    onClick={() => onOpenRecent(filePath)}
                    className="w-full text-left focus:outline-none"
                  >
                    <span className="font-mono text-primary">{filePath}</span>
                  </button>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </div>
  );
};

export default WelcomeScreen;

--- END: ../Gestor-Events_i_Personal/src/components/ui/WelcomeScreen.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/constants.tsx -- branca DEV_pre-monorepoV1.3.0 ---
// @ts-ignore - React is used in JSX
import React, { FC } from 'react';
import { ArrowUturnLeftIcon as OutlineArrowUturnLeftIcon, ArrowUturnRightIcon as OutlineArrowUturnRightIcon, DocumentArrowDownIcon as OutlineDocumentArrowDownIcon } from '@heroicons/react/24/outline';
import { AssignmentStatus } from './types';

export const APP_TITLE = "Gestor de Esdeveniments i Personal v0.2";
export const THEME_STORAGE_KEY = 'eventManagementAppTheme';

export const ASSIGNMENT_STATUS_OPTIONS = [
  { value: AssignmentStatus.Pending, label: 'Pendent' },
  { value: AssignmentStatus.Yes, label: 'Sí' },
  { value: AssignmentStatus.No, label: 'No' },
  { value: AssignmentStatus.Mixed, label: 'Mixt' },
];

export const SaveIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
  </svg>
);

export const LoadIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
  </svg>
);

export const PlusIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
  </svg>
);

export const EditIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
  </svg>
);

export const TrashIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.56 0c1.153 0 2.24.03 3.22.077m3.22-.077L10.828 4.28A2.25 2.25 0 0112.89 3h2.221a2.25 2.25 0 012.061 1.28l.513.986" />
  </svg>
);

export const UserPlusIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M19 7.5v3m0 0v3m0-3h3m-3 0h-3m-2.25-4.125a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zM4 19.235v-.11a6.375 6.375 0 0112.75 0v.109A12.318 12.318 0 0110.374 21c-2.331 0-4.512-.645-6.374-1.766z" />
  </svg>
);

export const UsersIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M15 19.128a9.38 9.38 0 002.625.372 9.337 9.337 0 004.121-.952 4.125 4.125 0 00-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 018.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0111.964-3.07M12 6.375a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zm8.25 2.25a2.625 2.625 0 11-5.25 0 2.625 2.625 0 015.25 0z" />
  </svg>
);

export const CalendarIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0v-7.5A2.25 2.25 0 015.25 9h13.5A2.25 2.25 0 0121 11.25v7.5m-9-6h.008v.008H12v-.008zM12 15h.008v.008H12V15zm0 2.25h.008v.008H12v-.008zM9.75 15h.008v.008H9.75V15zm0 2.25h.008v.008H9.75v-.008zM7.5 15h.008v.008H7.5V15zm0 2.25h.008v.008H7.5v-.008zm6.75-4.5h.008v.008h-.008v-.008zm0 2.25h.008v.008h-.008V15zm0 2.25h.008v.008h-.008v-.008zm2.25-4.5h.008v.008H16.5v-.008zm0 2.25h.008v.008H16.5V15z" />
  </svg>
);

export const ListIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
  </svg>
);

export const ChartBarIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" />
    </svg>
);

export const SunIcon = ({ className = "w-6 h-6" } : {className?: string}) => (
  <svg data-testid="sun-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-6.364-.386l1.591-1.591M3 12h2.25m.386-6.364l1.591 1.591M12 8.25A3.75 3.75 0 0115.75 12 3.75 3.75 0 0112 15.75 3.75 3.75 0 018.25 12 3.75 3.75 0 0112 8.25z" />
  </svg>
);

export const MoonIcon = ({ className = "w-6 h-6" } : {className?: string}) => (
  <svg data-testid="moon-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
  </svg>
);

export const ChevronDownIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
);

export const ChevronRightIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
  </svg>
);

export const ChevronUpIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
  </svg>
);

export const CsvIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M9 13.5l3 3m0 0l3-3m-3 3v-6m1.06-4.19l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
  </svg>
);

export const PdfIcon = ({ className = "w-5 h-5" }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m.75 12l3 3m0 0l3-3m-3 3v-6m-1.5-9H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
  </svg>
);

export const EyeIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" />
    <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  </svg>
);

export const XMarkIcon = ({ className = "w-6 h-6" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
  </svg>
);

export const InfoIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" />
  </svg>
);
export const InformationCircleIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" />
  </svg>
);
export const PersonAddIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16" className={className}>
    <path d="M12.5 16a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7m.5-5v1h1a.5.5 0 0 1 0 1h-1v1a.5.5 0 0 1-1 0v-1h-1a.5.5 0 0 1 0-1h1v-1a.5.5 0 0 1 1 0m-2-6a3 3 0 1 1-6 0 3 3 0 0 1 6 0"/>
    <path d="M2 13c0-1 1-2 3-2h5.259a4.5 4.5 0 0 1 .254-.834H5a2 2 0 0 0-2 2v2h4a4.5 4.5 0 0 1 .502-1z"/>
  </svg>
);

export const SyncIcon = ({ className = "w-5 h-5" } : {className?: string}) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.181-3.183m-11.664 0l4.992-4.993m-4.993 0l-3.181 3.183a8.25 8.25 0 000 11.664l3.181 3.183" />
  </svg>
);

export const BoxIcon = ({ className = "w-5 h-5" }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9.75l-9-5.25m9 5.25l9-5.25" />
  </svg>
);

export const GoogleIcon = ({ className = "w-5 h-5" }) => (
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" className={className}>
    <path fill="#4285F4" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z" />
    <path fill="#34A853" d="M43.611 20.083H24v8h11.303c-1.649 4.657-6.08 8-11.303 8V44c5.268 0 10.046-1.953 13.591-5.639l-5.657-5.657z" />
    <path fill="#FBBC05" d="M11.636 14.876c-1.933 2.419-3.095 5.564-3.095 8.999s1.162 6.58 3.095 8.999L6.045 38.636C2.12 34.61 0 29.598 0 24s2.12-10.61 6.045-14.636z" />
    <path fill="#EA4335" d="M43.611 20.083L37.954 14.426C34.046 10.498 29.268 8 24 8c-3.059 0-5.842 1.154-7.961 3.039l5.657 5.657C23.286 16.08 24.516 16 26 16c5.223 0 9.651 3.343 11.303 8H24v-8h19.611z" />
  </svg>
);

export const TECH_SHEET_ROLE_SUGGESTIONS = [
  // Direcció i Coordinació
  "Direcció: Cap Tècnic/a",
  "Direcció: Cap de Sala",
  "Direcció: Regidoria",
  "Direcció: Assistent/a de Regidoria",
  "Producció: Producció",
  "Producció: Auxiliar de Producció",
  // Equip Tècnic (Operació)
  "Tècnic/a: So",
  "Tècnic/a: Il·luminació",
  "Tècnic/a: Vídeo",
  "Tècnic/a: Operació de Càmera",
  "Tècnic/a: So (PA)",
  "Tècnic/a: Monitors",
  "Tècnic/a: Maquinària",
  "Tècnic: Microfonísta",
  // Equip Tècnic (Muntatge)
  "Muntatge: Maqui",
  "Muntatge: Maquinista / Rigger",
  "Muntatge: Auxiliar de Càrrega i Descàrrega",
  "Muntatge: Personal de Muntatge (Crew)",
  "Muntatge: Conductor/a",
  // Atenció al Públic
  "Públic: Personal de Sala / Acomodació",
  "Públic: Personal de Taquilles",
  "Públic: Personal de Seguretat",
  // Artístic i Suport
  "Suport: Rider / Road Manager",
  "Suport: Assistent/a Personal",
];

export const ArrowUturnLeftIcon: FC<{ className?: string }> = ({ className = "w-5 h-5" }) => (
  <OutlineArrowUturnLeftIcon className={className} />
);

export const ArrowUturnRightIcon: FC<{ className?: string }> = ({ className = "w-5 h-5" }) => (
  <OutlineArrowUturnRightIcon className={className} />
);

export const DocumentArrowDownIcon: FC<{ className?: string }> = ({ className = "w-5 h-5" }) => (
  <OutlineDocumentArrowDownIcon className={className} />
);

export const ClockIcon: FC<{ className?: string }> = ({ className = "w-5 h-5" }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

export const ArchiveIcon: FC<{ className?: string }> = ({ className = "w-5 h-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" />
    </svg>
);

export const RestoreIcon: FC<{ className?: string }> = ({ className = "w-5 h-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
    </svg>
);

export const CloudArrowUpIcon: FC<{ className?: string }> = ({ className = "w-5 h-5" }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 8.25c0 3.105-2.686 5.625-6 5.625S5.25 11.355 5.25 8.25 7.936 2.625 11.25 2.625s6 2.686 6 5.625z" />
  </svg>
);
--- END: ../Gestor-Events_i_Personal/src/constants.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/images.d.ts -- branca DEV_pre-monorepoV1.3.0 ---
declare module '*.png' {
  const value: any;
  export default value;
}

--- END: ../Gestor-Events_i_Personal/src/images.d.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/index.css -- branca DEV_pre-monorepoV1.3.0 ---
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 35 25% 92%;
    --card: 35 15% 85%;
    --popover: 35 15% 85%;
    --secondary: 35 20% 88%;
    --muted: 35 10% 83%;
    --border: 35 10% 50%;
    --input: 35 15% 88%;
    --accent: 220 15% 86%;
    --foreground: 240 10% 10%;
    --card-foreground: 240 10% 10%;
    --popover-foreground: 240 10% 10%;
    --secondary-foreground: 240 8% 25%;
    --muted-foreground: 240 5% 40%;
    --accent-foreground: 240 10% 10%;
    --primary-foreground: 210 40% 98%;
    --primary: 220 35% 25%;
    --destructive: 0 75% 55%;
    --success: 140 65% 40%;
    --warning: 45 85% 55%;
    --info: 210 70% 45%;
    --mixed-status: 280 40% 55%;
    --ring: 220 35% 45%;
    --destructive-foreground: 30 100% 98%;
    --success-foreground: 140 100% 98%;
    --warning-foreground: 240 10% 10%;
    --info-foreground: 210 100% 98%;
    --mixed-status-foreground: 280 100% 98%;
    --radius: 0.5rem;

    /* Colors per a fons de files (estil DEV, sòlid i viu) */
    --daily-row-yes-bg: hsl(var(--success));
    --daily-row-no-bg: hsl(var(--destructive));
    --daily-row-pending-bg: hsl(var(--warning));
    --daily-row-mixed-bg: hsla(var(--muted) / 0.5);

    /* Altres (ara derivats del tema) */
    --highlight-bg: var(--warning);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);

    /* Variables fixes per als esdeveniments del calendari (estil fosc permanent) */
    --calendar-event-bg: 240 5.9% 19%; /* Correspon a --card en dark mode */
    --calendar-event-fg: 210 40% 98%;   /* Correspon a --card-foreground en dark mode */
  }

  .dark {
    --background: 40 6% 10%;
    --card: 40 6% 15%;
    --popover: 40 6% 15%;
    --border: 40 6% 50%;
    --input: 40 6% 21%;
    --secondary: 40 6% 20%;
    --muted: 40 4% 17%;
    --accent: 220 10% 22%;
    --foreground: 40 5% 96%;
    --card-foreground: 40 5% 96%;
    --popover-foreground: 40 5% 96%;
    --secondary-foreground: 40 5% 96%;
    --muted-foreground: 40 4% 65%;
    --accent-foreground: 40 5% 96%;
    --primary: 221.2 76% 53.3%;
    --destructive: 0 68% 50.6%;
    --success: 142.1 65% 45.3%;
    --warning: 47.9 88% 55%;
    --info: 215 68% 48%;
    --mixed-status: 283 65% 50%;
    --ring: 221.2 83.2% 53.3%;
    --primary-foreground: 220 13% 97%;
    --destructive-foreground: 210 20% 98%;
    --success-foreground: 145 60% 98%;
    --warning-foreground: 48 95% 98%;
    --info-foreground: 210 20% 98%;
    --mixed-status-foreground: 280 60% 98%;

    /* Colors per a fons de files - Dark Mode (estil DEV, sòlid i viu) */
    --daily-row-yes-bg: hsl(var(--success));
    --daily-row-no-bg: hsl(var(--destructive));
    --daily-row-pending-bg: hsl(var(--warning));
    --daily-row-mixed-bg: hsla(var(--muted) / 0.5);

    /* Altres - Dark Mode (ara derivats del tema) */
    --highlight-bg: var(--warning);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -2px rgba(0, 0, 0, 0.2);
  }
}

@keyframes highlight-fade {
  from {
    background-color: hsla(var(--highlight-bg), 0.5);
    outline: 2px solid hsla(var(--highlight-bg), 0.8);
  }
  to {
    background-color: transparent;
    outline: 2px solid transparent;
  }
}

.highlight-event-frame {
  animation: highlight-fade 3s ease-out forwards;
}

.section {
  margin-bottom: 5px;
  padding: 4px;
}

/* Reducir espaciado en pantallas medianas */
@media (min-width: 1024px) and (max-width: 1279px) {
  .section { margin-bottom: 5px; padding: 4px; }
  .form-grid { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; }
  .form-group { margin-bottom: 6px; }
  .modal-content { padding: 16px; max-width: 95%; }
  .table-responsive { margin: 0; }
  #events-table th, #events-table td { padding: 4px 6px; }
  .calendar-wrapper { padding: 0.25rem; }
  input[type="text"], input[type="date"], input[type="search"], input[type="email"], input[type="tel"], input[type="url"], select, textarea { padding: 6px 8px; }
  .btn { padding: 6px 12px; }
}

@layer components {
  /* Fons per a cada fila diària */
  .daily-row-yes { background-color: var(--daily-row-yes-bg); }
  .daily-row-no { background-color: var(--daily-row-no-bg); }
  .daily-row-pending { background-color: var(--daily-row-pending-bg); }
  .daily-row-mixed { background-color: var(--daily-row-mixed-bg); }

  /* Estils per als botons de canvi d'estat (píndoles) */
  .status-pill { @apply px-2.5 py-0.5 text-xs font-bold rounded-full transition-all duration-150 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-ring focus:ring-offset-background; }
  .status-pill-selected-yes { background-color: hsl(var(--success)); box-shadow: var(--shadow-md); }
  .status-pill-selected-yes:focus { --tw-ring-color: hsl(var(--success)); }
  .status-pill-selected-no { background-color: hsl(var(--destructive)); box-shadow: var(--shadow-md); }
  .status-pill-selected-no:focus { --tw-ring-color: hsl(var(--destructive)); }
  .status-pill-selected-pending { background-color: hsl(var(--warning)); box-shadow: var(--shadow-md); }
  .status-pill-selected-pending:focus { --tw-ring-color: hsl(var(--warning)); }
  .status-pill-selected-mixed { background-color: hsl(var(--mixed-status)); box-shadow: var(--shadow-md); }
  .status-pill-selected-mixed:focus { --tw-ring-color: hsl(var(--mixed-status)); }
  .status-pill-unselected { @apply bg-secondary text-secondary-foreground/70 hover:bg-accent hover:text-accent-foreground; }

  /* Portal Tooltip Styles */
  .tooltip-portal {
    position: absolute;
    transform: translate(-50%, calc(-100% - 8px));
    padding: 4px 8px;
    background-color: hsl(var(--popover));
    color: hsl(var(--popover-foreground));
    border: 1px solid hsl(var(--border));
    border-radius: var(--radius);
    font-size: 12px;
    font-weight: 600;
    z-index: 10000;
    pointer-events: none;
    white-space: normal;
    max-width: 250px;
    box-shadow: var(--shadow-md);
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
  }

  .bg-gradient-mixed {
    background-image: linear-gradient(to right, hsla(var(--success) / 0.3), hsla(var(--warning) / 0.3), hsla(var(--destructive) / 0.3));
  }
}
--- END: ../Gestor-Events_i_Personal/src/index.css -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/index.tsx -- branca DEV_pre-monorepoV1.3.0 ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
--- END: ../Gestor-Events_i_Personal/src/index.tsx -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/stores/eventDataStore.ts -- branca DEV_pre-monorepoV1.3.0 ---


import { create } from 'zustand';
// import eliminat: useStoreWithEqualityFn
import { useStore } from 'zustand';
import { temporal, TemporalState } from 'zundo';
import { useModalStore } from './modalStore';
import { useGoogleConfigStore } from './googleConfigStore';
import { EventFrame, PersonGroup, Assignment, AppData, EventFrameForExport, AssignmentStatus, TechSheetData, MaterialItem, SyncProgressState, NeedItem, AssignmentOperationResult, MaterialControlRow, TechSheetProvider } from '../types';
import { formatDateDMY } from '../utils/dateFormat';
import { migrateTechSheetData } from '../utils/techSheetMigration';
import { validateData, repairData } from '../utils/dataIntegrity';
import logger from '../utils/logger';
import { immer } from 'zustand/middleware/immer';
import { notificationService } from '../utils/notificationService';

const generateId = () => Date.now().toString(36) + Math.random().toString(36).substring(2);

const createDefaultTechSheet = (eventFrame: Omit<EventFrame, 'id' | 'assignments' | 'personnelComplete' | 'techSheet'>): TechSheetData => {
    const defaultConditional = () => ({ status: 'unset' as const, details: '', needs: [] as NeedItem[] });
    return {
      eventName: eventFrame.name,
      location: eventFrame.place || '',
      date: formatDateDMY(eventFrame.startDate),
      showTime: '',
      showDuration: '',
      technicalProviders: [],
      generalNotes: '',
      parking: { status: 'unset', details: '' },
      preAssembly: { status: 'unset', details: '' },
      schedule: { status: 'unset', details: '', data: [] },
      dressingRooms: { status: 'unset', details: '' },
      actorsInfo: { status: 'unset', details: '', data: { number: 0, names: '' } },
      techniciansInfo: { status: 'unset', details: '', data: { number: 0, names: '' } },
      lighting: defaultConditional(),
      sound: defaultConditional(),
      video: defaultConditional(),
      machinery: defaultConditional(),
      rentals: defaultConditional(),
      otherEquipment: defaultConditional(),
      electrical: defaultConditional(),
      structures: defaultConditional(),
      platforms: defaultConditional(),
      consumables: defaultConditional(),
      curtains: defaultConditional(),
      transport: defaultConditional(),
      controlLocation: '',
      blueprints: '',
      contacts: [],
      observations: '',
      showLogistics: true,
      showPreAssembly: true,
      showSchedule: true,
      showNeeds: true,
      showOther: true,
      showGeneralNotesInPdf: true,
    };
  };

export interface EventDataState {
    eventFrames: EventFrame[];
    peopleGroups: PersonGroup[];
    materialItems: MaterialItem[];
    googleEvents: any[];
    hasUnsavedChanges: boolean;
    isSyncing: boolean;
    isUpdatingMaterial: boolean;
    syncProgress: SyncProgressState;
    dataRepairInfo: { fixes: any[], repairedData: AppData } | null;
    filterUIEventFrame: string | null;
    highlightedEventId: string | null;
    lastActionDescription: string | null;
    // Filtres centralitzats
    filterText: string;
    filterStatus: AssignmentStatus | '';
    filterDate: string;
    localFilterUIPerson: string;
    filterPlace: string;
    // Estats per a l'expansió automàtica
    isEventListExpanded: boolean;
    manualExpandedFrameIds: Set<string>;
}

interface EventDataActions {
    setFilterUIEventFrame: (id: string | null) => void;
    setHighlightedEventId: (id: string | null) => void;
    // Accions per als filtres centralitzats
    setFilterText: (text: string) => void;
    setFilterStatus: (status: AssignmentStatus | '') => void;
    setFilterDate: (date: string) => void;
    setLocalFilterUIPerson: (personId: string) => void;
    setFilterPlace: (place: string) => void;
    clearAllFilters: () => void;
    setSyncProgress: (progress: SyncProgressState) => void;
    showAndHighlightEvent: (eventId: string) => void;
    setManualExpandedFrameIds: (updater: (prev: Set<string>) => Set<string>) => void;
    toggleEventListExpanded: () => void;
    addEventFrame: (eventFrame: Omit<EventFrame, 'id' | 'assignments' | 'personnelComplete' | 'techSheet'>) => EventFrame;
    updateEventFrame: (eventFrame: EventFrame) => void;
    deleteEventFrame: (eventFrameId: string) => void;
    getEventFrameById: (eventFrameId: string) => EventFrame | undefined;
    addPersonGroup: (personGroup: Omit<PersonGroup, 'id'>) => void;
    updatePersonGroup: (personGroup: PersonGroup) => void;
    deletePersonGroup: (personGroupId: string) => void;
    getPersonGroupById: (personGroupId: string) => PersonGroup | undefined;
    addAssignment: (eventFrameId: string, assignment: Omit<Assignment, 'id' | 'eventFrameId' | 'dailyStatuses'>, force?: boolean) => AssignmentOperationResult;
    updateAssignment: (assignment: Assignment, force?: boolean, context?: { changedDate?: string }) => AssignmentOperationResult;
    deleteAssignment: (eventFrameId: string, assignmentId: string) => void;
    getAssignmentById: (eventFrameId: string, assignmentId: string) => Assignment | undefined;
    loadData: (data: AppData | null) => Promise<{ status: 'ok' | 'needs_confirmation' | 'error'; fixes?: string[], message?: string, type?: 'success' | 'error' | 'info' | 'warning' }>;
    loadGoogleConfigFromDataFile: (data: AppData) => Promise<{ success: boolean, message?: string, type?: 'success' | 'error' | 'info' | 'warning' }>;
    exportData: () => Promise<AppData>;
    setPersonnelComplete: (eventFrameId: string, complete: boolean) => void;
    setHasUnsavedChanges: (value: boolean) => void;
    refreshGoogleEvents: () => Promise<{ success: boolean, message?: string, type?: 'success' | 'error' | 'info' | 'warning' }>;
    syncWithGoogle: () => Promise<void>;
    executeSync: (targetCalendarId: string) => Promise<any>;
    addOrUpdateTechSheet: (eventFrameId: string, fitxaData: TechSheetData) => void;
    reorderTechnicalProviders: (eventFrameId: string, reorderedProviders: TechSheetProvider[]) => void;
    addMaterialItem: (newItemData: Omit<MaterialItem, 'id'>) => MaterialItem;
    updateMaterialItem: (updatedItem: MaterialItem) => void;
    deleteMaterialItem: (itemId: string) => void;
    addMaterialItemsFromFile: (newItems: MaterialItem[]) => { success: boolean, message: string, type: 'success' | 'error' | 'info' | 'warning' };
    getMaterialAvailability: (materialId: string, startDate: string, endDate: string, currentEventFrameId: string) => { available: number, total: number };
    mergePeopleGroups: (newPeople: PersonGroup[]) => { success: boolean, message: string, type: 'success' | 'error' | 'info' | 'warning' };
    replacePeopleGroups: (newPeople: PersonGroup[]) => void;
    replaceMaterialItems: (newItems: MaterialItem[]) => void;
    _applyDataToState: (data: AppData) => void;
    clearDataRepairInfo: () => void;
    setIsUpdatingMaterial: (isUpdating: boolean) => void;
    undoWithToast: () => void;
    redoWithToast: () => void;
    archiveOldEventFrames: () => EventFrame[];
    confirmArchiveEventFrames: (eventFrameIds: string[]) => void;
    restoreEventFrame: (eventFrameId: string) => void;
}

const initialState: EventDataState = {
    eventFrames: [],
    peopleGroups: [],
    materialItems: [],
    googleEvents: [],
    hasUnsavedChanges: false,
    isSyncing: false,
    isUpdatingMaterial: false,
    syncProgress: { current: 0, total: 0, message: '', visible: false },
    dataRepairInfo: null,
    filterUIEventFrame: null,
    highlightedEventId: null,
    lastActionDescription: null,
    // Filtres centralitzats - valors inicials
    filterText: '',
    filterStatus: '',
    filterDate: '',
    localFilterUIPerson: '',
    filterPlace: '',
    // Estats per a l'expansió automàtica - valors inicials
    isEventListExpanded: false,
    manualExpandedFrameIds: new Set<string>(),
};

export const useEventDataStore = create<EventDataState & EventDataActions>()(
  temporal(
    immer(
      (set, get) => ({
        ...initialState,

        setIsUpdatingMaterial: (isUpdating: boolean) => set({ isUpdatingMaterial: isUpdating }),

        undoWithToast: () => {
            const { temporal } = useEventDataStore;
            // Get the description of the action that is about to be undone.
            const currentDescription = get().lastActionDescription;

            temporal.getState().undo();

            if (currentDescription) {
                notificationService.info(`Desfeta l'acció: ${currentDescription}`);
            } else {
                notificationService.info('Acció desfeta.');
            }
        },

        redoWithToast: () => {
            const { temporal } = useEventDataStore;

            temporal.getState().redo();

            // After redoing, the current state has the description of the redone action.
            const newDescription = get().lastActionDescription;
            if (newDescription) {
                notificationService.info(`Refeta l'acció: ${newDescription}`);
            } else {
                notificationService.info('Acció refeta.');
            }
        },

        clearDataRepairInfo: () => set({ dataRepairInfo: null }),

        // UTILS
        setHasUnsavedChanges: (value: boolean) => set({ hasUnsavedChanges: value }),
        setFilterUIEventFrame: (id: string | null) => set({ filterUIEventFrame: id }),
        setHighlightedEventId: (id: string | null) => set({ highlightedEventId: id }),
        
        // FILTRES CENTRALITZATS
        setFilterText: (text: string) => set({ filterText: text }),
        setFilterStatus: (status: AssignmentStatus | '') => set({ filterStatus: status }),
        setFilterDate: (date: string) => set({ filterDate: date }),
        setLocalFilterUIPerson: (personId: string) => set({ localFilterUIPerson: personId }),
        setFilterPlace: (place: string) => set({ filterPlace: place }),
        clearAllFilters: () => set({ 
            filterText: '', 
            filterStatus: '', 
            filterDate: '', 
            localFilterUIPerson: '', 
            filterPlace: '',
            filterUIEventFrame: null,
            highlightedEventId: null
        }),
        setSyncProgress: (progress: SyncProgressState) => set({ syncProgress: progress }),
        showAndHighlightEvent: (eventId: string) => {
            logger.info(`[eventDataStore] showAndHighlightEvent called for ID: ${eventId}`);
            const newManualExpandedFrameIds = new Set(get().manualExpandedFrameIds);
            newManualExpandedFrameIds.add(eventId);
            set({
                isEventListExpanded: true,
                manualExpandedFrameIds: newManualExpandedFrameIds,
                highlightedEventId: eventId
            });
            logger.info(`[eventDataStore] state updated for highlighting:`, { isEventListExpanded: true, highlightedEventId: eventId });
        },
        setManualExpandedFrameIds: (updater: (prev: Set<string>) => Set<string>) => {
            const oldSet = get().manualExpandedFrameIds;
            const newSet = updater(oldSet);
            logger.info('[eventDataStore] setManualExpandedFrameIds called.', { from: Array.from(oldSet), to: Array.from(newSet) });
            set({ manualExpandedFrameIds: newSet });
        },
        toggleEventListExpanded: () => set((state) => ({ isEventListExpanded: !state.isEventListExpanded })),

        // DATA HYDRATION
            _applyDataToState: (data: AppData) => {
            const loadedEventFrames: EventFrame[] = (data.eventFrames || []).map((efExport: EventFrameForExport) => ({
                ...efExport,
                assignments: (data.assignments || []).filter((a: Assignment) => a.eventFrameId === efExport.id).sort((a: Assignment, b: Assignment) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime()),
                personnelComplete: efExport.personnelComplete || false,
                techSheet: migrateTechSheetData(efExport.techSheet, efExport as EventFrame),
            }));

            set({
                eventFrames: loadedEventFrames.sort((a: EventFrame,b: EventFrame) => new Date(b.startDate).getTime() - new Date(a.startDate).getTime() || a.name.localeCompare(b.name)),
                peopleGroups: (data.peopleGroups || []).sort((a: PersonGroup,b: PersonGroup) => a.name.localeCompare(b.name)),
                materialItems: (data.materialItems || []).sort((a: MaterialItem,b: MaterialItem) => a.name.localeCompare(b.name)),
                hasUnsavedChanges: false,
                lastActionDescription: 'Dades carregades des d\'un arxiu',
            });
        },
    loadData: async (data: AppData | null) => {
        const { _applyDataToState } = get();
        const { clear: clearHistory } = useEventDataStore.temporal.getState();
        logger.info("Iniciant la càrrega de dades (sense Google)...", { hasData: !!data });

        if (!data) {
            set((state) => {
                Object.assign(state, initialState);
                state.lastActionDescription = 'Projecte netejat';
            });
            clearHistory();
            return { status: 'ok', message: 'Estat de l\'aplicació netejat.', type: 'info' };
        }

        const migratedData: AppData = { ...data, eventFrames: data.eventFrames.map((ef: EventFrameForExport) => ({ ...ef, techSheet: migrateTechSheetData(ef.techSheet, ef as EventFrame) })) };
        const validationResult = validateData(migratedData);

        if (validationResult.isValid) {
          _applyDataToState(migratedData);
          clearHistory();
          return { status: 'ok', message: "Dades carregades amb èxit.", type: 'success' };
        } else {
          const { repairedData, fixes } = repairData(migratedData, validationResult.errors);
          set({ dataRepairInfo: { repairedData, fixes } });
          return { status: 'needs_confirmation', fixes };
        }
      },
    loadGoogleConfigFromDataFile: async (data: AppData) => {
        const { refreshGoogleEvents } = get();
        if (data?.googleConfig) {
            try {
                const { activeAppCalendarId, managedAppCalendars } = data.googleConfig;
                const prevConfig = useGoogleConfigStore.getState();

                const newMergedConfig = {
                    activeCalendarId: activeAppCalendarId ?? prevConfig.activeCalendarId,
                    managedCalendars: managedAppCalendars ?? prevConfig.managedCalendars,
                    selectedIds: prevConfig.selectedIds, // Preserve existing selections
                };

                useGoogleConfigStore.setState(newMergedConfig);

                if (window.electronAPI?.saveGoogleConfig) {
                    await window.electronAPI.saveGoogleConfig({
                        activeAppCalendarId: newMergedConfig.activeCalendarId,
                        managedAppCalendars: newMergedConfig.managedCalendars,
                    });
                }

                await refreshGoogleEvents();
                return { success: true, message: 'Configuració de Google carregada i desada correctament.', type: 'success' };
            } catch (error) {
                logger.error("Error actualitzant la configuració de Google des del fitxer:", { error });
                return { success: false, message: "No s'ha pogut actualitzar la configuració de Google des del fitxer.", type: 'error' };
            }
        }
        return { success: true, message: 'No hi havia configuració de Google per carregar.', type: 'info' };
    },
    exportData: async () => {
        const { eventFrames, peopleGroups, materialItems } = get();
        const allAssignmentsList: Assignment[] = eventFrames.flatMap((ef: EventFrame) => ef.assignments);
        const eventFramesForExport: EventFrameForExport[] = eventFrames.map(({ assignments, ...restOfFrame }: EventFrame) => restOfFrame);
        let googleConfigForExport: AppData['googleConfig'] = undefined;
        if (window.electronAPI) {
            const fullConfig = await window.electronAPI.loadGoogleConfig();
            if (fullConfig) {
                googleConfigForExport = { userEmail: fullConfig.userEmail, activeAppCalendarId: fullConfig.activeAppCalendarId, managedAppCalendars: fullConfig.managedAppCalendars };
            }
        }
        const dataToExport = { peopleGroups, eventFrames: eventFramesForExport, materialItems, assignments: allAssignmentsList, googleConfig: googleConfigForExport };
        // Assegurem que l'objecte és totalment serialitzable abans de passar-lo per IPC
        return JSON.parse(JSON.stringify(dataToExport));
    },

    // EVENT FRAMES
    addEventFrame: (newEventFrameData: Omit<EventFrame, 'id' | 'assignments' | 'personnelComplete' | 'techSheet'>) => {
        const newEventFrame: EventFrame = { ...newEventFrameData, id: generateId(), assignments: [], personnelComplete: false, techSheet: createDefaultTechSheet(newEventFrameData) };
        set((state: EventDataState) => {
            state.eventFrames.push(newEventFrame);
            state.eventFrames.sort((a: EventFrame,b: EventFrame) => new Date(b.startDate).getTime() - new Date(a.startDate).getTime() || a.name.localeCompare(b.name));
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has creat l'esdeveniment «${newEventFrame.name}»`;
        });
        return newEventFrame;
    },
    updateEventFrame: (updatedEventFrame: EventFrame) => {
        set((state: EventDataState) => {
            const frameIndex = state.eventFrames.findIndex(ef => ef.id === updatedEventFrame.id);
            if (frameIndex !== -1) {
                state.eventFrames[frameIndex] = updatedEventFrame;
            }
            state.eventFrames.sort((a: EventFrame,b: EventFrame) => new Date(b.startDate).getTime() - new Date(a.startDate).getTime() || a.name.localeCompare(b.name));
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has modificat l'esdeveniment «${updatedEventFrame.name}»`;
        });
    },
    deleteEventFrame: (eventFrameId: string) => {
        const eventFrameName = get().eventFrames.find(ef => ef.id === eventFrameId)?.name || 'desconegut';
        set((state: EventDataState) => {
            state.eventFrames = state.eventFrames.filter((ef: EventFrame) => ef.id !== eventFrameId);
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has suprimit l'esdeveniment «${eventFrameName}»`;
        });
    },
    getEventFrameById: (eventFrameId: string) => get().eventFrames.find((ef: EventFrame) => ef.id === eventFrameId),
    setPersonnelComplete: (eventFrameId: string, complete: boolean) => {
        const eventFrameName = get().eventFrames.find(ef => ef.id === eventFrameId)?.name || 'desconegut';
        set((state: EventDataState) => {
            const frame = state.eventFrames.find(ef => ef.id === eventFrameId);
            if (frame) {
                frame.personnelComplete = complete;
            }
            state.hasUnsavedChanges = true;
            state.lastActionDescription = complete
              ? `Has marcat el personal de «${eventFrameName}» com a completat`
              : `Has marcat el personal de «${eventFrameName}» com a pendent`;
        });
    },
    addOrUpdateTechSheet: (eventFrameId: string, techSheetData: TechSheetData) => {
        const eventFrameName = get().eventFrames.find(ef => ef.id === eventFrameId)?.name || 'desconegut';
        set((state: EventDataState) => {
            const frame = state.eventFrames.find(ef => ef.id === eventFrameId);
            if (frame) {
                frame.techSheet = techSheetData;
            }
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has actualitzat la fitxa tècnica de «${eventFrameName}»`;
        });
    },
    reorderTechnicalProviders: (eventFrameId: string, reorderedProviders: TechSheetProvider[]) => {
        const eventFrameName = get().eventFrames.find(ef => ef.id === eventFrameId)?.name || 'desconegut';
        set(state => {
            const frame = state.eventFrames.find(ef => ef.id === eventFrameId);
            if (frame && frame.techSheet) {
                frame.techSheet.technicalProviders = reorderedProviders;
            }
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has reordenat el personal tècnic de «${eventFrameName}»`;
        });
    },

    // ASSIGNMENTS
    addAssignment: (eventFrameId: string, newAssignmentData: Omit<Assignment, 'id' | 'eventFrameId' | 'dailyStatuses'>, force = false) => {
        const { eventFrames, peopleGroups } = get();
        const eventFrame = eventFrames.find((ef: EventFrame) => ef.id === eventFrameId);
        if (!eventFrame) return { success: false, message: "Marc d'esdeveniment no trobat." };

        if (!force && (newAssignmentData.status === AssignmentStatus.Yes || newAssignmentData.status === AssignmentStatus.Pending)) {
            const allOtherAssignments = get().eventFrames.flatMap(ef => ef.assignments.filter(a => a.personGroupId === newAssignmentData.personGroupId));
            const newStartDate = new Date(newAssignmentData.startDate);
            const newEndDate = new Date(newAssignmentData.endDate);

            for (let d = new Date(newStartDate); d <= newEndDate; d.setDate(d.getDate() + 1)) {
                const currentDateStr = d.toISOString().split('T')[0];
                const conflictingAssignments = allOtherAssignments.filter(existing => {
                    const existingStart = new Date(existing.startDate);
                    const existingEnd = new Date(existing.endDate);
                    if (d < existingStart || d > existingEnd) return false;

                    if (existing.status === AssignmentStatus.Yes || existing.status === AssignmentStatus.Pending) return true;
                    if (existing.status === AssignmentStatus.Mixed && existing.dailyStatuses?.[currentDateStr] && existing.dailyStatuses[currentDateStr] !== AssignmentStatus.No) return true;

                    return false;
                });

                if (conflictingAssignments.length > 0) {
                    const conflictDetails = conflictingAssignments.map(conflict => {
                        const conflictingEvent = get().eventFrames.find(ef => ef.id === conflict.eventFrameId);
                        return `"${conflictingEvent?.name}" el ${formatDateDMY(currentDateStr)}`;
                    }).join(", ");
                    return { success: true, warningMessage: `DUPLICATE_CONFLICT:Conflicte detectat: Aquest contacte ja té una assignació a ${conflictDetails}.` };
                }
            }
        }

        const newAssignment: Assignment = { ...newAssignmentData, id: generateId(), eventFrameId };
        const personName = peopleGroups.find(p => p.id === newAssignmentData.personGroupId)?.name || 'desconegut';
        set((state: EventDataState) => {
            const targetFrame = state.eventFrames.find(ef => ef.id === eventFrameId);
            if (targetFrame) {
                targetFrame.assignments.push(newAssignment);
                targetFrame.assignments.sort((a, b) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime());
            }
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has assignat «${personName}» a l'esdeveniment «${eventFrame?.name ?? 'desconegut'}»`;
        });
        return { success: true };
    },
    updateAssignment: (updatedAssignment: Assignment, force = false, context?: { changedDate?: string }) => {
        let finalAssignment = { ...updatedAssignment };

        // Logic to recalculate main status from daily statuses
        if (finalAssignment.status === AssignmentStatus.Mixed && finalAssignment.dailyStatuses) {
            const dailyStatusValues = Object.values(finalAssignment.dailyStatuses);
            if (dailyStatusValues.length > 0) {
                const firstStatus = dailyStatusValues[0];
                const allSame = dailyStatusValues.every(s => s === firstStatus);
                if (allSame) {
                    finalAssignment.status = firstStatus;
                    finalAssignment.dailyStatuses = undefined;
                }
            }
        } else if (finalAssignment.status !== AssignmentStatus.Mixed) {
            finalAssignment.dailyStatuses = undefined;
        }

        let warningMessage: string | undefined = undefined;

        if (!force) {
            const allOtherAssignments = get().eventFrames.flatMap(ef =>
                ef.assignments.filter(a => a.personGroupId === finalAssignment.personGroupId && a.id !== finalAssignment.id)
            );

            const checkDateRange = (start: Date, end: Date, statusToCheck: AssignmentStatus | { [date: string]: AssignmentStatus }) => {
                for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                    const currentDateStr = d.toISOString().split('T')[0];
                    let currentDayStatus: AssignmentStatus | undefined;

                    if (typeof statusToCheck === 'string') {
                        currentDayStatus = statusToCheck;
                    } else {
                        currentDayStatus = statusToCheck[currentDateStr];
                    }

                    if (!currentDayStatus || currentDayStatus === AssignmentStatus.No) continue;

                    const conflictingAssignments = allOtherAssignments.filter(existing => {
                        const existingStart = new Date(existing.startDate);
                        const existingEnd = new Date(existing.endDate);
                        if (d < existingStart || d > existingEnd) return false;

                        if (existing.status === AssignmentStatus.Yes || existing.status === AssignmentStatus.Pending) return true;
                        if (existing.status === AssignmentStatus.Mixed && existing.dailyStatuses?.[currentDateStr] && existing.dailyStatuses[currentDateStr] !== AssignmentStatus.No) return true;

                        return false;
                    });

                    if (conflictingAssignments.length > 0) {
                        const conflictDetails = conflictingAssignments.map(conflict => `"${get().eventFrames.find(ef => ef.id === conflict.eventFrameId)?.name}" el ${formatDateDMY(currentDateStr)}`).join(", ");
                        return `Conflicte detectat: Aquest contacte ja té una assignació a ${conflictDetails}.`;
                    }
                }
                return null;
            };

            let conflictMessage: string | null = null;
            if (finalAssignment.status !== AssignmentStatus.No) {
                if (context?.changedDate) {
                    const specificDate = new Date(context.changedDate);
                    conflictMessage = checkDateRange(specificDate, specificDate, finalAssignment.dailyStatuses || finalAssignment.status);
                } else {
                    conflictMessage = checkDateRange(new Date(finalAssignment.startDate), new Date(finalAssignment.endDate), finalAssignment.dailyStatuses || finalAssignment.status);
                }
            }
            if (conflictMessage) {
              warningMessage = `DUPLICATE_CONFLICT:${conflictMessage}`;
            }
        }

        const personName = get().peopleGroups.find(p => p.id === finalAssignment.personGroupId)?.name || 'desconegut';
        set(state => {
            const eventFrame = state.eventFrames.find(ef => ef.id === finalAssignment.eventFrameId);
            if (eventFrame) {
                const assignmentIndex = eventFrame.assignments.findIndex(a => a.id === finalAssignment.id);
                if (assignmentIndex !== -1) {
                    eventFrame.assignments[assignmentIndex] = finalAssignment;
                    eventFrame.assignments.sort((a, b) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime());
                }
            }
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has modificat l'assignació de «${personName}» a «${eventFrame?.name ?? 'desconegut'}»`;
        });

        return { success: true, warningMessage };
    },
    deleteAssignment: (eventFrameId: string, assignmentId: string) => {
        const assignment = get().getAssignmentById(eventFrameId, assignmentId);
        const personName = get().peopleGroups.find(p => p.id === assignment?.personGroupId)?.name || 'desconegut';
        set((state: EventDataState) => {
            const frame = state.eventFrames.find(ef => ef.id === eventFrameId);
            if (frame) {
                frame.assignments = frame.assignments.filter((a: Assignment) => a.id !== assignmentId);
            }
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has suprimit l'assignació de «${personName}» a «${frame?.name ?? 'desconegut'}»`;
        });
    },
    getAssignmentById: (eventFrameId: string, assignmentId: string) => get().eventFrames.find((ef: EventFrame) => ef.id === eventFrameId)?.assignments.find((a: Assignment) => a.id === assignmentId),

    // PEOPLE
    addPersonGroup: (newPersonGroupData: Omit<PersonGroup, 'id'>) => {
        const newPersonGroup: PersonGroup = { id: generateId(), ...newPersonGroupData };
        set((state: EventDataState) => {
            state.peopleGroups.push(newPersonGroup);
            state.peopleGroups.sort((a,b) => a.name.localeCompare(b.name));
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Afegit contacte: '${newPersonGroup.name}'`;
        });
    },
    updatePersonGroup: (updatedPersonGroup: PersonGroup) => {
        set((state: EventDataState) => {
            const personIndex = state.peopleGroups.findIndex(p => p.id === updatedPersonGroup.id);
            if (personIndex !== -1) {
                state.peopleGroups[personIndex] = updatedPersonGroup;
            }
            state.peopleGroups.sort((a,b) => a.name.localeCompare(b.name));
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Actualitzat contacte: '${updatedPersonGroup.name}'`;
        });
    },
    deletePersonGroup: (personGroupId: string) => {
        const personName = get().peopleGroups.find(p => p.id === personGroupId)?.name || 'desconegut';
        set(state => {
            state.peopleGroups = state.peopleGroups.filter((pg: PersonGroup) => pg.id !== personGroupId);
            state.eventFrames.forEach(ef => {
                ef.assignments = ef.assignments.filter((a: Assignment) => a.personGroupId !== personGroupId)
            });
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Eliminat contacte: '${personName}'`;
        });
    },
    getPersonGroupById: (personGroupId: string) => get().peopleGroups.find((pg: PersonGroup) => pg.id === personGroupId),
    mergePeopleGroups: (newPeople: PersonGroup[]) => {
        const existingNames = new Set(get().peopleGroups.map((p: PersonGroup) => p.name.toLowerCase()));
        const peopleToAdd = newPeople.filter((p: PersonGroup) => !existingNames.has(p.name.toLowerCase()));
        if (peopleToAdd.length > 0) {
            set((state: EventDataState) => {
                state.peopleGroups.push(...peopleToAdd);
                state.peopleGroups.sort((a, b) => a.name.localeCompare(b.name));
                state.hasUnsavedChanges = true;
                state.lastActionDescription = `Has afegit ${peopleToAdd.length} nous contactes a l'agenda`;
            });
            return { success: true, message: `${peopleToAdd.length} noves persones afegides.`, type: 'success' };
        } else {
            return { success: true, message: "Totes les persones del fitxer ja existeixen.", type: 'info' };
        }
    },
    replacePeopleGroups: (newPeople) => {
        set(state => {
            state.peopleGroups = newPeople.sort((a, b) => a.name.localeCompare(b.name));
            state.hasUnsavedChanges = true;
            state.lastActionDescription = 'Has reemplaçat tota la llista de contactes';
        });
    },

    // MATERIAL
    addMaterialItem: (newItemData: Omit<MaterialItem, 'id'>) => {
        const newItem: MaterialItem = { ...newItemData, id: generateId() };
        set((state: EventDataState) => {
            state.materialItems.push(newItem);
            state.materialItems.sort((a,b) => a.name.localeCompare(b.name));
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has afegit el material «${newItem.name}» a l'inventari`;
        });
        return newItem;
    },
    updateMaterialItem: (updatedItem: MaterialItem) => {
        set({ isUpdatingMaterial: true });
        set(state => {
            // 1. Actualitzar l'ítem mestre
            const itemIndex = state.materialItems.findIndex(item => item.id === updatedItem.id);
            if (itemIndex !== -1) {
                state.materialItems[itemIndex] = updatedItem;
            }
            state.materialItems.sort((a, b) => a.name.localeCompare(b.name));

            // 2. Propagar canvis a tota l'app
            const needsKeys: (keyof TechSheetData)[] = [
                'lighting', 'sound', 'video', 'machinery', 'rentals', 'otherEquipment',
                'electrical', 'structures', 'platforms', 'consumables', 'curtains', 'transport'
            ];

            state.eventFrames.forEach(eventFrame => {
                if (!eventFrame.techSheet) return;

                needsKeys.forEach(key => {
                    const section = eventFrame.techSheet![key];
                    if (section && typeof section === 'object' && 'status' in section && section.status === 'yes' && 'data' in section && section.data && Array.isArray(section.data.needs)) {
                        section.data.needs.forEach((needItem: NeedItem) => {
                            if (needItem.materialItemId === updatedItem.id) {
                                needItem.description = updatedItem.name;
                                needItem.origin = updatedItem.location;
                            }
                        });
                    }
                });
            });
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has modificat el material «${updatedItem.name}» de l'inventari`;
        });
        setTimeout(() => set({ isUpdatingMaterial: false }), 0);
    },
    deleteMaterialItem: (itemId: string) => {
        const itemName = get().materialItems.find(i => i.id === itemId)?.name || 'desconegut';
        set((state: EventDataState) => {
            state.materialItems = state.materialItems.filter((item: MaterialItem) => item.id !== itemId);
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has suprimit el material «${itemName}» de l'inventari`;
        });
    },
    addMaterialItemsFromFile: (newItems: MaterialItem[]) => {
        const existingNames = new Set(get().materialItems.map(item => item.name.toLowerCase()));
        const itemsToAdd = newItems.filter((newItem: MaterialItem) => !existingNames.has(newItem.name.toLowerCase()));
        if (itemsToAdd.length > 0) {
            set((state: EventDataState) => {
                state.materialItems.push(...itemsToAdd);
                state.materialItems.sort((a,b) => a.name.localeCompare(b.name));
                state.hasUnsavedChanges = true;
                state.lastActionDescription = `Fusionats ${itemsToAdd.length} articles de material`;
            });
            return { success: true, message: `${itemsToAdd.length} nous articles de material afegits.`, type: 'success' };
        } else {
            return { success: true, message: "Tots els articles del fitxer ja existeixen.", type: 'info' };
        }
    },
    replaceMaterialItems: (newItems) => {
        set(state => {
            state.materialItems = newItems.sort((a, b) => a.name.localeCompare(b.name));
            state.hasUnsavedChanges = true;
            state.lastActionDescription = 'Reemplaçat l\'inventari de material';
        });
    },
    getMaterialAvailability: (materialId: string, startDate: string, endDate: string, currentEventFrameId: string, currentItemId?: string) => {
        const { materialItems, eventFrames } = get();
        const materialItem = materialItems.find(item => item.id === materialId);
        if (!materialItem) return { available: 0, total: 0 };

        let committedInCurrentEvent = 0;
        const currentEventFrame = eventFrames.find(ef => ef.id === currentEventFrameId);
        if (currentEventFrame?.techSheet) {
            const needsKeys: (keyof TechSheetData)[] = [
                'lighting', 'sound', 'video', 'machinery', 'rentals', 'otherEquipment',
                'electrical', 'structures', 'platforms', 'consumables', 'curtains', 'transport'
            ];
            needsKeys.forEach(key => {
                const section = currentEventFrame.techSheet![key];
                if (section && section.status === 'yes' && Array.isArray((section as any).data?.needs)) {
                    (section as any).data.needs.forEach((need: NeedItem) => {
                        if (need.materialItemId === materialId && need.id !== currentItemId) {
                            committedInCurrentEvent += Number(need.quantity) || 0;
                        }
                    });
                }
            });
        }

        let minAvailable = materialItem.stock;
        for (let d = new Date(startDate); d <= new Date(endDate); d.setDate(d.getDate() + 1)) {
            const currentDate = new Date(d);
            let dailyCommittedStock = 0;
            eventFrames.forEach(ef => {
                if (ef.id === currentEventFrameId) return;
                if (currentDate >= new Date(ef.startDate) && currentDate <= new Date(ef.endDate)) {
                    Object.values(ef.techSheet || {}).forEach(section => {
                        if (section && section.status === 'yes' && Array.isArray((section as any).data?.needs)) {
                            (section as any).data.needs.forEach((need: NeedItem) => {
                                if (need.materialItemId === materialId) {
                                    dailyCommittedStock += Number(need.quantity) || 0;
                                }
                            });
                        }
                    });
                }
            });
            minAvailable = Math.min(minAvailable, materialItem.stock - dailyCommittedStock);
        }
        return { total: materialItem.stock, available: minAvailable - committedInCurrentEvent };
    },

    // GOOGLE & SYNC
        refreshGoogleEvents: async () => {
                if (window.electronAPI?.getGoogleEvents) {
                    const result = await window.electronAPI.getGoogleEvents();
                    if (result.success && result.events) {
                        set({ googleEvents: result.events });
                        return { success: true };
                    } else if (result.message) {
                        return { success: false, message: result.message, type: 'error' };
                    }
                }
                return { success: false, message: 'API d\'Electron no disponible.', type: 'error' };
            },
    syncWithGoogle: async () => {
        const { openModal, closeModal } = useModalStore.getState();
        const { executeSync } = get();

        if (window.electronAPI?.loadGoogleConfig) {
            const config = await window.electronAPI.loadGoogleConfig();
            if (!config || !config.managedAppCalendars || config.managedAppCalendars.length === 0) {
                openModal('googleSettings');
                return;
            }
            openModal('selectSyncCalendar', {
                managedCalendars: config.managedAppCalendars,
                activeCalendarId: config.activeAppCalendarId,
                onConfirmSync: (targetCalendarId: string) => {
                    closeModal();
                    executeSync(targetCalendarId);
                }
            });
        } else {
            logger.warn("L'API d'Electron per a Google Config no està disponible.");
        }
    },
    executeSync: async (targetCalendarId) => {
        const { exportData, loadData, refreshGoogleEvents } = get();
        let finalResult: any = { success: false, message: 'La sincronització no es va completar.', type: 'error' };

        set({ isSyncing: true, syncProgress: { current: 0, total: 0, message: 'Iniciant...', visible: true } });

        if (window.electronAPI) {
          const localData = await exportData();
          const result = await window.electronAPI.syncWithGoogle({ localData, targetCalendarId });

          if (result.success && result.data) {
            await loadData(result.data);
            await refreshGoogleEvents();
            finalResult = { success: true, message: result.message || 'Sincronització completada.', type: 'success' };
          } else {
            await refreshGoogleEvents();
            finalResult = { success: false, message: result.message || 'Error desconegut durant la sincronització.', type: 'error', code: result.code };
          }
        }

        set({ isSyncing: false, syncProgress: { ...get().syncProgress, visible: false } });
        return finalResult;
      },

    // ARCHIVING
    archiveOldEventFrames: () => {
        const { eventFrames } = get();
        const oneMonthAgo = new Date();
        oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);

        return eventFrames.filter(ef => {
            const endDate = new Date(ef.endDate);
            return endDate < oneMonthAgo && !ef.isArchived;
        });
    },

    confirmArchiveEventFrames: (eventFrameIds: string[]) => {
        set(state => {
            const idsToArchive = new Set(eventFrameIds);
            state.eventFrames.forEach(ef => {
                if (idsToArchive.has(ef.id)) {
                    ef.isArchived = true;
                }
            });
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has arxivat ${eventFrameIds.length} esdeveniments antics`;
        });
    },

    restoreEventFrame: (eventFrameId: string) => {
        const eventFrameName = get().eventFrames.find(ef => ef.id === eventFrameId)?.name || 'desconegut';
        set(state => {
            const frame = state.eventFrames.find(ef => ef.id === eventFrameId);
            if (frame) {
                frame.isArchived = false;
            }
            state.hasUnsavedChanges = true;
            state.lastActionDescription = `Has restaurat l'esdeveniment «${eventFrameName}»`;
        });
    },
    })),
        {
            // Memoització superficial per evitar objectes nous si l'estat no canvia
            partialize: (() => {
                let last: PartializedState | undefined;
                let lastVals: [EventFrame[], PersonGroup[], MaterialItem[], string | null] | undefined;
                return (state) => {
                    const vals: [EventFrame[], PersonGroup[], MaterialItem[], string | null] = [state.eventFrames, state.peopleGroups, state.materialItems, state.lastActionDescription];
                    if (lastVals && vals.every((v, i) => v === lastVals![i])) {
                        return last!;
                    }
                    lastVals = vals;
                    last = { eventFrames: vals[0], peopleGroups: vals[1], materialItems: vals[2], lastActionDescription: vals[3] };
                    return last;
                };
            })(),
            limit: 20,
        }
  )
);

type PartializedState = Pick<EventDataState, 'eventFrames' | 'peopleGroups' | 'materialItems' | 'lastActionDescription'>;

export const useTemporalStore = <T,>(
    selector: (state: TemporalState<PartializedState>) => T
) => {
    return useStore(useEventDataStore.temporal, selector);
};

// --- Selectors ---

export const selectAvailableOrigins = (state: EventDataState): string[] => {
  const origins = new Set(state.materialItems.map(item => item.location));
  return Array.from(origins).sort((a, b) => a.localeCompare(b));
};

export interface MaterialControlFilters {
  selectedEventIds?: string[];
  selectedOrigins?: string[];
  selectedCategories?: string[];
  searchText?: string;
  dateRange?: { start?: string; end?: string };
}

export const selectMaterialControlData = (
  state: EventDataState,
  filters: MaterialControlFilters
): MaterialControlRow[] => {
  const { selectedEventIds, dateRange, selectedOrigins, selectedCategories, searchText } = filters;
  const { materialItems, eventFrames } = state;

  const isPeakDemandActive = (selectedEventIds && selectedEventIds.length > 0) || (dateRange && (dateRange.start || dateRange.end));

  if (!isPeakDemandActive) {
    // Comportament per defecte: mostra tots els materials sense demanda.
    const allRows = materialItems.map(item => ({
      item,
      totalDemand: 0,
      balance: item.stock,
      breakdown: [],
    }));

    // Aplica filtres simples que no depenen de la demanda.
    return allRows.filter(row => {
      if (selectedOrigins && selectedOrigins.length > 0 && !selectedOrigins.includes(row.item.location)) return false;
      if (selectedCategories && selectedCategories.length > 0 && !selectedCategories.includes(row.item.category)) return false;
      if (searchText && searchText.trim()) {
        const lowerCaseSearch = searchText.toLowerCase();
        return row.item.name.toLowerCase().includes(lowerCaseSearch) ||
               row.item.category.toLowerCase().includes(lowerCaseSearch) ||
               row.item.location.toLowerCase().includes(lowerCaseSearch);
      }
      return true;
    });
  }

  // --- Càlcul de Pic de Demanda Activat ---

  // 1. Determina els esdeveniments rellevants.
  let relevantEvents = eventFrames;
  if (selectedEventIds && selectedEventIds.length > 0) {
    const eventIdSet = new Set(selectedEventIds);
    relevantEvents = eventFrames.filter(ef => eventIdSet.has(ef.id));
  } else if (dateRange && (dateRange.start || dateRange.end)) {
    relevantEvents = eventFrames.filter(event => {
      const eventStart = new Date(event.startDate);
      const eventEnd = new Date(event.endDate);
      const filterStart = dateRange.start ? new Date(dateRange.start) : null;
      const filterEnd = dateRange.end ? new Date(dateRange.end) : null;
      if (filterStart && eventEnd < filterStart) return false;
      if (filterEnd) {
          const inclusiveFilterEnd = new Date(filterEnd);
          inclusiveFilterEnd.setDate(inclusiveFilterEnd.getDate() + 1);
          if (eventStart >= inclusiveFilterEnd) return false;
      }
      return true;
    });
  }

  // 2. Extreu totes les necessitats de material dels esdeveniments rellevants.
  const allNeeds: ({ itemId: string; quantity: number; event: EventFrame })[] = [];
  relevantEvents.forEach(event => {
    if (!event.techSheet) return;
    const needsKeys: (keyof TechSheetData)[] = ['lighting', 'sound', 'video', 'machinery', 'rentals', 'otherEquipment', 'electrical', 'structures', 'platforms', 'consumables', 'curtains', 'transport'];
    needsKeys.forEach(key => {
      const section = event.techSheet![key];
      if (section && section.status === 'yes' && 'data' in section && section.data && Array.isArray((section.data as any).needs)) {
        (section.data as any).needs.forEach((need: NeedItem) => {
          if (need.materialItemId && need.quantity) {
            const numericQuantity = Number(need.quantity);
            if (!isNaN(numericQuantity) && numericQuantity > 0) {
              allNeeds.push({ itemId: need.materialItemId, quantity: numericQuantity, event });
            }
          }
        });
      }
    });
  });

  // 3. Construeix les files de resultats per a cada ítem de material.
  const resultRows: MaterialControlRow[] = materialItems.map(item => {
    const itemNeeds = allNeeds.filter(need => need.itemId === item.id);
    if (itemNeeds.length === 0) {
      return { item, totalDemand: 0, balance: item.stock, breakdown: [] };
    }

    // Troba el rang de dates global per a aquest ítem.
    const allDates = itemNeeds.flatMap(need => [new Date(need.event.startDate), new Date(need.event.endDate)]);
    const minDate = new Date(Math.min.apply(null, allDates.map(d => d.getTime())));
    const maxDate = new Date(Math.max.apply(null, allDates.map(d => d.getTime())));

    // Calcula el pic de demanda dia a dia.
    let peakDemand = 0;
    for (let d = new Date(minDate); d <= maxDate; d.setDate(d.getDate() + 1)) {
      let dailyDemand = 0;
      itemNeeds.forEach(need => {
        const eventStart = new Date(need.event.startDate);
        const eventEnd = new Date(need.event.endDate);
        if (d >= eventStart && d <= eventEnd) {
          dailyDemand += need.quantity;
        }
      });
      if (dailyDemand > peakDemand) {
        peakDemand = dailyDemand;
      }
    }

    // Construeix el desglossament.
    const breakdown = itemNeeds.map(need => ({
      eventFrameId: need.event.id,
      eventName: need.event.name,
      quantity: need.quantity,
      startDate: need.event.startDate,
      endDate: need.event.endDate,
    }));

    return {
      item,
      totalDemand: peakDemand,
      balance: item.stock - peakDemand,
      breakdown,
    };
  });

  // 4. Aplica filtres finals.
  return resultRows.filter(row => {
    // Amaga files sense demanda si el filtre d'esdeveniments està actiu.
    if (row.totalDemand === 0 && selectedEventIds && selectedEventIds.length > 0) {
        return false;
    }
    if (selectedOrigins && selectedOrigins.length > 0 && !selectedOrigins.includes(row.item.location)) return false;
    if (selectedCategories && selectedCategories.length > 0 && !selectedCategories.includes(row.item.category)) return false;
    if (searchText && searchText.trim()) {
      const lowerCaseSearch = searchText.toLowerCase();
      return row.item.name.toLowerCase().includes(lowerCaseSearch) ||
             row.item.category.toLowerCase().includes(lowerCaseSearch) ||
             row.item.location.toLowerCase().includes(lowerCaseSearch);
    }
    return true;
  });
};

--- END: ../Gestor-Events_i_Personal/src/stores/eventDataStore.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/stores/googleConfigStore.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { GoogleCalendar, ManagedAppCalendar, GoogleConfig } from '../types';
import { useEventDataStore } from './eventDataStore';
import { useModalStore } from './modalStore';
import { notificationService } from '../utils/notificationService';
import logger from '../utils/logger';

// --- STATE AND TYPES ---

interface GoogleConfigState {
  externalCalendars: GoogleCalendar[];
  selectedIds: string[];
  managedCalendars: ManagedAppCalendar[];
  activeCalendarId: string | null;
  loading: boolean;
  error: string | null;
  isSyncing: boolean;
}

interface ActionResult {
    success: boolean;
    message: string;
    type: 'success' | 'error' | 'info' | 'warning';
}

interface GoogleConfigActions {
  toggleExternalCalendar: (calendarId: string) => void;
  setActiveCalendarId: (calendarId: string | null) => void;
  resetGoogleConfig: () => void;
}

const initialState: GoogleConfigState = {
  externalCalendars: [],
  selectedIds: [],
  managedCalendars: [],
  activeCalendarId: null,
  loading: true,
  error: null,
  isSyncing: false,
};

// --- ZUSTAND STORE CREATION ---

export const useGoogleConfigStore = create<GoogleConfigState & GoogleConfigActions>()(
  immer((set) => ({
    ...initialState,

    // Accions síncrones simples que modifiquen l'estat directament
    toggleExternalCalendar: (calendarId: string) => {
      set(state => {
        const newSet = new Set(state.selectedIds);
        if (newSet.has(calendarId)) {
          newSet.delete(calendarId);
        } else {
          newSet.add(calendarId);
        }
        state.selectedIds = Array.from(newSet);
      });
    },

    setActiveCalendarId: (calendarId: string | null) => {
      set({ activeCalendarId: calendarId });
    },

    resetGoogleConfig: () => {
      set(initialState);
      logger.info("Estat de la configuració de Google restablert.");
    },
  }))
);

// --- STANDALONE ASYNCHRONOUS/COMPLEX ACTIONS ---

/**
 * Sets up listeners for Google authentication events from the main process.
 */
export const initializeGoogleAuthListeners = () => {
  if (window.electronAPI?.onGoogleAuthSuccess) {
    window.electronAPI.onGoogleAuthSuccess(() => {
      logger.info("Rebut 'google-auth-success' a la store. Refrescant configuració.");
      fetchAndLoadConfig();
      notificationService.success('Connectat a Google Calendar amb èxit!');
    });
  }
  if (window.electronAPI?.onGoogleAuthError) {
    window.electronAPI.onGoogleAuthError((errorMessage) => {
        logger.error("Rebut 'google-auth-error' a la store.", { errorMessage });
        notificationService.error(`Error d'autenticació: ${errorMessage}`);
    });
  }
};

/**
 * Initiates the Google authentication flow via the main process.
 */
export const startGoogleAuthFlow = async () => {
  logger.info('[UI] Iniciant flux d\'autenticació amb Google.');
  if (window.electronAPI?.startGoogleAuth) {
    const result = await window.electronAPI.startGoogleAuth();
    if (result.success) {
      notificationService.info('Obrint el navegador per autenticar-se amb Google...');
    } else {
      notificationService.error(result.message || "No s'ha pogut iniciar l'autenticació.");
    }
  } else {
    notificationService.warning('Aquesta funcionalitat només està disponible a l\'aplicació d\'escriptori.');
  }
};

/**
 * Fetches the complete Google Calendar configuration and list of calendars.
 */
export const fetchAndLoadConfig = async () => {
  if (!window.electronAPI?.loadGoogleConfig || !window.electronAPI?.getCalendarList) {
    useGoogleConfigStore.setState({ loading: false, error: "API d'Electron no disponible." });
    return;
  }
  useGoogleConfigStore.setState({ loading: true, error: null });
  try {
    const [configResult, calendarsResult] = await Promise.all([
      window.electronAPI.loadGoogleConfig() as Promise<GoogleConfig | null>,
      window.electronAPI.getCalendarList()
    ]);

    const newConfigState = {
      selectedIds: configResult?.selectedCalendarIds || [],
      managedCalendars: configResult?.managedAppCalendars || [],
      activeCalendarId: configResult?.activeAppCalendarId || null,
    };

    const managedIdsSet = new Set(newConfigState.managedCalendars.map(c => c.id));

    useGoogleConfigStore.setState({
      ...newConfigState,
      externalCalendars: calendarsResult.success ? (calendarsResult.calendars?.filter(c => !managedIdsSet.has(c.id)) || []) : [],
      error: calendarsResult.success ? null : (calendarsResult.message || 'Error desconegut obtenint calendaris.'),
    });

  } catch (err) {
    const errorMessage = (err as Error).message;
    logger.error("Error a fetchAndLoadConfig:", { errorMessage });
    useGoogleConfigStore.setState({ error: errorMessage });
  } finally {
    useGoogleConfigStore.setState({ loading: false });
  }
};

/**
 * Saves the current configuration of selected and active calendars.
 */
export const saveConfig = async (): Promise<ActionResult> => {
    const { selectedIds, activeCalendarId } = useGoogleConfigStore.getState();
    if (window.electronAPI?.saveGoogleConfig) {
        const configToSave: Partial<GoogleConfig> = {
            selectedCalendarIds: selectedIds,
            activeAppCalendarId: activeCalendarId,
        };
        const result = await window.electronAPI.saveGoogleConfig(configToSave);
        if (result.success) {
            setTimeout(() => {
                useEventDataStore.getState().refreshGoogleEvents();
            }, 0);
            return { success: true, message: 'Configuració desada.', type: 'success' };
        } else {
            return { success: false, message: result.message || "No s'ha pogut desar la configuració.", type: 'error' };
        }
    }
    return { success: false, message: "API d'Electron no disponible.", type: 'error' };
};

/**
 * Creates a new Google Calendar managed by the application.
 */
export const createNewCalendar = async (suffix: string): Promise<ActionResult | undefined> => {
    if (window.electronAPI?.createNewAppCalendar) {
        const result = await window.electronAPI.createNewAppCalendar(suffix);
        if (result.success && result.data) {
            useGoogleConfigStore.setState({
                managedCalendars: result.data.managedAppCalendars,
                activeCalendarId: result.data.activeAppCalendarId,
            });
            setTimeout(() => {
                fetchAndLoadConfig();
            }, 0);
            return { success: true, message: result.message || 'Calendari creat correctament.', type: 'success' };
        } else {
            return { success: false, message: result.message || 'Error creant el calendari.', type: 'error' };
        }
    }
};

/**
 * Deletes a managed Google Calendar permanently.
 */
export const deleteCalendar = (calendar: ManagedAppCalendar) => {
  const { openModal } = useModalStore.getState();
  openModal('confirmHardReset', {
    titleOverride: "Confirmar Eliminació de Calendari",
    itemName: `Estàs segur que vols eliminar permanentment el calendari "${calendar.name}" del teu compte de Google i de l'aplicació? Aquesta acció no es pot desfer.`,
    confirmButtonText: "Sí, Eliminar Calendari",
    onConfirmSpecial: async () => {
      if (window.electronAPI?.deleteAppCalendar) {
        try {
          const result = await window.electronAPI.deleteAppCalendar(calendar.id);
          if (result.success && result.data) {
            notificationService.success(result.message || 'Calendari eliminat correctament.');
            useGoogleConfigStore.setState({
                managedCalendars: result.data.managedAppCalendars,
                activeCalendarId: result.data.activeAppCalendarId,
            });
            setTimeout(() => {
                fetchAndLoadConfig();
                useEventDataStore.getState().refreshGoogleEvents();
            }, 0);
          } else {
            notificationService.error(result.message || "Hi ha hagut un error durant l'eliminació.");
          }
        } catch (err) {
            notificationService.error((err as Error).message);
        }
      }
    },
  });
};

/**
 * Disconnects the Google account, deleting all managed calendars and revoking access.
 */
export const disconnectGoogle = () => {
    const { openModal, closeModal } = useModalStore.getState();
    openModal('confirmHardReset', {
      titleOverride: "Confirmar Desconnexió de Google",
      itemName: "Estàs segur que vols desconnectar el teu compte de Google? Aquesta acció és irreversible i farà el següent:<br><br>" +
                "<ul class='list-disc list-inside text-left'>" +
                "<li><b>Eliminarà TOTS</b> els calendaris gestionats per l'aplicació del teu compte de Google.</li>" +
                "<li><b>Revocarà</b> l'accés de l'aplicació al teu compte.</li>" +
                "<li><b>Esborrarà</b> tota la configuració local de Google.</li>" +
                "</ul>",
      confirmButtonText: "Sí, Desconnectar",
      onConfirmSpecial: async () => {
        if (window.electronAPI?.googleDisconnect) {
          try {
            const result = await window.electronAPI.googleDisconnect();
            if (result.success) {
              notificationService.success('Compte de Google desconnectat correctament.');
              setTimeout(() => {
                  useEventDataStore.getState().refreshGoogleEvents();
                  fetchAndLoadConfig();
              }, 0);
              closeModal();
            } else {
              notificationService.error(result.message || 'Hi ha hagut un error durant la desconnexió.');
            }
          } catch (err) {
            notificationService.error((err as Error).message);
          }
        }
      },
    });
  };

--- END: ../Gestor-Events_i_Personal/src/stores/googleConfigStore.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/stores/loggingMiddleware.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { StateCreator } from 'zustand';
import logger from '../utils/logger';

export const loggingMiddleware = <T extends object>(
  f: StateCreator<T>,
  name: string
): StateCreator<T> => (set, get, api) => {
  return f(
    (args) => {
      const oldState = get();

      logger.info(`[ZUSTAND] ${name} - Acció`, {
        args,
        prevState: oldState,
      });

      set(args);

      const newState = get();
      try {
        const newStateSize = JSON.stringify(newState).length;
        // Si l'estat és molt gran (ex: > 50KB), no el registris sencer
        if (newStateSize > 50000) {
          logger.info(`[ZUSTAND] ${name} - Estat actualitzat (mida > 50KB, omès)`);
        } else {
          logger.info(`[ZUSTAND] ${name} - Estat actualitzat`, { newState });
        }
      } catch (e) {
          logger.warn(`[ZUSTAND] ${name} - No s'ha pogut serialitzar el nou estat per comprovar la mida.`);
      }
    },
    get,
    api
  );
};

--- END: ../Gestor-Events_i_Personal/src/stores/loggingMiddleware.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/stores/modalStore.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { create } from 'zustand';
import { ModalType, ModalData } from '../types';
import { devtools } from 'zustand/middleware';

// Aquesta és l'estructura de l'estat del nostre store
interface ModalState {
  type: ModalType;
  data: ModalData | null;
  isOpen: boolean;
}

// Aquestes són les accions que podrem executar sobre l'estat
interface ModalActions {
  openModal: (type: ModalType, data?: ModalData) => void;
  closeModal: () => void;
  updateModalData: (data: Partial<ModalData>) => void;
}

const initialState: ModalState = {
  type: null,
  data: null,
  isOpen: false,
};

export const useModalStore = create<ModalState & ModalActions>()(
  devtools(
    (set) => ({
      ...initialState,

      openModal: (type, data = {}) => {
        set({
            type,
            data,
            isOpen: true,
          });
      },

      closeModal: () => set(initialState),

      updateModalData: (data) =>
        set((state) => ({
          data: state.data ? { ...state.data, ...data } : data,
        })),
    }),
    { name: 'modalStore' }
  )
);

--- END: ../Gestor-Events_i_Personal/src/stores/modalStore.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/types.ts -- branca DEV_pre-monorepoV1.3.0 ---
export enum AssignmentStatus {
  Pending = 'Pendent',
  Yes = 'Sí',
  No = 'No',
  Mixed = 'Mixt',
}

export interface PersonGroup {
  id: string;
  name: string;
  role?: string;
  tel1?: string;
  tel2?: string;
  email?: string;
  web?: string;
  notes?: string;
}

export interface Assignment {
  id:string;
  personGroupId: string;
  eventFrameId: string;
  startDate: string;
  endDate: string;
  status: AssignmentStatus;
  notes?: string;
  dailyStatuses?: {
    [dateYYYYMMDD: string]: AssignmentStatus;
  };
}

// --- Tech Sheet Interfaces ---

export type ConditionalStatus = 'yes' | 'no' | 'unset';

export interface ConditionalSection<T extends object = {}> {
  status: ConditionalStatus;
  details: string;
  data?: T;
}

export interface AssemblyScheduleItem {
  id: string;
  date: string;
  time: string;
  timeEnd?: string;
  description: string;
}

export interface NeedItem {
  id: string;
  materialItemId?: string | null;
  quantity: number | string;
  description: string;
  origin: string;
}

export interface ContactPerson {
  id: string;
  name: string;
  role: string;
  phone: string;
  email: string;
}

export interface TechSheetRoleItem {
  id: string;
  assignmentId?: string;
  role: string;
  quantity: number | string;
  notes?: string;
  printNotes?: boolean;
}

export interface TechSheetProvider {
  id:string;
  personGroupId: string;
  roles: TechSheetRoleItem[];
  isManual?: boolean;
}

export interface TechSheetData {
  // Original fields that must be present
  eventName: string;
  location: string;
  date: string;
  showDuration: string;
  technicalProviders: TechSheetProvider[];
  showTimes?: { id: string; time: string }[];

  // --- NEW FIELDS (optional for backwards compatibility) ---
  generalNotes?: string;
  parking?: ConditionalSection;

  // Sections
  preAssembly?: ConditionalSection;
  schedule?: ConditionalSection<AssemblyScheduleItem[]>;
  logistics?: ConditionalSection; // To group logistics fields

  // Logistics fields (will be inside logistics object in the future)
  dressingRooms?: ConditionalSection<{ details: string }>;
  actorsInfo?: ConditionalSection<{ number: number | string; names: string }>;
  techniciansInfo?: ConditionalSection<{ number: number | string; names: string }>;

  // Technical Needs
  lighting?: ConditionalSection<{ needs: NeedItem[] }>;
  sound?: ConditionalSection<{ needs: NeedItem[] }>;
  video?: ConditionalSection<{ needs: NeedItem[] }>;
  machinery?: ConditionalSection<{ needs: NeedItem[] }>;
  rentals?: ConditionalSection<{ needs: NeedItem[] }>;
  otherEquipment?: ConditionalSection<{ needs: NeedItem[] }>;
  electrical?: ConditionalSection<{ needs: NeedItem[] }>;
  structures?: ConditionalSection<{ needs: NeedItem[] }>;
  platforms?: ConditionalSection<{ needs: NeedItem[] }>;
  consumables?: ConditionalSection<{ needs: NeedItem[] }>;
  curtains?: ConditionalSection<{ needs: NeedItem[] }>;
  transport?: ConditionalSection<{ needs: NeedItem[] }>;
  
  // Other Details
  controlLocation?: string;
  blueprints?: string;

  // Contacts and Observations
  contacts?: ContactPerson[];
  observations?: string;

  // PDF Visibility
  showLogistics?: boolean;
  showPreAssembly?: boolean;
  showSchedule?: boolean;
  showNeeds?: boolean;
  showOther?: boolean;
  showGeneralNotesInPdf?: boolean;
  technicalPersonnelNotes?: string;
  showTechnicalPersonnelNotesInPdf?: boolean;
  technicalNeedsNotes?: string;
  showTechnicalNeedsNotesInPdf?: boolean;
  showScheduleNotesInPdf?: boolean;

  // Legacy fields that might exist in old data
  parkingInfo?: string;
  preAssemblySchedule?: string;
  assemblySchedule?: any[];
  videoDetails?: string;
  companyContact?: string;

  [key: string]: any;
}


export interface EventFrame {
  id: string;
  name: string;
  place?: string;
  startDate: string;
  endDate: string;
  generalNotes?: string;
  personnelComplete?: boolean;
  assignments: Assignment[];
  googleEventId?: string;
  googleCalendarId?: string;
  lastModified?: string;
  lastSync?: string;
  techSheet?: TechSheetData;
  isArchived?: boolean;
}

export type EventFrameForExport = Omit<EventFrame, 'assignments'>;

export interface MaterialItem {
  id: string;
  name: string;
  category: string;
  stock: number;
  location: string;
  notes?: string;
}

export interface MaterialControlRow {
  item: MaterialItem;
  totalDemand: number;
  balance: number;
  breakdown: {
    eventFrameId: string;
    eventName: string;
    quantity: number;
    startDate: string;
    endDate: string;
  }[];
}

export interface ManagedAppCalendar {
  id: string;
  name: string;
  suffix: string;
}

export interface GoogleConfig {
  userEmail?: string;
  activeAppCalendarId?: string | null;
  managedAppCalendars?: ManagedAppCalendar[];
  selectedCalendarIds?: string[];
  // Obsolete fields, for migration/safety
  appCalendarId?: string;
  calendarSuffix?: string;
  createdWithSuffix?: string;
}

export interface GoogleConfigForExport {
  userEmail?: string;
  activeAppCalendarId?: string | null;
  managedAppCalendars?: ManagedAppCalendar[];
}

export interface AppData {
  eventFrames: EventFrameForExport[];
  peopleGroups: PersonGroup[];
  materialItems: MaterialItem[];
  assignments: Assignment[];
  googleConfig?: GoogleConfigForExport;
}

export interface InitialEventFrameData {
    startDate?: string;
    endDate?: string;
}

export type ShowToastFunction = (
  message: string,
  type?: 'success' | 'error' | 'info' | 'warning'
) => void;


export type ModalType =
  | 'addEventFrame'
  | 'editEventFrame'
  | 'addAssignment'
  | 'editAssignment'
  | 'managePeople'
  | 'eventFrameDetails'
  | 'confirmDeleteEventFrame'
  | 'confirmDeleteAssignment'
  | 'googleSettings'
  | 'confirmHardReset'
  | 'mergeOrReplace'
  | 'selectSyncCalendar'
  | 'createAppCalendar'
  | 'confirmDataRepair'
  | 'confirmDuplicate'
  | 'updateFromAssignments'
  | 'addMaterialFromTechSheet'
  | 'confirmDelete'
  | 'history'
  | 'googleEventDetails'
  | 'about'
  | null;

export interface ModalData {
    eventData?: any;
    toAdd?: Assignment[];
    toRemove?: (TechSheetRoleItem & { personGroupId: string })[];
    toUpdate?: { assignment: Assignment; currentRole: TechSheetRoleItem; newNotes: string }[];
    getPersonGroupById?: (id: string) => PersonGroup | undefined;
    message?: string;
    eventFrameToEdit?: EventFrame;
    eventFrame?: EventFrame;
    assignmentToEdit?: Assignment;
    personGroupId?: string;
    itemName?: string;
    itemId?: string;
    eventFrameId?: string;
    assignmentId?: string;
    startDate?: string;
    endDate?: string;
    status?: AssignmentStatus;
    notes?: string;
    name?: string;
    place?: string;
    generalNotes?: string;
    itemType?: string;
    onConfirm?: (...args: any[]) => void;
    onCancel?: () => void;
    onConfirmSpecial?: (inputValue?: string) => void;
    confirmButtonText?: string;
    cancelButtonText?: string;
    onCloseModal?: () => void;
    titleOverride?: string;
    newData?: PersonGroup[] | MaterialItem[];
    requiresInput?: boolean;
    suppressSuccessToast?: boolean;
    intent?: 'destructive' | 'constructive';
    managedCalendars?: ManagedAppCalendar[];
    activeCalendarId?: string | null;
    onConfirmSync?: (targetCalendarId: string) => void;
    fixes?: string[];
    onAdd?: (newItem: MaterialItem) => void;
}

export interface ModalState {
  type: ModalType;
  data?: ModalData | null;
}

export type AssignmentOperationResult = {
  success: boolean;
  message?: string;
  warningMessage?: string;
};

export interface SyncProgressState {
  current: number;
  total: number;
  message: string;
  visible: boolean;
}

export interface EventDataConteImplicits {
  eventFrames: EventFrame[];
  peopleGroups: PersonGroup[];
  addEventFrame: (eventFrame: Omit<EventFrame, 'id' | 'assignments' | 'personnelComplete' | 'techSheet'>) => EventFrame;
  updateEventFrame: (eventFrame: EventFrame) => void;
  deleteEventFrame: (eventFrameId: string) => void;
  getEventFrameById: (eventFrameId: string) => EventFrame | undefined;
  openModal: (type: ModalType, data?: ModalData) => void;
  showToast: ShowToastFunction;
  addPersonGroup: (personGroup: Omit<PersonGroup, 'id'>) => void;
  updatePersonGroup: (personGroup: PersonGroup) => void;
  deletePersonGroup: (personGroupId: string) => void;
  getPersonGroupById: (personGroupId: string) => PersonGroup | undefined;
  addAssignment: (eventFrameId: string, assignment: Omit<Assignment, 'id' | 'eventFrameId' | 'dailyStatuses'>, force?: boolean) => AssignmentOperationResult;
  updateAssignment: (assignment: Assignment, force?: boolean, context?: { changedDate?: string }) => AssignmentOperationResult;
  deleteAssignment: (eventFrameId: string, assignmentId: string) => void;  getAssignmentById: (eventFrameId: string, assignmentId: string) => Assignment | undefined;
  loadData: (data: AppData | null) => Promise<void>;
  exportData: () => Promise<AppData>;
  setPersonnelComplete: (eventFrameId: string, complete: boolean) => void;
  hasUnsavedChanges: boolean;
  setHasUnsavedChanges: (value: boolean) => void;
  googleEvents: any[];
  refreshGoogleEvents: (showToast?: ShowToastFunction) => Promise<{ success: boolean, message?: string, type?: 'success' | 'error' | 'info' | 'warning' }>;
  syncWithGoogle: () => Promise<void>;
  syncProgress: SyncProgressState;
  isSyncing: boolean;
  addOrUpdateTechSheet: (eventFrameId: string, fitxaData: TechSheetData) => void;
  materialItems: MaterialItem[];
  addMaterialItem: (newItemData: Omit<MaterialItem, 'id'>) => MaterialItem | undefined;
  updateMaterialItem: (updatedItem: MaterialItem) => void;
  deleteMaterialItem: (itemId: string) => void;
  addMaterialItemsFromFile: (newItems: MaterialItem[]) => void;
  getMaterialAvailability: (materialId: string, startDate: string, endDate: string, currentEventFrameId: string) => { available: number, total: number };
  mergePeopleGroups: (newPeople: PersonGroup[]) => void;
  replacePeopleGroups: (newPeople: PersonGroup[]) => void;
  replaceMaterialItems: (newItems: MaterialItem[]) => void;
  executeSync: (targetCalendarId: string) => Promise<void>;
  undo: () => void;
  redo: () => void;
  canUndo: boolean;
  canRedo: boolean;
}

export type EventDataManagerReturn = Omit<EventDataConteImplicits, 'openModal' | 'showToast'>;

export interface SummaryRow {
  id: string;
  primaryGrouping: string;
  secondaryGrouping?: string;
  eventFrameName: string;
  eventFramePlace?: string;
  eventFrameStartDate: string;
  eventFrameEndDate: string;
  assignmentPersonName: string;
  assignmentStartDate: string;
  assignmentEndDate: string;
  assignmentStatus: AssignmentStatus | '';
  assignmentNotes?: string;
  eventFrameGeneralNotes?: string;
  isMixedStatusAssignment?: boolean;
  assignmentObject: Assignment;
  [key: string]: any;
}


export interface Person {
  id: string;
  name: string;
  email?: string;
  phone?: string;
  notes?: string;
}

interface BaseCalendarEvent {
  id: string;
  title: string;
  start: string;
  end: string;
  allDay?: boolean;
  backgroundColor?: string;
  borderColor?: string;
  textColor?: string;
}

export interface CalendarAssignmentEvent extends BaseCalendarEvent {
  extendedProps: {
    type: 'assignment';
    eventFrameId: string;
    assignmentId: string;
  };
}

export interface CalendarEventFrameEvent extends BaseCalendarEvent {
  extendedProps: {
    type: 'eventFrame';
    eventFrameId: string;
    assignmentId?: undefined;
  };
  allDay: true;
}

export type CalendarEventType = CalendarAssignmentEvent | CalendarEventFrameEvent;

export interface GoogleCalendar {
  id: string;
  summary: string;
  backgroundColor: string;
  primary?: boolean;
}

export interface ShowSaveDialogOptions {
  title:string;
  defaultPath: string;
  filters: { name: string; extensions: string[] }[];
  data: Buffer | string;
  isDocumentSave?: boolean;
}

export interface ShowSaveDialogResult {
  success: boolean;
  canceled?: boolean;
  filePath?: string;
  message?: string;
}

export interface FileLoadedData {
  success: boolean;
  type: string;
  content?: string;
  fileName?: string;
  message?: string;
}

export interface ElectronAPI {
  // Document Management
  openFileDialog: () => Promise<{ success: boolean; canceled?: boolean; filePath?: string; message?: string; }>;
  readFile: (filePath: string) => Promise<{ success: boolean; content?: string; message?: string; }>;
  saveFile: (options: { filePath: string, data: string }) => Promise<{ success: boolean; message?: string; }>;
  showSaveDialog: (options: ShowSaveDialogOptions) => Promise<ShowSaveDialogResult>;
  showUnsavedChangesDialog: (options: { message: string; buttons: string[] }) => Promise<{ response: number }>;

  // Session & App Lifecycle
  onConfirmQuit: (callback: () => void) => () => void;
  quitApplication: () => void;
  getSessionData: () => Promise<any>;
  saveSessionData: (key: string, value: any) => Promise<{ success: boolean; message?: string }>;
  getRecentFiles: () => Promise<string[]>;
  addRecentFile: (filePath: string) => Promise<{ success: boolean; recentFiles: string[] }>;
  getAppMetadata: () => Promise<{ name: string; version: string; description: string; }>;

  // Google Integration
  loadGoogleConfig: () => Promise<GoogleConfig | null>;
  startGoogleAuth: () => Promise<{ success: boolean; message?: string }>;
  onGoogleAuthSuccess: (callback: () => void) => () => void;
  onGoogleAuthError: (callback: (errorMessage: string) => void) => () => void;
  getCalendarList: () => Promise<{ success: boolean, calendars?: GoogleCalendar[], message?: string }>;
  saveGoogleConfig: (config: Partial<GoogleConfig>) => Promise<{ success: boolean, data?: GoogleConfig, message?: string }>;
  getGoogleEvents: () => Promise<{ success: boolean, events?: any[], message?: string }>;
  getEventDetails: (calendarId: string, eventId: string) => Promise<{ success: boolean, event?: any, message?: string }>;
  syncWithGoogle: (payload: { localData: AppData, targetCalendarId: string }) => Promise<any>;
  onSyncProgress: (callback: (progress: Omit<SyncProgressState, 'visible'>) => void) => () => void;
  googleDisconnect: () => Promise<{ success: boolean; message?: string }>;
  deleteAppCalendar: (calendarId: string) => Promise<{ success: boolean; message?: string; data?: { managedAppCalendars: ManagedAppCalendar[], activeAppCalendarId: string | null } }>;
  createNewAppCalendar: (suffix: string) => Promise<{ success: boolean; message?: string; data?: { managedAppCalendars: ManagedAppCalendar[], activeAppCalendarId: string | null } }>;

  // Menu and Notifications
  onMenuAction: (callback: (action: string) => void) => () => void;
  triggerMenuAction: (action: string) => void;
  onBackendNotification: (callback: (notification: { message: string; type: 'success' | 'error' | 'info' | 'warning' }) => void) => () => void;

  // Misc & Obsolete
  factoryReset: () => Promise<{ success: boolean; message?: string }>;
  openLogsFolder: () => Promise<{ success: boolean; message?: string }>;
  openBackupsFolder: () => Promise<{ success: boolean; message?: string }>;
  // Obsolete - kept for safety, should be removed later
  loadAppData: () => Promise<any>;
  saveAppData: (data: AppData) => Promise<{ success: boolean; message?: string }>;
  getDefaultDataPath: () => Promise<string>;
  onAppWillRelaunchAfterReset: (callback: () => void) => () => void;
  onSyncError: (callback: (error: string) => void) => () => void;
  onSyncSuccess: (callback: (message: string) => void) => () => void;
  getPlatformSync: () => string;
}

declare global {
  interface Window {
    electronAPI?: ElectronAPI;
    electronLog?: {
      debug: (...args: any[]) => void;
      info: (...args: any[]) => void;
      warn: (...args: any[]) => void;
      error: (...args: any[]) => void;
    };
  }
}
--- END: ../Gestor-Events_i_Personal/src/types.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/colorUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---
/**
 * Converteix un color HSL a un format RGB.
 * Aquesta funció és crucial per traduir els colors del tema (definits en HSL)
 * al format RGB que requereix la llibreria de generació de PDF (jspdf-autotable).
 *
 * @param h - Hue (to) [0, 360]
 * @param s - Saturació (saturació) [0, 100]
 * @param l - Lluminositat (lluminositat) [0, 100]
 * @returns Un array que representa el color RGB: [R, G, B]
 */
export function hslToRgb(h: number, s: number, l: number): [number, number, number] {
  s /= 100;
  l /= 100;

  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
  const m = l - c / 2;

  let r = 0, g = 0, b = 0;

  if (0 <= h && h < 60) {
    r = c; g = x; b = 0;
  } else if (60 <= h && h < 120) {
    r = x; g = c; b = 0;
  } else if (120 <= h && h < 180) {
    r = 0; g = c; b = x;
  } else if (180 <= h && h < 240) {
    r = 0; g = x; b = c;
  } else if (240 <= h && h < 300) {
    r = x; g = 0; b = c;
  } else if (300 <= h && h < 360) {
    r = c; g = 0; b = x;
  }

  r = Math.round((r + m) * 255);
  g = Math.round((g + m) * 255);
  b = Math.round((b + m) * 255);

  return [r, g, b];
}
--- END: ../Gestor-Events_i_Personal/src/utils/colorUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/csvUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { EventFrame, PersonGroup, Assignment, ShowToastFunction, MaterialControlRow } from '../types';
import { getStatusSummaryText } from './statusUtils';
import { generateFileName } from './fileNameUtils';

// Define ActiveFilters type locally for this module
type ActiveFilters = {
  filterText?: string | null;
  filterStatus?: string | null;
  filterDate?: string | null;
  localFilterUIPerson?: string | null;
  filterPlace?: string | null;
  filterUIEventFrame?: string | null;
};

export const escapeCsvCell = (cellData: string | number | boolean | undefined | null): string => {
  if (cellData === undefined || cellData === null) return '';
  const stringData = String(cellData);
  if (stringData.includes(',') || stringData.includes('"') || stringData.includes('\n')) {
    return `"${stringData.replace(/"/g, '""')}"`;
  }
  return stringData;
};

export const exportEventListToCsv = async (
  eventFrames: EventFrame[],
  peopleGroups: PersonGroup[],
  showToast: ShowToastFunction,
  activeFilters: ActiveFilters
) => {
  try {
    const headers = [
      'Nom Esdeveniment',
      'Lloc',
      'Data Inici Esdeveniment',
      'Data Fi Esdeveniment',
      'Personal Assignat',
      'Data Inici Assignació',
      'Data Fi Assignació',
      'Estat Assignació',
      'Notes Assignació',
      'Notes Generals Esdeveniment'
    ];

    const rows = eventFrames.flatMap(ef => {
      if (ef.assignments.length === 0) {
        return [[
          escapeCsvCell(ef.name),
          escapeCsvCell(ef.place),
          escapeCsvCell(ef.startDate),
          escapeCsvCell(ef.endDate),
          escapeCsvCell(''), // No assigned person
          escapeCsvCell(''), // No assignment start date
          escapeCsvCell(''), // No assignment end date
          escapeCsvCell(''), // No assignment status
          escapeCsvCell(''), // No assignment notes
          escapeCsvCell(ef.generalNotes),
        ]];
      }
      return ef.assignments.map((a: Assignment) => {
        const person = peopleGroups.find(p => p.id === a.personGroupId);
        return [
          escapeCsvCell(ef.name),
          escapeCsvCell(ef.place),
          escapeCsvCell(ef.startDate),
          escapeCsvCell(ef.endDate),
          escapeCsvCell(person ? person.name : 'N/A'),
          escapeCsvCell(a.startDate),
          escapeCsvCell(a.endDate),
          escapeCsvCell(getStatusSummaryText(a)),
          escapeCsvCell(a.notes),
          escapeCsvCell(ef.generalNotes),
        ];
      });
    });

    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');

    const fileName = generateFileName('Llista_Esdeveniments', activeFilters, eventFrames, 'csv');

    if (window.electronAPI?.showSaveDialog) {
      const result = await window.electronAPI.showSaveDialog({
        title: 'Desar CSV',
        defaultPath: fileName,
        filters: [{ name: 'CSV', extensions: ['csv'] }],
        data: "\uFEFF" + csvContent,
        isDocumentSave: false, // Indica al backend que això NO és un desat de document
      });
      if (result.success) {
        showToast('CSV desat amb èxit!', 'success');
      } else if (!result.canceled) {
        showToast(`Error en desar el CSV: ${result.message}`, 'error');
      }
    } else {
      const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', fileName);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      showToast('Llista exportada a CSV amb èxit!', 'success');
    }
  } catch (error) {
    showToast(`Error generant CSV: ${(error as Error).message}`, 'error');
  }
};

export const exportMaterialControlCsv = async (
  data: MaterialControlRow[],
  showToast: ShowToastFunction
) => {
  try {
    const headers = ['Nom', 'Categoria', 'Origen', 'Demanada', 'Estoc', 'Balanç', 'Notes'];

    const rows = data.map(row => [
      escapeCsvCell(row.item.name),
      escapeCsvCell(row.item.category),
      escapeCsvCell(row.item.location),
      escapeCsvCell(row.totalDemand),
      escapeCsvCell(row.item.stock),
      escapeCsvCell(row.balance),
      escapeCsvCell(row.item.notes),
    ]);

    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');

    const fileName = `Control_Material_${new Date().toISOString().slice(0, 10)}.csv`;

    if (window.electronAPI?.showSaveDialog) {
      const result = await window.electronAPI.showSaveDialog({
        title: 'Desar CSV',
        defaultPath: fileName,
        filters: [{ name: 'CSV', extensions: ['csv'] }],
        data: csvContent,
        isDocumentSave: false, // Indica al backend que això NO és un desat de document
      });
      if (result.success) {
        showToast('CSV desat amb èxit!', 'success');
      } else if (!result.canceled) {
        showToast(`Error en desar el CSV: ${result.message}`, 'error');
      }
    } else {
      const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', fileName);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      showToast('Dades exportades a CSV amb èxit!', 'success');
    }
  } catch (error) {
    showToast(`Error generant CSV: ${(error as Error).message}`, 'error');
  }
};

--- END: ../Gestor-Events_i_Personal/src/utils/csvUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/dataIntegrity.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { AppData } from '../types';

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

export interface ValidationError {
  type: 'broken_assignment_reference';
  message: string;
  assignmentId: string;
  eventFrameId: string;
  personGroupId: string;
}

export const validateData = (data: AppData): ValidationResult => {
  const errors: ValidationError[] = [];
  const eventFrameIds = new Set(data.eventFrames.map(ef => ef.id));
  const personGroupIds = new Set(data.peopleGroups.map(pg => pg.id));

  (data.assignments || []).forEach(assignment => {
    if (!eventFrameIds.has(assignment.eventFrameId)) {
      errors.push({
        type: 'broken_assignment_reference',
        message: `L'assignació '${assignment.id}' fa referència a un esdeveniment que no existeix (${assignment.eventFrameId}).`,
        assignmentId: assignment.id,
        eventFrameId: assignment.eventFrameId,
        personGroupId: assignment.personGroupId,
      });
    }
    if (!personGroupIds.has(assignment.personGroupId)) {
      errors.push({
        type: 'broken_assignment_reference',
        message: `L'assignació '${assignment.id}' fa referència a una persona/grup que no existeix (${assignment.personGroupId}).`,
        assignmentId: assignment.id,
        eventFrameId: assignment.eventFrameId,
        personGroupId: assignment.personGroupId,
      });
    }
  });

  return {
    isValid: errors.length === 0,
    errors,
  };
};

export interface RepairResult {
  repairedData: AppData;
  fixes: string[];
}

export const repairData = (data: AppData, errors: ValidationError[]): RepairResult => {
  const repairedData = { ...data };
  const fixes: string[] = [];
  const assignmentsToRemove = new Set<string>();

  errors.forEach(error => {
    if (error.type === 'broken_assignment_reference') {
      if (!assignmentsToRemove.has(error.assignmentId)) {
        assignmentsToRemove.add(error.assignmentId);
        fixes.push(`S'ha eliminat una assignació trencada (ID: ${error.assignmentId}).`);
      }
    }
  });

  if (assignmentsToRemove.size > 0) {
    repairedData.assignments = (repairedData.assignments || []).filter(
      assignment => !assignmentsToRemove.has(assignment.id)
    );
  }

  return {
    repairedData,
    fixes,
  };
};

--- END: ../Gestor-Events_i_Personal/src/utils/dataIntegrity.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/dataMigration.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { AppData, PersonGroup, EventFrameForExport, Assignment, AssignmentStatus } from '../types';

interface OldPeopleData {
  people: {
    id: number;
    name: string;
    role?: string;
    tel1?: string;
    tel2?: string;
    email?: string;
    web?: string;
    notes?: string;
  }[];
}

interface OldEventData {
  eventFrames: {
    id: number;
    eventName: string;
    location?: string;
    generalStartDate: string;
    generalEndDate: string | null;
    notesGeneral?: string;
    isPersonnelComplete?: boolean;
  }[];
}

interface OldAssignmentData {
  assignments: {
    id: number;
    eventFrameId: number;
    personId: number;
    assignmentStartDate: string;
    assignmentEndDate: string | null;
    status?: 'Sí' | 'No' | 'Pendent';
    notesAssignment?: string;
  }[];
}

import { formatDateDMY } from './dateFormat';

export const migrateData = (
  peopleData?: OldPeopleData,
  eventData?: OldEventData,
  assignmentData?: OldAssignmentData
): AppData => {
  const peopleGroups: PersonGroup[] = (peopleData?.people || []).map(p => ({
    id: p.id.toString(),
    name: p.name,
    role: p.role || '',
    tel1: p.tel1 || '',
    tel2: p.tel2 || '',
    email: p.email || '',
    web: p.web || '',
    notes: p.notes || ''
  }));

  const eventFrames: EventFrameForExport[] = (eventData?.eventFrames || []).map(e => {
    const eventFrame = {
      id: e.id.toString(),
      name: e.eventName,
      place: e.location || '',
      startDate: e.generalStartDate,
      endDate: e.generalEndDate || e.generalStartDate,
      generalNotes: e.notesGeneral || '',
      personnelComplete: e.isPersonnelComplete || false,
    };
    return {
      ...eventFrame,
      techSheet: {
        eventName: eventFrame.name,
        location: eventFrame.place || '',
        date: formatDateDMY(eventFrame.startDate),
        showTime: '',
        showDuration: '',
        technicalProviders: [],
        lightingNeeds: [],
        soundNeeds: [],
        videoNeeds: [],
        machineryNeeds: [],
      }
    }
  });

  const assignments: Assignment[] = (assignmentData?.assignments || []).map(a => ({
    id: a.id.toString(),
    eventFrameId: a.eventFrameId.toString(),
    personGroupId: a.personId.toString(),
    startDate: a.assignmentStartDate,
    endDate: a.assignmentEndDate || a.assignmentStartDate,
    status: convertOldStatus(a.status),
    notes: a.notesAssignment || ''
  }));

  return {
    peopleGroups,
    eventFrames,
    assignments,
    materialItems: []
  };
};

const convertOldStatus = (status?: string): AssignmentStatus => {
  switch (status) {
    case 'Sí':
      return AssignmentStatus.Yes;
    case 'No':
      return AssignmentStatus.No;
    default:
      return AssignmentStatus.Pending;
  }
};

export const validateMigratedData = (data: AppData): { isValid: boolean; errors: string[] } => {
  const errors: string[] = [];

  if (!data.peopleGroups || !Array.isArray(data.peopleGroups)) {
    errors.push("El format de les dades de persones és invàlid.");
  }

  if (!data.eventFrames || !Array.isArray(data.eventFrames)) {
    errors.push("El format de les dades d'esdeveniments és invàlid.");
  }

  if (!data.assignments || !Array.isArray(data.assignments)) {
    errors.push("El format de les dades d'assignacions és invàlid.");
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
};

--- END: ../Gestor-Events_i_Personal/src/utils/dataMigration.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/dateFormat.ts -- branca DEV_pre-monorepoV1.3.0 ---
export function formatDateDMY(dateStr?: string | null): string {
  if (!dateStr) return '';
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) return dateStr;
  const day = String(date.getDate()).padStart(2, '0');
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const year = date.getFullYear();
  return `${day}/${month}/${year}`;
}

// Format de rang de dates dd/mm/yyyy - dd/mm/yyyy
export function formatDateRangeDMY(start?: string | null, end?: string | null): string {
  const startFormatted = formatDateDMY(start);
  const endFormatted = formatDateDMY(end);
  if (startFormatted && endFormatted && startFormatted !== endFormatted) {
    return `${startFormatted} - ${endFormatted}`;
  }
  return startFormatted || '';
}

// Suma dies a una data ISO i retorna YYYY-MM-DD
export function addDaysISO(dateStr: string, days: number): string {
  const date = new Date(dateStr);
  date.setDate(date.getDate() + days);
  return date.toISOString().split('T')[0];
}

/**
 * Genera un nom de fitxer per defecte amb el format dades_GEP_dd-mm-aa_HH-MM.json.
 * @returns Un string amb el nom del fitxer generat.
 */
export function generateDefaultFileName(): string {
  const now = new Date();
  const day = String(now.getDate()).padStart(2, '0');
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const year = String(now.getFullYear()).slice(-2);
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');

  return `dades_GEP_${day}-${month}-${year}_${hours}-${minutes}.json`;
}

--- END: ../Gestor-Events_i_Personal/src/utils/dateFormat.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/dateRangeFormatter.ts -- branca DEV_pre-monorepoV1.3.0 ---
const formatSimpleDM = (dateStr: string): string => {
  const parts = dateStr.split('-');
  return `${parts[2]}/${parts[1]}`;
};

/**
 * Comprova si dues dates són consecutives.
 */
const areDatesConsecutive = (dateStr1: string, dateStr2: string): boolean => {
  const d1 = new Date(dateStr1);
  d1.setUTCHours(0, 0, 0, 0); // Assegurem que no hi ha problemes de zona horària
  d1.setDate(d1.getDate() + 1);
  return d1.toISOString().split('T')[0] === dateStr2;
}

/**
 * Converteix una llista de dates (YYYY-MM-DD) en una cadena de rangs compacta.
 * Ex: ['2025-05-14', '2025-05-15', '2025-05-17'] -> "14/05-15/05, 17/05"
 */
export const formatDateRanges = (dates: string[]): string => {
  if (!dates || dates.length === 0) {
    return '';
  }

  // Assegurem que les dates estan ordenades
  const sortedDates = [...dates].sort();
  
  const ranges: string[] = [];
  let i = 0;
  while (i < sortedDates.length) {
    let rangeStart = sortedDates[i];
    let rangeEnd = sortedDates[i];
    let j = i;

    while (j + 1 < sortedDates.length && areDatesConsecutive(sortedDates[j], sortedDates[j + 1])) {
      rangeEnd = sortedDates[j + 1];
      j++;
    }

    if (rangeStart === rangeEnd) {
      ranges.push(formatSimpleDM(rangeStart));
    } else {
      ranges.push(`${formatSimpleDM(rangeStart)}-${formatSimpleDM(rangeEnd)}`);
    }
    
    i = j + 1;
  }
  
  return ranges.join(', ');
};

--- END: ../Gestor-Events_i_Personal/src/utils/dateRangeFormatter.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/fileNameUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { useEventDataStore } from '../stores/eventDataStore';
import { EventFrame } from '../types';
import { formatDateDMY } from './dateFormat';

// Tipus per a l'objecte de filtres, extret de l'estat de Zustand
type ActiveFilters = {
  filterText?: string | null;
  filterStatus?: string | null;
  filterDate?: string | null;
  localFilterUIPerson?: string | null;
  filterPlace?: string | null;
  filterUIEventFrame?: string | null;
};

// Funció auxiliar per a formatar un rang de dates a partir de les dades
const formatDateRangeFromData = (data: EventFrame[]): string => {
  if (!data || data.length === 0) {
    return 'Sense_Dates';
  }

  const sortedFrames = [...data].sort((a, b) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime());
  const startDate = sortedFrames[0].startDate;
  const endDate = [...data].sort((a, b) => new Date(b.endDate).getTime() - new Date(a.endDate).getTime())[0].endDate;

  if (startDate === endDate) {
    return formatDateDMY(startDate);
  }

  return `De_${formatDateDMY(startDate)}_a_${formatDateDMY(endDate)}`;
};

/**
 * Genera un descriptor intel·ligent per al nom del fitxer basat en els filtres actius.
 * @param filters - L'objecte que conté tots els filtres actius.
 * @param data - El conjunt de dades (EventFrame[]) que s'exportarà.
 * @returns Un string que descriu el contingut basat en els filtres.
 */
const generateSmartDescriptor = (filters: ActiveFilters, data: EventFrame[]): string => {
  const { peopleGroups, eventFrames } = useEventDataStore.getState();

  // Prioritat Alta: Filtres més restrictius i comuns
  if (filters.filterUIEventFrame) {
    const eventName = eventFrames.find(ef => ef.id === filters.filterUIEventFrame)?.name;
    return `Esdeveniment_${eventName?.replace(/[^a-zA-Z0-9]/g, '-') || 'Desconegut'}`;
  }

  if (filters.localFilterUIPerson) {
    const personName = peopleGroups.find(p => p.id === filters.localFilterUIPerson)?.name;
    return `Persona_${personName?.replace(/[^a-zA-Z0-9]/g, '-') || 'Desconegut'}`;
  }

  if (filters.filterDate) {
    return `Data_${formatDateDMY(filters.filterDate)}`;
  }

  // Comportament sense filtres prioritaris: Descriure el rang de dates
  const isAnyFilterActive = filters.filterText || filters.filterStatus || filters.filterPlace;
  if (!isAnyFilterActive) {
    return formatDateRangeFromData(data);
  }

  // Si hi ha filtres secundaris però no primaris, retorna un descriptor genèric
  return `Seleccio_Filtrada`;
};

/**
 * Funció principal per a construir el nom complet del fitxer d'exportació.
 * @param prefix - El prefix del fitxer (p. ex., 'Llista_Esdeveniments', 'Resum_Per_Persona').
 * @param filters - L'objecte amb l'estat dels filtres actius.
 * @param data - Les dades que s'exportaran, per a determinar el rang de dates si no hi ha filtres.
 * @param extension - L'extensió del fitxer (p. ex., 'pdf', 'csv').
 * @returns El nom de fitxer complet i sanejat.
 */
export const generateFileName = (
  prefix: string,
  filters: ActiveFilters,
  data: EventFrame[],
  extension: 'pdf' | 'csv'
): string => {
  const descriptor = generateSmartDescriptor(filters, data);

  // Comprova si s'han aplicat filtres secundaris (menys específics)
  const hasSecondaryFilters = !!(filters.filterText || filters.filterPlace || filters.filterStatus);
  const secondaryIndicator = (filters.filterUIEventFrame || filters.localFilterUIPerson || filters.filterDate) && hasSecondaryFilters
    ? '_+Filtres'
    : '';

  const finalDescriptor = `${descriptor}${secondaryIndicator}`;

  // Neteja final per a assegurar un nom de fitxer vàlid
  const saneDescriptor = finalDescriptor.replace(/[^a-zA-Z0-9_-]/g, '_');

  return `${prefix}_${saneDescriptor}.${extension}`;
};

/**
 * Genera el nom de fitxer per a la Fitxa de Bolo.
 * Aquest format és especial i no depèn dels filtres generals.
 * @param eventName - El nom de l'esdeveniment.
 * @param eventDateOrRange - La data o rang de dates de l'esdeveniment.
 * @returns El nom de fitxer formatejat.
 */
export const generateTechSheetFileName = (eventName: string, eventDateOrRange: string): string => {
    const saneEventName = eventName.replace(/[^a-zA-Z0-9_-]/g, '_');
    const saneDate = eventDateOrRange.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `Fitxa_Bolo_${saneEventName}_${saneDate}.pdf`;
};

--- END: ../Gestor-Events_i_Personal/src/utils/fileNameUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/logger.ts -- branca DEV_pre-monorepoV1.3.0 ---
// Com que electron-log sobreescriu els mètodes de la consola al procés principal,
// podem utilitzar directament els mètodes de la consola al renderer i electron-log
// els capturarà automàticament a través del seu IPC.
// Això simplifica enormement el codi i elimina la necessitat de mantenir un logger personalitzat.

const logger = {
  debug: (...args: any[]) => {
    if (window.electronLog) {
      window.electronLog.debug(...args);
    } else {
      console.debug(...args);
    }
  },
  info: (...args: any[]) => {
    if (window.electronLog) {
      window.electronLog.info(...args);
    } else {
      console.log(...args);
    }
  },
  warn: (...args: any[]) => {
    if (window.electronLog) {
      window.electronLog.warn(...args);
    } else {
      console.warn(...args);
    }
  },
  error: (...args: any[]) => {
    if (window.electronLog) {
      window.electronLog.error(...args);
    } else {
      console.error(...args);
    }
  }
};

export default logger;

--- END: ../Gestor-Events_i_Personal/src/utils/logger.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/notificationService.ts -- branca DEV_pre-monorepoV1.3.0 ---
import toast from 'react-hot-toast';

export const notificationService = {
  success: (message: string) => {
    toast.success(message);
  },
  
  error: (message: string) => {
    toast.error(message);
  },
  
  info: (message: string) => {
    toast(message, {
      icon: 'ℹ️',
      className: 'bg-info text-info-foreground border-border border p-4 rounded-lg shadow-lg',
    });
  },
  
  warning: (message: string) => {
    toast(message, {
      icon: '⚠️',
      className: 'bg-warning text-warning-foreground border-border border p-4 rounded-lg shadow-lg',
    });
  },
  
  loading: (message: string) => {
    return toast.loading(message);
  },
  
  dismiss: (toastId?: string) => {
    if (toastId) {
      toast.dismiss(toastId);
    } else {
      toast.dismiss();
    }
  },
  
  promise: <T>(
    promise: Promise<T>,
    messages: {
      loading: string;
      success: string | ((data: T) => string);
      error: string | ((error: any) => string);
    }
  ) => {
    return toast.promise(promise, messages);
  }
};

--- END: ../Gestor-Events_i_Personal/src/utils/notificationService.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/pdfGenerator.ts -- branca DEV_pre-monorepoV1.3.0 ---
import jsPDF from 'jspdf';
import autoTable, { Styles } from 'jspdf-autotable';
import { PersonGroup, SummaryRow, MaterialItem, TechSheetData, ShowToastFunction, EventFrame, Assignment, NeedItem, MaterialControlRow } from '../types';
import { formatDateDMY, formatDateRangeDMY } from './dateFormat';
import { getStatusSummaryText } from './statusUtils';
import { themeHslColors } from './themeDefinition';
import { hslToRgb } from './colorUtils';
import { generateFileName, generateTechSheetFileName } from './fileNameUtils';

// Define ActiveFilters type locally for this module
type ActiveFilters = {
  filterText?: string | null;
  filterStatus?: string | null;
  filterDate?: string | null;
  localFilterUIPerson?: string | null;
  filterPlace?: string | null;
  filterUIEventFrame?: string | null;
};
const createPdfHeader = (pdf: jsPDF, title: string): number => {
  pdf.setFontSize(18);
  pdf.setFont('helvetica', 'bold');
  pdf.text(title, 14, 20);
  const date = `Data d'exportació: ${formatDateDMY(new Date().toISOString())}`;
  pdf.setFontSize(10);
  pdf.setFont('helvetica', 'normal');
  pdf.text(date, pdf.internal.pageSize.getWidth() - 14, 20, { align: 'right' });
  return 30; // Retorna la posició Y inicial per al contingut
};

// Funció genèrica per gestionar el peu de pàgina
const addFooter = (pdf: jsPDF, pageCount: number) => {
  const pageW = pdf.internal.pageSize.getWidth();
  pdf.setFontSize(8);
  pdf.setFont('helvetica', 'normal');
  pdf.text(`${pageCount}`, pageW - 14, pdf.internal.pageSize.getHeight() - 15, { align: 'right' });
};

// Funció d'ajuda per al desat dual
async function savePdfWithDialog(
  pdf: jsPDF,
  defaultFileName: string,
  showToast: ShowToastFunction
) {
  if (window.electronAPI?.showSaveDialog) {
    const pdfData = pdf.output('arraybuffer');
    const result = await window.electronAPI.showSaveDialog({
      title: 'Desar PDF',
      defaultPath: defaultFileName,
      filters: [{ name: 'Documents PDF', extensions: ['pdf'] }],
      data: pdfData as any, // Pass ArrayBuffer directly
      isDocumentSave: false, // Indica al backend que això NO és un desat de document
    });
    if (result.success) {
      showToast('PDF desat amb èxit!', 'success');
    } else if (!result.canceled) {
      showToast(`Error en desar el PDF: ${result.message}`, 'error');
    }
  } else {
    pdf.save(defaultFileName);
    showToast('Resum exportat a PDF amb èxit!', 'success');
  }
}

// --- EXPORTACIÓ DE RESUMS ---
export const exportSummariesToPdf = async (
  title: string,
  data: Map<string, SummaryRow[]>,
  dataType: 'event-name' | 'start-date' | 'person',
  showToast: ShowToastFunction,
  activeFilters: ActiveFilters,
  filteredEventFrames: EventFrame[]
) => {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4');
    let y = createPdfHeader(pdf, `Resum: ${title}`);
    let pageCount = 1;

    const addPageIfNeeded = (currentY: number) => {
      if (currentY > 280) {
        addFooter(pdf, pageCount);
        pdf.addPage();
        pageCount++;
        return 10; // Y inicial per a la nova pàgina
      }
      return currentY;
    };

    if (data.size === 0) {
      pdf.setFontSize(12);
      pdf.text("No hi ha dades per mostrar en aquest resum.", 14, y);
    } else {
      data.forEach((assignments, groupKey) => {
        y = addPageIfNeeded(y);

        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        pdf.text(groupKey, 14, y);
        y += 8;

        const head = [['Esdeveniment/Persona', 'Dates', 'Estat', 'Notes']];
        const body = assignments.map(a => {
            let label = '';
            if (dataType === 'person') {
                label = a.eventFrameName;
            } else {
                label = a.assignmentPersonName;
            }

            const statusDetail = a.isMixedStatusAssignment
                ? `Mixt (${getStatusSummaryText(a.assignmentObject)})`
                : a.assignmentStatus;

            return [
                label,
                formatDateRangeDMY(a.assignmentStartDate, a.assignmentEndDate),
                statusDetail,
                a.assignmentNotes || '-'
            ];
        });

        autoTable(pdf, {
          head,
          body,
          startY: y,
          theme: 'striped',
          styles: { fontSize: 9, cellPadding: 2 },
          headStyles: { fillColor: hslToRgb(...themeHslColors.primary), textColor: hslToRgb(...themeHslColors.foregroundWhite), fontStyle: 'bold' },
          margin: { top: 15, bottom: 15 }
        });

        y = (pdf as any).lastAutoTable.finalY + 10;
      });
    }

    const totalPages = (pdf.internal as any).getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      addFooter(pdf, i);
    }

    const prefix = `Resum_Per_${dataType === 'event-name' ? 'Esdeveniment' : (dataType === 'start-date' ? 'Data' : 'Persona')}`;
    const fileName = generateFileName(prefix, activeFilters, filteredEventFrames, 'pdf');
    await savePdfWithDialog(pdf, fileName, showToast);

  } catch (error) {
    showToast(`Error generant PDF: ${(error as Error).message}`, 'error');
  }
};


// --- EXPORTACIó DE LLISTA DE MATERIAL ---
export const exportMaterialToPdf = async (materialItems: MaterialItem[], showToast: ShowToastFunction) => {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4');
    let y = createPdfHeader(pdf, 'Llista de Material');

    const head = [['Nom', 'Estoc', 'Ubicació', 'Notes']];
    
    const itemsByCategory: { [key: string]: MaterialItem[] } = {};
    materialItems.forEach(item => {
      const category = item.category || 'Sense Categoria';
      if (!itemsByCategory[category]) {
        itemsByCategory[category] = [];
      }
      itemsByCategory[category].push(item);
    });

    const body: any[][] = [];
    Object.keys(itemsByCategory).sort().forEach(category => {
      body.push([{ content: category, colSpan: 4, styles: { fontStyle: 'bold', fillColor: hslToRgb(...themeHslColors.grayBorder), textColor: hslToRgb(...themeHslColors.foreground) } }]);
      itemsByCategory[category].forEach(item => {
        body.push([
          item.name,
          item.stock.toString(),
          item.location || '-',
          item.notes || '-'
        ]);
      });
    });

    autoTable(pdf, {
      head,
      body,
      startY: y,
      theme: 'grid',
      styles: { fontSize: 10, cellPadding: 2.5 },
      headStyles: { fillColor: hslToRgb(...themeHslColors.success), textColor: hslToRgb(...themeHslColors.foregroundWhite), fontStyle: 'bold' },
      didDrawPage: (_data: any) => {
        if (_data.pageNumber > 1) {
            createPdfHeader(pdf, 'Llista de Material');
        }
      },
      margin: { top: 30, bottom: 15 }
    });

    const totalPages = (pdf.internal as any).getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      addFooter(pdf, i);
    }

    const fileName = `Llista_Material_${new Date().toISOString().slice(0, 10)}.pdf`;
    await savePdfWithDialog(pdf, fileName, showToast);
  } catch (error) {
    showToast(`Error generant PDF: ${(error as Error).message}`, 'error');
  }
};

// --- EXPORTACIÓ DE CONTROL DE MATERIAL ---

export const exportMaterialControlSummaryPdf = async (
  data: MaterialControlRow[],
  showToast: ShowToastFunction
) => {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4');
    let y = createPdfHeader(pdf, 'Resum de Control de Material');

    const head = [['Nom', 'Origen', 'Estoc', 'Balanç', 'Demanada']];
    const body: any[][] = [];
    let lastCategory = '';
    let lastOrigin = '';

    data.forEach(row => {
      if (row.item.category !== lastCategory) {
        lastCategory = row.item.category;
        lastOrigin = '';
        body.push([{
          content: lastCategory,
          colSpan: 5,
          styles: { fontStyle: 'bold', fillColor: hslToRgb(...themeHslColors.graySubtle), textColor: hslToRgb(...themeHslColors.foreground), fontSize: 11, halign: 'left' }
        }]);
      }

      if (row.item.location !== lastOrigin) {
        lastOrigin = row.item.location;
        body.push([{
          content: `Origen: ${lastOrigin}`,
          colSpan: 5,
          styles: { fontStyle: 'italic', fillColor: hslToRgb(...themeHslColors.grayMuted), textColor: hslToRgb(...themeHslColors.foregroundMuted), fontSize: 10, halign: 'left' }
        }]);
      }

      body.push([
        row.item.name,
        row.item.location,
        row.item.stock.toString(),
        { content: row.balance.toString(), styles: { fontStyle: 'bold', textColor: row.balance < 0 ? hslToRgb(...themeHslColors.destructive) : hslToRgb(...themeHslColors.success) } },
        row.totalDemand.toString()
      ]);

      if (row.item.notes) {
        body.push([{
          content: `Nota: ${row.item.notes}`,
          colSpan: 5,
          styles: {
            fillColor: hslToRgb(...themeHslColors.grayLightest),
            textColor: hslToRgb(...themeHslColors.foregroundMuted),
            fontStyle: 'italic',
            fontSize: 8
          }
        }]);
      }
    });

    autoTable(pdf, {
      head,
      body,
      startY: y,
      theme: 'grid',
      styles: { fontSize: 9, cellPadding: 2 },
      headStyles: { fillColor: hslToRgb(...themeHslColors.grayDark), textColor: hslToRgb(...themeHslColors.foregroundWhite), fontStyle: 'bold' },
      didDrawPage: (data: any) => {
        if (data.pageNumber > 1) {
          createPdfHeader(pdf, 'Resum de Control de Material');
        }
      },
      margin: { top: 30, bottom: 15 }
    });

    const totalPages = (pdf.internal as any).getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      addFooter(pdf, i);
    }

    const fileName = `Resum_Control_Material_${new Date().toISOString().slice(0, 10)}.pdf`;
    await savePdfWithDialog(pdf, fileName, showToast);
  } catch (error) {
    showToast(`Error generant PDF: ${(error as Error).message}`, 'error');
  }
};

export const exportMaterialControlDetailedPdf = async (
  data: MaterialControlRow[],
  eventFrames: EventFrame[],
  showToast: ShowToastFunction
) => {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4');
    let y = createPdfHeader(pdf, 'Detall de Control de Material');

    const eventMap = new Map(eventFrames.map(ef => [ef.id, ef]));

    const materialByEvent: Map<string, { eventName: string, items: any[] }> = new Map();
    data.forEach(row => {
      row.breakdown.forEach(bd => {
        if (!materialByEvent.has(bd.eventFrameId)) {
          materialByEvent.set(bd.eventFrameId, { eventName: bd.eventName, items: [] });
        }
        materialByEvent.get(bd.eventFrameId)!.items.push({
          name: row.item.name,
          quantity: bd.quantity,
          category: row.item.category,
          location: row.item.location
        });
      });
    });

    const sortedEventIds = Array.from(materialByEvent.keys()).sort((a, b) => {
        const eventA = eventMap.get(a);
        const eventB = eventMap.get(b);
        if (!eventA || !eventB) return 0;
        return new Date(eventA.startDate).getTime() - new Date(eventB.startDate).getTime();
    });


    for (const eventId of sortedEventIds) {
      const eventData = materialByEvent.get(eventId)!;
      const eventDetails = eventMap.get(eventId);

      if (y > 250) {
        pdf.addPage();
        y = createPdfHeader(pdf, 'Detall de Control de Material');
      }

      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      const eventTitle = `${eventData.eventName} (${formatDateRangeDMY(eventDetails?.startDate, eventDetails?.endDate)})`;
      pdf.text(eventTitle, 14, y);
      y += 8;

      const head = [['Quantitat', 'Nom', 'Categoria', 'Origen']];
      const body = eventData.items
        .map(item => [item.quantity.toString(), item.name, item.category, item.location]);

      autoTable(pdf, {
        head,
        body,
        startY: y,
        theme: 'striped',
        styles: { fontSize: 9, cellPadding: 2 },
        headStyles: { fillColor: hslToRgb(...themeHslColors.primary), textColor: hslToRgb(...themeHslColors.foregroundWhite), fontStyle: 'bold' },
      });

      y = (pdf as any).lastAutoTable.finalY + 10;
    }

    const totalPages = (pdf.internal as any).getNumberOfPages();
    for(let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        addFooter(pdf, i);
    }

    const fileName = `Detall_Control_Material_${new Date().toISOString().slice(0, 10)}.pdf`;
    await savePdfWithDialog(pdf, fileName, showToast);
  } catch (error) {
    showToast(`Error generant PDF: ${(error as Error).message}`, 'error');
  }
};


// --- EXPORTACIÓ DE LLIBRETA D'ADRECES ---
export const exportPeopleToPdf = async (peopleGroups: PersonGroup[], showToast: ShowToastFunction) => {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4');
    let y = createPdfHeader(pdf, "Llibreta d'Adreces");

    const head = [['Nom', 'Rol', 'Contacte', 'Notes']];
    const body = peopleGroups.map(p => {
      const contactInfo = [
        p.tel1,
        p.tel2,
        p.email,
        p.web,
      ].filter(Boolean).join('\n');
      return [p.name, p.role || '-', contactInfo || '-', p.notes || '-'];
    });

    autoTable(pdf, {
      head,
      body,
      startY: y,
      theme: 'striped',
      styles: { fontSize: 9, cellPadding: 2, overflow: 'linebreak' },
      headStyles: { fillColor: hslToRgb(...themeHslColors.orange), textColor: hslToRgb(...themeHslColors.foregroundWhite), fontStyle: 'bold' },
      columnStyles: {
        2: { cellWidth: 60 },
        3: { cellWidth: 'auto' }
      },
      didDrawPage: (_data: any) => {
        if (_data.pageNumber > 1) {
            createPdfHeader(pdf, "Llibreta d'Adreces");
        }
      },
      margin: { top: 30, bottom: 15 }
    });

    const totalPages = (pdf.internal as any).getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      addFooter(pdf, i);
    }

    const fileName = `Llibreta_Adreces_${new Date().toISOString().slice(0, 10)}.pdf`;
    await savePdfWithDialog(pdf, fileName, showToast);
  } catch (error) {
    showToast(`Error generant PDF: ${(error as Error).message}`, 'error');
  }
};

// --- FITXA TÈCNICA ---
export const exportTechSheetToPdf = async (
  formData: TechSheetData,
  eventName: string,
  getPersonGroupById: (id: string) => PersonGroup | undefined,
  showToast: ShowToastFunction
) => {
  try {
    const pdf = new jsPDF('p', 'mm', 'a4');
    let y = 10;

    // Define vertical spacing between sections
    const VERTICAL_SPACING = 3;

    const sane = (value: any): string => (value === null || value === undefined || String(value).trim() === '' || String(value).trim() === '--') ? '-' : String(value);
    const headStyles: Partial<Styles> = { fillColor: hslToRgb(...themeHslColors.grayDark), textColor: hslToRgb(...themeHslColors.foregroundWhite), fontStyle: 'bold' };
    const labelStyles: Partial<Styles> = { fillColor: hslToRgb(...themeHslColors.grayMuted), textColor: hslToRgb(...themeHslColors.foreground), fontStyle: 'bold', cellWidth: 50 };
    const subHeadStyles: Partial<Styles> = { fillColor: hslToRgb(...themeHslColors.graySubtle), textColor: hslToRgb(...themeHslColors.foreground), fontStyle: 'bold' };

    const checkPageBreak = (currentY: number): number => {
        if (currentY > 290) {
            pdf.addPage();
            return 10;
        }
        return currentY;
    };

    // --- Header ---
    const headerBody = [
        [{ content: 'FITXA DE BOLO', colSpan: 2, styles: { halign: 'center' as 'center', fontSize: 16, fontStyle: 'bold' as 'bold' } }],
        [{ content: 'NOM DEL BOLO:', styles: labelStyles }, sane(formData.eventName)],
        [{ content: 'LLOC:', styles: labelStyles }, sane(formData.location)],
        [{ content: 'DATA:', styles: labelStyles }, sane(formData.date)],
        [{ content: 'HORA:', styles: labelStyles }, formData.showTimes && formData.showTimes.length > 0 ? formData.showTimes.map(st => st.time).join(', ') : '-'],
        [{ content: 'DURADA:', styles: labelStyles }, sane(formData.showDuration)],
    ];
    autoTable(pdf, { 
      body: headerBody, 
      theme: 'grid', 
      startY: y, 
      pageBreak: 'avoid',
      margin: { left: 10, right: 10 },
      styles: { cellPadding: 2 }
    });
    y = (pdf as any).lastAutoTable.finalY + VERTICAL_SPACING;

    // ... (rest of the function remains the same, just applying the color conversion)

    // Example for one section:
    if (formData.showGeneralNotesInPdf && sane(formData.generalNotes) !== '-') {
        y = checkPageBreak(y);
        autoTable(pdf, {
            head: [[{ content: 'NOTES GENERALS DE LA FITXA', styles: headStyles }]],
            body: [[sane(formData.generalNotes)]],
            startY: y, 
            theme: 'grid', 
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 }
        });
        y = (pdf as any).lastAutoTable.finalY + 5;
    }

    if (formData.parking?.status === 'yes' || formData.parking?.status === 'no') {
      y = checkPageBreak(y);
      const parkingDetails = formData.parking.status === 'yes'
          ? (sane(formData.parking.details) !== '-' ? sane(formData.parking.details) : 'SI')
          : 'NO';
      autoTable(pdf, {
          head: [[{ content: 'PÀRQUING', styles: headStyles }]],
          body: [[parkingDetails]],
          startY: y, 
          theme: 'grid', 
          pageBreak: 'avoid',
          margin: { left: 10, right: 10 },
          styles: { cellPadding: 2 }
      });
      y = (pdf as any).lastAutoTable.finalY + VERTICAL_SPACING;
    }

    const personnelBody: any[][] = [];
    let hasAnyNotes = false;

    if (formData.technicalProviders && formData.technicalProviders.length > 0) {
      formData.technicalProviders.forEach(provider => {
        const person = getPersonGroupById(provider.personGroupId);
        if (provider.roles && provider.roles.length > 0) {
          provider.roles.forEach(role => {
            if (sane(role.role) !== '-' || sane(role.quantity) !== '-') {
                const row = [sane(role.quantity), sane(role.role), sane(person?.name)];
                if (role.printNotes && sane(role.notes) !== '-') {
                    hasAnyNotes = true;
                    row.push(sane(role.notes));
                }
                personnelBody.push(row);
            }
          });
        }
      });
    }
    if (personnelBody.length > 0) {
        y = checkPageBreak(y);
        const tableBody: any[][] = [];
        const totalColumns = hasAnyNotes ? 4 : 3;

        if (formData.showTechnicalPersonnelNotesInPdf && sane(formData.technicalPersonnelNotes) !== '-') {
            tableBody.push([{ content: sane(formData.technicalPersonnelNotes), colSpan: totalColumns, styles: { fontStyle: 'italic' as 'italic', halign: 'left' as 'left' } }]);
        }
        personnelBody.forEach(row => tableBody.push(row));

        autoTable(pdf, {
            head: [[{ content: 'PERSONAL TÈCNIC', colSpan: totalColumns, styles: headStyles }]],
            body: tableBody,
            startY: y,
            theme: 'grid',
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 },
            headStyles: { ...headStyles, halign: 'center' as 'center' },
            columnStyles: hasAnyNotes 
                ? { 0: { cellWidth: 15, halign: 'right' as 'right' }, 3: {cellWidth: 'auto'} }
                : { 0: { cellWidth: 15, halign: 'right' as 'right' } }
        });
        y = (pdf as any).lastAutoTable.finalY + VERTICAL_SPACING;
    }

    if (formData.preAssembly?.status === 'yes') {
        y = checkPageBreak(y);
        autoTable(pdf, {
            head: [[{ content: 'PREMUNTATGE', styles: headStyles }]],
            body: [[sane(formData.preAssembly.details)]],
            startY: y,
            theme: 'grid',
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 }
        });
        y = (pdf as any).lastAutoTable.finalY + 5;
    }

    if (formData.schedule?.status === 'yes' && formData.schedule.data && formData.schedule.data.length > 0) {
        y = checkPageBreak(y);

        const groupedSchedule = formData.schedule.data.reduce((acc, item) => {
            const date = item.date || 'Sense data';
            if (!acc[date]) {
                acc[date] = [];
            }
            acc[date].push(item);
            return acc;
        }, {} as Record<string, any[]>);

        const scheduleBody: any[][] = [];
        const dateSubHeadStyles: Partial<Styles> = { fillColor: hslToRgb(...themeHslColors.grayMuted), textColor: hslToRgb(...themeHslColors.foreground), fontStyle: 'bold' };

        if (formData.showScheduleNotesInPdf && sane(formData.schedule.details) !== '-') {
            scheduleBody.push([{ content: sane(formData.schedule.details), colSpan: 2, styles: { fontStyle: 'italic' as 'italic' } }]);
        }

        Object.entries(groupedSchedule).forEach(([date, items]) => {
            scheduleBody.push([{ content: `Data: ${formatDateDMY(date)}`, colSpan: 2, styles: dateSubHeadStyles }]);
            items.forEach(item => {
                const timeRange = [sane(item.time), sane(item.timeEnd)].filter(t => t !== '-').join(' - ');
                scheduleBody.push([timeRange, sane(item.description)]);
            });
        });

        autoTable(pdf, {
            head: [[{ content: 'HORARIS', colSpan: 2, styles: headStyles }]],
            body: scheduleBody,
            startY: y,
            theme: 'grid',
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 },
            columnStyles: { 0: { cellWidth: 40 } },
        });
        y = (pdf as any).lastAutoTable.finalY + 5;
    }

    const logisticsBody: any[][] = [];
    if (formData.dressingRooms?.status === 'yes') {
        logisticsBody.push([
            { content: 'Camerinos', styles: { cellWidth: 40 } },
            { content: sane(formData.dressingRooms.details) !== '-' ? sane(formData.dressingRooms.details) : 'SI', colSpan: 2 }
        ]);
    }
    if (formData.actorsInfo?.status === 'yes') {
        logisticsBody.push(['Actors', sane(formData.actorsInfo.data?.number), sane(formData.actorsInfo.data?.names)]);
    }
    if (formData.techniciansInfo?.status === 'yes') {
        logisticsBody.push(['Tècnics/Prod. Cia', sane(formData.techniciansInfo.data?.number), sane(formData.techniciansInfo.data?.names)]);
    }

    if (logisticsBody.length > 0) {
        y = checkPageBreak(y);
        autoTable(pdf, {
            head: [[{ content: 'LOGÍSTICA', colSpan: 3, styles: headStyles }]],
            body: logisticsBody,
            startY: y,
            theme: 'grid',
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 },
            columnStyles: { 0: { cellWidth: 40 }, 1: { cellWidth: 40 }, 2: { cellWidth: 'auto' } },
        });
        y = (pdf as any).lastAutoTable.finalY + VERTICAL_SPACING;
    }

    const needsBody: any[][] = [];
    if (formData.showTechnicalNeedsNotesInPdf && sane(formData.technicalNeedsNotes) !== '-') {
        needsBody.push([{ content: sane(formData.technicalNeedsNotes), colSpan: 3, styles: { fontStyle: 'italic' as 'italic' } }]);
    }
    const addNeedsToBody = (title: string, section: TechSheetData[keyof TechSheetData]) => {
        const needsSection = section as { status: 'yes' | 'no' | 'unset', details?: string, data?: { needs: NeedItem[] } };
        if (!needsSection || needsSection.status !== 'yes') return;

        const hasDetails = sane(needsSection.details) !== '-';
        const validNeeds = (needsSection.data?.needs || []).filter((n: NeedItem) => sane(n.description) !== '-' || sane(n.quantity) !== '-');

        if (hasDetails || validNeeds.length > 0) {
            needsBody.push([{ content: title, colSpan: 3, styles: subHeadStyles }]);
            if (hasDetails) needsBody.push([{ content: needsSection.details!, colSpan: 3, styles: { fontStyle: 'italic' as 'italic' } }]);
            validNeeds.forEach((n: NeedItem) => {
                needsBody.push([ { content: sane(n.quantity), styles: { halign: 'right' as 'right' } }, sane(n.description), sane(n.origin) ]);
            });
        }
    };

    addNeedsToBody('Il·luminació', formData.lighting);
    addNeedsToBody('So', formData.sound);
    addNeedsToBody('Vídeo', formData.video);
    addNeedsToBody('Maquinària', formData.machinery);
    addNeedsToBody('Lloguers', formData.rentals);
    addNeedsToBody("Material d'Altres Equipaments", formData.otherEquipment);
    addNeedsToBody('Infraestructures Elèctriques', formData.electrical);
    addNeedsToBody('Estructures', formData.structures);
    addNeedsToBody('Tarimes', formData.platforms);
    addNeedsToBody('Consumibles', formData.consumables);
    addNeedsToBody('Cortinatges', formData.curtains);
    addNeedsToBody('Transport', formData.transport);

    if (needsBody.length > 0) {
        y = checkPageBreak(y);
        autoTable(pdf, {
            head: [[{ content: 'NECESSITATS TÈCNIQUES', colSpan: 3, styles: headStyles }]],
            body: needsBody,
            startY: y,
            theme: 'grid',
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 },
            columnStyles: { 0: { cellWidth: 15 }, 1: { cellWidth: 'auto' }, 2: { cellWidth: 40 } },
        });
        y = (pdf as any).lastAutoTable.finalY + 5;
    }

    const otherDetailsBody = [];
    if (sane(formData.controlLocation) !== '-') otherDetailsBody.push([{ content: 'Control a:', styles: labelStyles }, sane(formData.controlLocation)]);
    if (sane(formData.blueprints) !== '-') otherDetailsBody.push([{ content: 'Plànols:', styles: labelStyles }, sane(formData.blueprints)]);
    if (otherDetailsBody.length > 0) {
      y = checkPageBreak(y);
      autoTable(pdf, {
          head: [[{ content: 'ALTRES DETALLS', colSpan: 2, styles: headStyles }]],
          body: otherDetailsBody,
          startY: y,
          theme: 'grid',
          pageBreak: 'avoid',
          margin: { left: 10, right: 10 },
          styles: { cellPadding: 2 }
      });
      y = (pdf as any).lastAutoTable.finalY + VERTICAL_SPACING;
    }

    const contactBody: any[][] = [];
    if (formData.contacts && formData.contacts.length > 0) {
        formData.contacts.forEach(contact => {
            if (Object.values(contact).some(val => sane(val) !== '-')) {
                const contactInfo = `Email: ${sane(contact.email)}\nTel: ${sane(contact.phone)}`;
                contactBody.push([sane(contact.name), sane(contact.role), contactInfo]);
            }
        });
    }
    if (contactBody.length > 0) {
        y = checkPageBreak(y);
        autoTable(pdf, {
            head: [[{ content: 'CONTACTES COMPANYIA', colSpan: 3, styles: headStyles }]],
            body: contactBody,
            startY: y,
            theme: 'grid',
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 },
            columnStyles: { 0: { cellWidth: 50 }, 1: { cellWidth: 50 }, 2: { cellWidth: 'auto' } },
        });
        y = (pdf as any).lastAutoTable.finalY + 5;
    }

    if (sane(formData.observations) !== '-') {
        y = checkPageBreak(y);
        autoTable(pdf, {
            head: [[{ content: 'OBSERVACIONS', styles: headStyles }]],
            body: [[sane(formData.observations)]],
            startY: y,
            theme: 'grid',
            pageBreak: 'avoid',
            margin: { left: 10, right: 10 },
            styles: { cellPadding: 2 }
        });
    }

    const totalPages = (pdf.internal as any).getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      addFooter(pdf, i);
    }

    const fileName = generateTechSheetFileName(eventName, formData.date || '');
    await savePdfWithDialog(pdf, fileName, showToast);
  } catch (error) {
    showToast(`Error generant PDF: ${(error as Error).message}`, 'error');
  }
};

// --- EXPORTACIÓ DE LLISTA D'ESDEVENIMENTS ---
export const exportEventListToPdf = async (
  eventFrames: EventFrame[],
  peopleGroups: PersonGroup[],
  showToast: ShowToastFunction,
  activeFilters: ActiveFilters
) => {
  try {
    const pdf = new jsPDF('l', 'mm', 'a4'); // 'l' per a format apaïsat (landscape)
    let y = createPdfHeader(pdf, "Llista d'Esdeveniments");

    const head = [['Nom Esdeveniment', 'Lloc', 'Dates', 'Personal Assignat i Notes', 'Estat', 'Notes Generals']];
    const body = eventFrames.map(ef => {
      const personnelText = ef.assignments.length > 0
        ? ef.assignments.map((a: Assignment) => {
            const person = peopleGroups.find(p => p.id === a.personGroupId);
            const personLine = `${person ? person.name : 'N/A'} ${getStatusSummaryText(a)}`;
            const notesLine = a.notes ? `  └ Nota: ${a.notes}` : '';
            return [personLine, notesLine].filter(Boolean).join('\n');
          }).join('\n\n')
        : 'Sense assignacions';

      const statusText = ef.personnelComplete ? 'Complet' : 'Incomplet';

      return [
        ef.name,
        ef.place || '-',
        formatDateRangeDMY(ef.startDate, ef.endDate),
        personnelText,
        statusText,
        ef.generalNotes || '-'
      ];
    });

    autoTable(pdf, {
      head,
      body,
      startY: y,
      theme: 'grid',
      styles: { fontSize: 8, cellPadding: 2, overflow: 'linebreak' },
      headStyles: { fillColor: hslToRgb(...themeHslColors.grayMedium), textColor: hslToRgb(...themeHslColors.foregroundWhite), fontStyle: 'bold' },
      columnStyles: {
        3: { cellWidth: 85 },
        5: { cellWidth: 60 }
      },
      didDrawPage: (_data: any) => {
        if (_data.pageNumber > 1) {
            createPdfHeader(pdf, "Llista d'Esdeveniments");
        }
      },
      margin: { top: 30, bottom: 15 }
    });

    const totalPages = (pdf.internal as any).getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      addFooter(pdf, i);
    }

    const fileName = generateFileName('Llista_Esdeveniments', activeFilters, eventFrames, 'pdf');
    await savePdfWithDialog(pdf, fileName, showToast);
  } catch (error) {
    showToast(`Error generant PDF: ${(error as Error).message}`, 'error');
  }
};
--- END: ../Gestor-Events_i_Personal/src/utils/pdfGenerator.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/selectors.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { EventFrame, Assignment, AssignmentStatus } from '../types';

/**
 * Selector per obtenir les vistes filtrades d'eventFrames
 * Aquest selector evita bucles de renderitzat perquè calcula les dades derivades al moment
 */
export const selectFilteredEventFrames = (state: {
  eventFrames: EventFrame[];
  peopleGroups: { id: string; name: string }[];
  filterText: string;
  filterStatus: AssignmentStatus | '';
  filterDate: string;
  localFilterUIPerson: string;
  filterPlace: string;
  filterUIEventFrame: string | null;
  showArchived?: boolean;
}) => {
  const {
    eventFrames,
    peopleGroups,
    filterText,
    filterStatus,
    filterDate,
    localFilterUIPerson,
    filterPlace,
    filterUIEventFrame,
    showArchived = false
  } = state;

  // Crear mapa de persones per eficiència
  const peopleMap = new Map<string, string>();
  peopleGroups.forEach(p => peopleMap.set(p.id, p.name));

  try {
    let frames = [...eventFrames];

    // 1. Filter by archive status
    if (showArchived) {
        frames = frames.filter(ef => ef.isArchived === true);
    } else {
        frames = frames.filter(ef => ef.isArchived !== true);
    }

    // Aplicar filtres
    if (filterUIEventFrame) {
      frames = frames.filter(ef => ef.id === filterUIEventFrame);
    }
    
    if (filterPlace) {
      const normPlace = filterPlace.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      frames = frames.filter(ef => 
        ef.place && 
        ef.place.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').includes(normPlace)
      );
    }
    
    if (!filterUIEventFrame) {
      if (filterText) {
        const lowerFilterText = filterText.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        frames = frames.filter(ef => {
          const efFields = [ef.name, ef.place || '', ef.generalNotes || '']
            .join(' ')
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '');
          
          const assignFields = ef.assignments
            .map((a: Assignment) => [
              peopleMap.get(a.personGroupId) || '', 
              a.notes || ''
            ].join(' '))
            .join(' ')
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '');
          
          return efFields.includes(lowerFilterText) || assignFields.includes(lowerFilterText);
        });
      }
      
      if (filterStatus) {
        frames = frames.filter(ef => 
          ef.assignments.some((a: Assignment) => 
            a.status === filterStatus || 
            (a.status === AssignmentStatus.Mixed && 
             a.dailyStatuses && 
             Object.values(a.dailyStatuses).includes(filterStatus))
          )
        );
      }
      
      if (localFilterUIPerson) {
        frames = frames.filter(ef => 
          ef.assignments.some(a => a.personGroupId === localFilterUIPerson)
        );
      }
      
      if (filterDate) {
        frames = frames.filter(ef => 
          new Date(ef.startDate) <= new Date(filterDate) && 
          new Date(ef.endDate) >= new Date(filterDate)
        );
      }
    }

    return frames;
  } catch (error) {
    console.error('[selectFilteredEventFrames] Error aplicant filtres:', error);
    return [];
  }
};

--- END: ../Gestor-Events_i_Personal/src/utils/selectors.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/statusUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { Assignment, AssignmentStatus } from '../types';
import { formatDateRanges } from './dateRangeFormatter';

/**
 * Genera un text descriptiu per a l'estat d'una assignació.
 * Si l'estat és Mixt, agrupa les dates per estat i mostra els rangs.
 * @param assignment - L'objecte de l'assignació.
 * @returns Una cadena de text com "(Sí)" o "(Mixt: Sí [14/05-15/05] No [16/05])".
 */
export const getStatusSummaryText = (assignment: Assignment): string => {
  if (assignment.status !== AssignmentStatus.Mixed || !assignment.dailyStatuses) {
    return `(${assignment.status})`;
  }

  const datesByStatus: { [key in AssignmentStatus]?: string[] } = {};

  Object.entries(assignment.dailyStatuses).forEach(([date, status]) => {
    if (!datesByStatus[status]) {
      datesByStatus[status] = [];
    }
    datesByStatus[status]!.push(date);
  });
  
  const parts = [];
  if (datesByStatus[AssignmentStatus.Yes]?.length) {
    parts.push(`Sí [${formatDateRanges(datesByStatus[AssignmentStatus.Yes])}]`);
  }
  if (datesByStatus[AssignmentStatus.No]?.length) {
    parts.push(`No [${formatDateRanges(datesByStatus[AssignmentStatus.No])}]`);
  }
  if (datesByStatus[AssignmentStatus.Pending]?.length) {
    parts.push(`Pendent [${formatDateRanges(datesByStatus[AssignmentStatus.Pending])}]`);
  }

  if (parts.length === 0) {
     return `(${AssignmentStatus.Mixed})`; // Fallback per si no hi ha estats diaris
  }

  return `(Mixt: ${parts.join(' ')})`;
};

--- END: ../Gestor-Events_i_Personal/src/utils/statusUtils.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/techSheetMigration.ts -- branca DEV_pre-monorepoV1.3.0 ---
import { TechSheetData, EventFrame, ConditionalStatus, NeedItem } from '../types';
import { formatDateDMY } from './dateFormat';
import logger from './logger';

const isObject = (v: any) => v && typeof v === 'object' && !Array.isArray(v);

// This is a minimal version of createDefaultTechSheet to avoid circular dependencies
const createDefaultTechSheetForMigration = (eventFrame: EventFrame): TechSheetData => {
  const defaultConditional = () => ({ status: 'unset' as const, details: '', data: { needs: [] } });
  return {
    eventName: eventFrame.name,
    location: eventFrame.place || '',
    date: formatDateDMY(eventFrame.startDate),
    showTimes: [],
    showDuration: '',
    technicalProviders: [],
    generalNotes: '',
    parking: { status: 'unset', details: '' },
    preAssembly: { status: 'unset', details: '' },
    schedule: { status: 'unset', details: '', data: [] },
    dressingRooms: { status: 'unset', details: '' },
    actorsInfo: { status: 'unset', details: '', data: { number: 0, names: '' } },
    techniciansInfo: { status: 'unset', details: '', data: { number: 0, names: '' } },
    lighting: defaultConditional(),
    sound: defaultConditional(),
    video: defaultConditional(),
    machinery: defaultConditional(),
    rentals: defaultConditional(),
    otherEquipment: defaultConditional(),
    electrical: defaultConditional(),
    structures: defaultConditional(),
    platforms: defaultConditional(),
    consumables: defaultConditional(),
    curtains: defaultConditional(),
    transport: defaultConditional(),
    controlLocation: '',
    blueprints: '',
    contacts: [],
    observations: '',
    showLogistics: true,
    showPreAssembly: true,
    showSchedule: true,
    showNeeds: true,
    showOther: true,
    showGeneralNotesInPdf: true,
  };
};


export const migrateTechSheetData = (data: any, eventFrame: EventFrame): TechSheetData => {
  try {
    // Check if data is already in the new format
    if (data && isObject(data.lighting) && isObject(data.sound)) {
        return data as TechSheetData;
    }

    const oldData = data || {};
    const defaultSheet = createDefaultTechSheetForMigration(eventFrame);

    const fromStringToStatus = (val: any): ConditionalStatus => {
        if (typeof val !== 'string' || val.trim() === '' || val.trim() === '--') return 'unset';
        if (val.toUpperCase().startsWith('SI')) return 'yes';
        if (val.toUpperCase().startsWith('NO')) return 'no';
        return 'yes';
    };

    const extractDetails = (val: any): string => {
        if (typeof val !== 'string') return '';
        return val.replace(/^SI:?\s*/i, '').trim();
    };

    const migrateNeeds = (oldNeeds: any, oldDetails?: any) => {
        const needs = (Array.isArray(oldNeeds) ? oldNeeds : []) as NeedItem[];
        const details = extractDetails(oldDetails);
        const status = fromStringToStatus(oldDetails);
        // If there are needs but status is unset, make it 'yes'
        const finalStatus = (status === 'unset' && needs.length > 0) ? 'yes' : status;
        return { status: finalStatus, details, data: { needs } };
    };

    const newSheet: TechSheetData = {
        ...defaultSheet,

        eventName: oldData.eventName || eventFrame.name,
        location: oldData.location || eventFrame.place || '',
        date: oldData.date || (eventFrame.startDate === eventFrame.endDate ? formatDateDMY(eventFrame.startDate) : `${formatDateDMY(eventFrame.startDate)} - ${formatDateDMY(eventFrame.endDate)}`),
        showTimes: oldData.showTime ? [{ id: 'migrated-time-1', time: oldData.showTime }] : [],
        showDuration: oldData.showDuration || '',
        technicalProviders: (oldData.technicalProviders || []).map((p: any) => ({
            ...p,
            roles: (p.roles || []).map((r: any) => ({ ...r, printNotes: r.printNotes ?? true }))
        })),

        generalNotes: oldData.generalNotes || '',
        parking: {
            status: fromStringToStatus(oldData.parkingInfo),
            details: extractDetails(oldData.parkingInfo),
        },
        preAssembly: {
            status: fromStringToStatus(oldData.preAssemblySchedule),
            details: extractDetails(oldData.preAssemblySchedule),
        },
        schedule: {
            status: fromStringToStatus(oldData.preAssemblySchedule),
            details: '',
            data: (oldData.assemblySchedule || []).map((item: any, index: number) => ({ id: `migrated-sched-${index}`, date: '', time: item.time || '', description: item.description || '' })),
        },

        lighting: migrateNeeds(oldData.lightingNeeds),
        sound: migrateNeeds(oldData.soundNeeds),
        machinery: migrateNeeds(oldData.machineryNeeds),
        video: migrateNeeds(oldData.videoNeeds, oldData.videoDetails),
        rentals: migrateNeeds(oldData.rentalsNeeds, oldData.rentals),
        otherEquipment: migrateNeeds(oldData.otherEquipmentNeeds, oldData.otherEquipment),

        controlLocation: oldData.controlLocation || '',
        blueprints: oldData.blueprints || '',
        contacts: oldData.companyContact ? [{ id: 'migrated-contact-1', name: oldData.companyContact, role: '', phone: '', email: '' }] : (oldData.contacts || []),
        observations: oldData.observations || '',

        showLogistics: oldData.showLogistics ?? true,
        showPreAssembly: oldData.showPreAssembly ?? true,
        showSchedule: oldData.showSchedule ?? true,
        showNeeds: oldData.showNeeds ?? true,
        showOther: oldData.showOther ?? true,
        showGeneralNotesInPdf: oldData.showGeneralNotesInPdf ?? true,

        technicalPersonnelNotes: oldData.technicalPersonnelNotes || '',
        showTechnicalPersonnelNotesInPdf: oldData.showTechnicalPersonnelNotesInPdf ?? true,
        technicalNeedsNotes: oldData.technicalNeedsNotes || '',
        showTechnicalNeedsNotesInPdf: oldData.showTechnicalNeedsNotesInPdf ?? true,
        showScheduleNotesInPdf: oldData.showScheduleNotesInPdf ?? true,
    };

    return newSheet;

  } catch (error) {
    logger.error("Error migrating tech sheet data. Returning default sheet.", { error, originalData: data });
    return createDefaultTechSheetForMigration(eventFrame);
  }
};

--- END: ../Gestor-Events_i_Personal/src/utils/techSheetMigration.ts -- branca DEV_pre-monorepoV1.3.0 ---

--- START: ../Gestor-Events_i_Personal/src/utils/themeDefinition.ts -- branca DEV_pre-monorepoV1.3.0 ---
/**
 * ATENCIÓ: AQUEST FITXER ÉS AUTO-GENERAT.
 * NO EDITAR MANUALMENT.
 *
 * Aquest fitxer defineix els colors del tema en format HSL per ser utilitzats
 * en contextos on les variables CSS no són accessibles, com la generació de PDFs.
 * Es genera a partir de 'theme.config.js' executant 'npm run build:theme'.
 * Per fer canvis, modifica 'theme.config.js' i torna a executar l'script.
 */

export const themeHslColors = {
  primary: [220, 35, 25],
  success: [140, 65, 40],
  warning: [45, 85, 55],
  destructive: [0, 75, 55],
  foreground: [240, 10, 10],
  foregroundMuted: [240, 5, 40],
  foregroundWhite: [210, 40, 98],
  grayDark: [40, 6, 20],
  grayBorder: [35, 10, 50],
  grayMuted: [35, 10, 83],
  grayMedium: [75, 85, 99],
  graySubtle: [240, 5, 92],
  grayLightest: [240, 5, 98],
  orange: [25, 95, 53],
} as const;

--- END: ../Gestor-Events_i_Personal/src/utils/themeDefinition.ts -- branca DEV_pre-monorepoV1.3.0 ---


==================================================
=== RESUM D'EXCLUSIONS A L'ARREL ===

Fitxers exclosos de l'arrel:
- .gitattributes
- .gitignore
- LICENSE
- google-credentials.json
- package-lock.json
- service-account.json

Directoris exclosos de l'arrel:
- .git/
- .github/
- .idea/
- build/
- captures_pantalla/
- examples json/
- imatges/
- node_modules/
- packages/
- public/
- scripts/
